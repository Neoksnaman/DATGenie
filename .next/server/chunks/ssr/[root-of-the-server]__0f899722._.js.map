{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/schemas.ts"],"sourcesContent":["\nimport { z } from 'zod';\n\nconst alphanumericWithSpaces = (name: string, length: number, required = true) => {\n  const schema = z.string()\n   .max(length, `${name} must be ${length} characters or less.`)\n   .regex(/^[a-zA-Z0-9\\s]*$/, `${name} must only contain letters, numbers, and spaces.`);\n  \n  if (required) {\n    return schema.min(1, `${name} is required.`);\n  }\n  return schema.optional().or(z.literal(''));\n};\n\nexport const TaxProfileSchema = z.object({\n  tpTIN: z.string().regex(/^[0-9]{9}$/, 'TIN must be 9 digits.'),\n  branchCode: z.string().regex(/^[0-9]{4}$/, 'Branch code must be 4 digits.'),\n  rdoCode: z.string().min(1, 'RDO Code is required.'),\n  entityType: z.string(),\n  cycleType: z.string(),\n  monthSelect: z.string().min(1, 'Month is required.'),\n  companyName: alphanumericWithSpaces('Company Name', 50, false),\n  lastName: alphanumericWithSpaces('Last Name', 30, false),\n  firstName: alphanumericWithSpaces('First Name', 30, false),\n  middleName: alphanumericWithSpaces('Middle Name', 30, false),\n  tradeName: alphanumericWithSpaces('Trade Name', 50),\n  subStreet: z.string().max(30, 'Unit/Floor/Substreet must be 30 characters or less.').optional().or(z.literal('')),\n  street: z.string().max(30, 'Street must be 30 characters or less.').min(1, 'Street is required.'),\n  barangay: z.string().max(30, 'Barangay must be 30 characters or less.').min(1, 'Barangay is required.'),\n  cityMunicipality: z.string().max(30, 'City/Municipality must be 30 characters or less.').min(1, 'City/Municipality is required.'),\n  province: z.string().max(30, 'Province must be 30 characters or less.').min(1, 'Province is required.'),\n  zipCode: z.string().regex(/^[0-9]{4}$/, 'Zip code must be 4 digits.'),\n}).passthrough().refine(data => {\n    if (data.entityType === 'Individual') {\n        return !!data.lastName && !!data.firstName && !!data.middleName;\n    }\n    return true;\n}, {\n    message: \"First, Middle, and Last name are required for individuals.\",\n    path: [\"lastName\"], \n}).refine(data => {\n    if (data.entityType === 'Non-Individual') {\n        return !!data.companyName;\n    }\n    return true;\n}, {\n    message: \"Company name is required for non-individuals.\",\n    path: [\"companyName\"],\n});\n\n\nexport type TaxProfile = z.infer<typeof TaxProfileSchema>;\n\n\nexport const MutationResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    data: TaxProfileSchema.nullable(),\n});\n\nexport const DatFileSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  path: z.string(),\n  modifiedTime: z.string(),\n});\nexport type DatFile = z.infer<typeof DatFileSchema>;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/drive-oauth.ts"],"sourcesContent":["\nimport { google } from 'googleapis';\n\nconst {\n  GOOGLE_OAUTH_CLIENT_ID,\n  GOOGLE_OAUTH_CLIENT_SECRET,\n  GOOGLE_OAUTH_REFRESH_TOKEN,\n} = process.env;\n\nif (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n  // This check is important but shouldn't throw an error that crashes the server on startup,\n  // as the credentials might not be used on every page load.\n  // We will let the functions that use it handle the error.\n  console.warn('Google OAuth credentials are not fully configured in .env. Some Drive/Sheets features may not work.');\n}\n\n// This is a fixed value for web applications\nconst GOOGLE_OAUTH_REDIRECT_URI = 'https://developers.google.com/oauthplayground';\n\nlet oauth2Client: import('google-auth-library').OAuth2Client | null = null;\n\nexport async function getOAuth2Client() {\n  // Add the check here to provide a clear error when the credentials are used.\n  if (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n    throw new Error('Google OAuth credentials (CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN) must be configured in your .env file.');\n  }\n  \n  if (oauth2Client) {\n    // Check if the token is about to expire (within 60 seconds) and refresh if needed\n    if (oauth2Client.credentials.expiry_date && oauth2Client.credentials.expiry_date < (Date.now() + 60 * 1000)) {\n        console.log('[OAuth] Access token expiring soon, refreshing...');\n        await oauth2Client.refreshAccessToken();\n        console.log('[OAuth] Access token refreshed.');\n    }\n    return oauth2Client;\n  }\n\n  const client = new google.auth.OAuth2(\n    GOOGLE_OAUTH_CLIENT_ID,\n    GOOGLE_OAUTH_CLIENT_SECRET,\n    GOOGLE_OAUTH_REDIRECT_URI\n  );\n\n  client.setCredentials({\n    refresh_token: GOOGLE_OAUTH_REFRESH_TOKEN,\n  });\n\n  // Do an initial token refresh to get the access token\n  try {\n    console.log('[OAuth] Initializing and refreshing access token...');\n    await client.refreshAccessToken();\n    console.log('[OAuth] Initial token refreshed successfully.');\n  } catch (error) {\n    console.error('[OAuth] Failed to refresh access token:', error);\n    throw new Error('Failed to refresh access token. Check your refresh token and credentials.');\n  }\n\n  oauth2Client = client;\n  return oauth2Client;\n}\n\nexport async function getSheetsClient() {\n    const oauth2Client = await getOAuth2Client();\n    return google.sheets({ version: 'v4', auth: oauth2Client });\n}\n"],"names":[],"mappings":";;;;AACA;;AAEA,MAAM,EACJ,sBAAsB,EACtB,0BAA0B,EAC1B,0BAA0B,EAC3B,GAAG,QAAQ,GAAG;AAEf,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;IACzF,2FAA2F;IAC3F,2DAA2D;IAC3D,0DAA0D;IAC1D,QAAQ,IAAI,CAAC;AACf;AAEA,6CAA6C;AAC7C,MAAM,4BAA4B;AAElC,IAAI,eAAkE;AAE/D,eAAe;IACpB,6EAA6E;IAC7E,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;QACzF,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,cAAc;QAChB,kFAAkF;QAClF,IAAI,aAAa,WAAW,CAAC,WAAW,IAAI,aAAa,WAAW,CAAC,WAAW,GAAI,KAAK,GAAG,KAAK,KAAK,MAAO;YACzG,QAAQ,GAAG,CAAC;YACZ,MAAM,aAAa,kBAAkB;YACrC,QAAQ,GAAG,CAAC;QAChB;QACA,OAAO;IACT;IAEA,MAAM,SAAS,IAAI,mJAAA,CAAA,SAAM,CAAC,IAAI,CAAC,MAAM,CACnC,wBACA,4BACA;IAGF,OAAO,cAAc,CAAC;QACpB,eAAe;IACjB;IAEA,sDAAsD;IACtD,IAAI;QACF,QAAQ,GAAG,CAAC;QACZ,MAAM,OAAO,kBAAkB;QAC/B,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,eAAe;IACf,OAAO;AACT;AAEO,eAAe;IAClB,MAAM,eAAe,MAAM;IAC3B,OAAO,mJAAA,CAAA,SAAM,CAAC,MAAM,CAAC;QAAE,SAAS;QAAM,MAAM;IAAa;AAC7D","debugId":null}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/googlesheets.ts"],"sourcesContent":["\nimport { z } from 'zod';\nimport type { TaxProfile } from './schemas';\nimport { getSheetsClient } from './drive-oauth';\n\nconst signupSchema = z.object({\n  userName: z.string(),\n  email: z.string().email(),\n  password: z.string(),\n  folderId: z.string(),\n});\n\nconst loginSchema = z.object({\n  userName: z.string(),\n  password: z.string(),\n});\n\nexport type SignupData = z.infer<typeof signupSchema>;\nexport type LoginData = z.infer<typeof loginSchema>;\n\n\nconst {\n  GOOGLE_SHEETS_SHEET_ID,\n} = process.env;\n\nif (!GOOGLE_SHEETS_SHEET_ID) {\n  throw new Error('GOOGLE_SHEETS_SHEET_ID is not configured in .env');\n}\n\nconst SPREADSHEET_ID = GOOGLE_SHEETS_SHEET_ID;\nconst SHEET_NAME = 'credentials';\n\nexport async function appendUserToSheet(userData: SignupData) {\n  const { email, userName, password, folderId } = userData;\n  const timestamp = new Date().toISOString();\n  const sheets = await getSheetsClient();\n\n  // Mapping to sheet headers: emailAddress, userName, pwd, databaseID, folderID, status, lastLogin, runtime\n  const values = [[email, userName, password, '', folderId, 'active', timestamp, '']];\n\n  const request = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${SHEET_NAME}!A1`, // Appends to the first empty row of the sheet\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function getAllUsers() {\n    try {\n        const sheets = await getSheetsClient();\n        const response = await sheets.spreadsheets.values.get({\n            spreadsheetId: SPREADSHEET_ID,\n            range: SHEET_NAME,\n        });\n\n        const rows = response.data.values;\n        if (!rows || rows.length === 0) {\n            return [];\n        }\n\n        const header = rows[0];\n        const emailIndex = header.indexOf('emailAddress');\n        const userNameIndex = header.indexOf('userName');\n        const pwdIndex = header.indexOf('pwd');\n        const databaseIdIndex = header.indexOf('databaseID');\n        const folderIdIndex = header.indexOf('folderID');\n\n        if (userNameIndex === -1 || pwdIndex === -1 || emailIndex === -1 || databaseIdIndex === -1 || folderIdIndex === -1) {\n            throw new Error('Could not find required columns in the credentials sheet.');\n        }\n\n        return rows.slice(1).map(row => ({\n            emailAddress: row[emailIndex] || '',\n            userName: row[userNameIndex] || '',\n            pwd: row[pwdIndex] || '',\n            databaseId: row[databaseIdIndex] || '',\n            folderId: row[folderIdIndex] || '',\n        }));\n\n    } catch (err) {\n        console.error('The API returned an error: ' + err);\n        throw new Error('Failed to retrieve data from Google Sheet.');\n    }\n}\n\nexport async function updateUserFolderId(userName: string, folderId: string) {\n    const sheets = await getSheetsClient();\n    const range = `${SHEET_NAME}!A:H`; // Adjust range to cover all columns\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const folderIdIndex = header.indexOf('folderID');\n\n    if (userNameIndex === -1 || folderIdIndex === -1) {\n        throw new Error('userName or folderID column not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === userName);\n    if (userRowIndex === -1) {\n        throw new Error(`User ${userName} not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + folderIdIndex);\n\n    await sheets.spreadsheets.values.update({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [[folderId]],\n        },\n    });\n}\n\n\nexport async function getAllHeaderDataFromSheet(databaseId: string): Promise<TaxProfile[]> {\n  try {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.values.get({\n      spreadsheetId: databaseId,\n      range: 'tpList!A:Q',\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    const header = rows[0];\n    const dataRows = rows.slice(1);\n    \n    const objects = dataRows\n        .map(row => {\n            const rowData: { [key: string]: any } = {};\n            header.forEach((key, headerIndex) => {\n                rowData[key] = row[headerIndex] || '';\n            });\n            return rowData as TaxProfile;\n        })\n        .filter(profile => profile.tpTIN && typeof profile.tpTIN === 'string' && profile.tpTIN.trim() !== '');\n\n    return objects;\n\n  } catch (err) {\n    console.error(`The API returned an error for spreadsheet ${databaseId}: ` + err);\n    throw new Error('Failed to retrieve header data from Google Sheet.');\n  }\n}\n\nexport async function appendHeaderDataToSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const headerResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range: 'tpList!A1:Q1',\n  });\n  \n  const headers = headerResponse.data.values?.[0];\n  if (!headers) {\n    throw new Error('Could not retrieve headers from tpList sheet.');\n  }\n\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function updateHeaderDataInSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const range = 'tpList!A:Q';\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    throw new Error('No data found in the sheet.');\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n  \n  const rowIndex = rows.findIndex(row => row[tinIndex] === profileData.tpTIN);\n\n  if (rowIndex === -1) {\n    throw new Error('Profile with the specified TIN not found.');\n  }\n  \n  const rowToUpdate = rowIndex + 1;\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A${rowToUpdate}`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.update(request);\n    console.log('Updated sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to update data in Google Sheet.');\n  }\n}\n\nasync function getSheetId(spreadsheetId: string, sheetName: string): Promise<number | null> {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.get({\n        spreadsheetId,\n    });\n    const sheet = response.data.sheets?.find(s => s.properties?.title === sheetName);\n    return sheet?.properties?.sheetId ?? null;\n}\n\nexport async function deleteHeaderDataRowInSheet(tpTIN: string, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const sheetName = 'tpList';\n  const range = `${sheetName}!A:Q`;\n\n  // 1. Get all data to find the row index\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    console.log('No data found in the sheet to delete.');\n    return;\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n\n  const rowIndex = rows.findIndex(row => row[tinIndex] === tpTIN);\n\n  if (rowIndex === -1) {\n    console.log(`Profile with TIN ${tpTIN} not found for deletion.`);\n    return; // Profile not found, so nothing to delete\n  }\n\n  // 2. Get the sheetId required for batchUpdate\n  const sheetId = await getSheetId(databaseId, sheetName);\n  if (sheetId === null) {\n      throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n  }\n\n  // 3. Perform batch update to delete the row and add a blank one\n  const batchUpdateRequest = {\n    spreadsheetId: databaseId,\n    resource: {\n      requests: [\n        {\n          deleteDimension: {\n            range: {\n              sheetId: sheetId,\n              dimension: 'ROWS',\n              startIndex: rowIndex, // The 0-based index of the row to delete.\n              endIndex: rowIndex + 1\n            }\n          }\n        },\n        {\n          appendDimension: {\n            sheetId: sheetId,\n            dimension: \"ROWS\",\n            length: 1\n          }\n        }\n      ]\n    }\n  };\n\n  try {\n    await sheets.spreadsheets.batchUpdate(batchUpdateRequest);\n    console.log(`Successfully deleted row at index ${rowIndex} and added a new one.`);\n  } catch (err) {\n    console.error('The API returned an error during batch update: ' + err);\n    throw new Error('Failed to delete row from Google Sheet.');\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions/profiles.ts"],"sourcesContent":["'use server';\n\nimport type { TaxProfile } from '@/lib/schemas';\nimport { TaxProfileSchema, MutationResultSchema } from '@/lib/schemas';\nimport { getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, deleteHeaderDataRowInSheet } from '../googlesheets';\nimport { z } from 'zod';\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 761, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/drive.ts"],"sourcesContent":["\n'use server';\n\nimport { google } from 'googleapis';\nimport type { drive_v3 } from 'googleapis';\nimport { getOAuth2Client } from './drive-oauth';\nimport type { DatFile } from './schemas';\n\n\nasync function getDriveClient(): Promise<drive_v3.Drive> {\n    const oauth2Client = await getOAuth2Client();\n    return google.drive({ version: 'v3', auth: oauth2Client });\n}\n\n/**\n * Creates a root folder for a user.\n * @param name The name of the folder to create.\n * @returns The ID of the created folder.\n */\nexport async function createFolderInDrive(name: string): Promise<string> {\n    const drive = await getDriveClient();\n    const fileMetadata = {\n        name,\n        mimeType: 'application/vnd.google-apps.folder',\n    };\n    try {\n        const file = await drive.files.create({\n            resource: fileMetadata,\n            fields: 'id',\n        });\n        console.log(`[Drive] Created root folder \"${name}\" with ID: ${file.data.id}`);\n        return file.data.id!;\n    } catch (error) {\n        console.error(`[Drive] Error creating root folder \"${name}\":`, error);\n        throw error;\n    }\n}\n\nasync function findFolder(drive: drive_v3.Drive, name: string, parentId: string): Promise<string | null> {\n    const query = `mimeType='application/vnd.google-apps.folder' and name='${name.replace(/'/g, \"\\\\'\")}' and '${parentId}' in parents and trashed=false`;\n    try {\n        const res = await drive.files.list({\n            q: query,\n            fields: 'files(id)',\n            spaces: 'drive',\n            pageSize: 1,\n        });\n        if (res.data.files && res.data.files.length > 0 && res.data.files[0].id) {\n            return res.data.files[0].id;\n        }\n        return null;\n    } catch (error) {\n        console.error(`[Drive] Error finding folder \"${name}\" in parent \"${parentId}\":`, error);\n        return null;\n    }\n}\n\nasync function createFolder(drive: drive_v3.Drive, name: string, parentId: string): Promise<string> {\n    const fileMetadata = {\n        name: name,\n        mimeType: 'application/vnd.google-apps.folder',\n        parents: [parentId],\n    };\n    const folder = await drive.files.create({\n        resource: fileMetadata,\n        fields: 'id',\n    });\n    if (!folder.data.id) throw new Error(`Failed to create folder \"${name}\"`);\n    console.log(`[Drive] Created folder \"${name}\" with ID: ${folder.data.id}.`);\n    return folder.data.id;\n}\n\n\nasync function getOrCreateFolderByPath(drive: drive_v3.Drive, rootFolderId: string, path: string[]): Promise<string> {\n    let currentParentId = rootFolderId;\n    \n    const datFilesFolderName = 'DATFiles';\n    let datFilesFolderId = await findFolder(drive, datFilesFolderName, currentParentId);\n    if (!datFilesFolderId) {\n        datFilesFolderId = await createFolder(drive, datFilesFolderName, currentParentId);\n    }\n    currentParentId = datFilesFolderId;\n\n    for (const folderName of path) {\n        let nextFolderId = await findFolder(drive, folderName, currentParentId);\n        if (!nextFolderId) {\n            nextFolderId = await createFolder(drive, folderName, currentParentId);\n        }\n        currentParentId = nextFolderId;\n    }\n    return currentParentId;\n}\n\nexport async function checkFileExists(fileName: string, rootFolderId: string, path: string[]): Promise<boolean> {\n    try {\n        const drive = await getDriveClient();\n        const finalFolderId = await getOrCreateFolderByPath(drive, rootFolderId, path);\n        const query = `name='${fileName.replace(/'/g, \"\\\\'\")}' and '${finalFolderId}' in parents and trashed=false`;\n        \n        const res = await drive.files.list({\n            q: query,\n            fields: 'files(id)',\n            pageSize: 1,\n        });\n\n        return !!(res.data.files && res.data.files.length > 0);\n    } catch (error) {\n        console.error(`[Drive] Error checking if file '${fileName}' exists:`, error);\n        return false;\n    }\n}\n\n/**\n * Uploads or updates a file in a specific Google Drive folder path.\n * @param fileName The name of the file.\n * @param fileContent The content of the file.\n * @param rootFolderId The ID of the user's root folder in Drive.\n * @param path An array representing the folder path inside \"DATFiles\".\n * @param overwrite If true, will update the existing file. If false, will not upload if file exists.\n * @returns The DatFile object for the created/updated file.\n */\nexport async function uploadFileToDrive(fileName: string, fileContent: string, rootFolderId: string, path: string[], overwrite: boolean = false): Promise<DatFile> {\n  try {\n    const drive = await getDriveClient();\n    const finalFolderId = await getOrCreateFolderByPath(drive, rootFolderId, path);\n    console.log(`[Drive] Final folder for upload is '${finalFolderId}'.`);\n\n    const media = {\n        mimeType: 'text/plain',\n        body: fileContent,\n    };\n    \n    const fileFields = 'id, name, modifiedTime';\n\n    if (overwrite) {\n        const query = `name='${fileName.replace(/'/g, \"\\\\'\")}' and '${finalFolderId}' in parents and trashed=false`;\n        const res = await drive.files.list({ q: query, fields: 'files(id)', pageSize: 1 });\n\n        if (res.data.files && res.data.files.length > 0 && res.data.files[0].id) {\n            const fileId = res.data.files[0].id;\n            console.log(`[Drive] Overwriting existing file '${fileName}' with ID: ${fileId}`);\n            const updatedFile = await drive.files.update({\n                fileId: fileId,\n                media: media,\n                fields: fileFields,\n            });\n            if (!updatedFile.data.id || !updatedFile.data.name || !updatedFile.data.modifiedTime) {\n                throw new Error('File update did not return complete data.');\n            }\n             return { id: updatedFile.data.id, name: updatedFile.data.name, path: path.join(' / '), modifiedTime: updatedFile.data.modifiedTime };\n        }\n    }\n    \n    // If not overwriting or file doesn't exist, create a new one.\n    const fileMetadata = {\n      name: fileName,\n      parents: [finalFolderId],\n    };\n\n    const file = await drive.files.create({\n      requestBody: fileMetadata,\n      media: media,\n      fields: fileFields,\n    });\n\n    if (!file.data.id || !file.data.name || !file.data.modifiedTime) {\n        throw new Error('File creation did not return complete data.');\n    }\n    console.log(`[Drive] Successfully uploaded new file '${fileName}', File ID: ${file.data.id}`);\n    return { id: file.data.id, name: file.data.name, path: path.join(' / '), modifiedTime: file.data.modifiedTime };\n\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    console.error(`[Drive] Failed to upload file '${fileName}':`, errorMessage);\n    throw new Error(`Failed to upload file to Google Drive: ${errorMessage}`);\n  }\n}\n\n/**\n * Lists all .DAT files within a user's DATFiles directory structure and all subfolder IDs.\n * @param rootFolderId The root folder ID for the user.\n * @returns A list of file details and a list of all folder IDs within the DATFiles structure.\n */\nexport async function listDatFiles(rootFolderId: string): Promise<{ files: DatFile[]; folderIds: string[] }> {\n    const drive = await getDriveClient();\n\n    const datFilesFolderId = await findFolder(drive, \"DATFiles\", rootFolderId);\n    if (!datFilesFolderId) {\n        console.log('[Drive] \"DATFiles\" folder not found, returning empty list.');\n        return { files: [], folderIds: [] };\n    }\n\n    const folderMap = new Map<string, { name: string; parentId: string }>();\n    const allFiles: DatFile[] = [];\n    const allFolderIds = new Set<string>([datFilesFolderId]);\n\n    async function walkFolders(folderId: string): Promise<void> {\n        let pageToken: string | undefined = undefined;\n        do {\n            const res = await drive.files.list({\n                q: `'${folderId}' in parents and trashed=false`,\n                fields: \"nextPageToken, files(id, name, mimeType, modifiedTime, parents)\",\n                spaces: \"drive\",\n                pageToken,\n                pageSize: 1000,\n            });\n\n            const folderPromises: Promise<void>[] = [];\n\n            if (res.data.files) {\n                for (const file of res.data.files) {\n                    if (file.mimeType === \"application/vnd.google-apps.folder\") {\n                        if (file.id) {\n                            allFolderIds.add(file.id);\n                            if (file.parents && file.parents.length > 0) {\n                                folderMap.set(file.id, { name: file.name!, parentId: file.parents[0] });\n                            }\n                            folderPromises.push(walkFolders(file.id));\n                        }\n                    } else if (file.name?.endsWith(\".DAT\")) {\n                        let pathParts: string[] = [];\n                        let currentParentId = file.parents?.[0];\n\n                        while (currentParentId && currentParentId !== datFilesFolderId) {\n                            const parentFolder = folderMap.get(currentParentId);\n                            if (parentFolder) {\n                                pathParts.unshift(parentFolder.name);\n                                currentParentId = parentFolder.parentId;\n                            } else {\n                                break;\n                            }\n                        }\n\n                        allFiles.push({\n                            id: file.id!,\n                            name: file.name!,\n                            path: pathParts.join(\" / \"),\n                            modifiedTime: file.modifiedTime!,\n                        });\n                    }\n                }\n            }\n            await Promise.all(folderPromises);\n            pageToken = res.data.nextPageToken;\n        } while (pageToken);\n    }\n\n    folderMap.set(datFilesFolderId, { name: \"DATFiles\", parentId: rootFolderId });\n    await walkFolders(datFilesFolderId);\n\n    return { files: allFiles, folderIds: Array.from(allFolderIds) };\n}\n\n\n\n/**\n * Downloads the content of a file from Google Drive.\n * @param fileId The ID of the file to download.\n * @returns The content of the file as a string.\n */\nexport async function downloadFileFromDrive(fileId: string): Promise<string> {\n    const drive = await getDriveClient();\n    try {\n        const response = await drive.files.get(\n            { fileId: fileId, alt: 'media' },\n            { responseType: 'stream' }\n        );\n\n        return new Promise((resolve, reject) => {\n            let buf: any[] = [];\n            response.data\n                .on('data', (chunk) => buf.push(chunk))\n                .on('end', () => {\n                    const content = Buffer.concat(buf).toString();\n                    resolve(content);\n                })\n                .on('error', (err) => {\n                    console.error(`[Drive] Error downloading file ${fileId}:`, err);\n                    reject(err);\n                });\n        });\n\n    } catch (error: any) {\n        if (error.code === 404) {\n            throw new Error('File not found.');\n        }\n        console.error(`[Drive] API error on download for file ${fileId}:`, error);\n        throw error;\n    }\n}\n\n\n/**\n * Deletes a file from Google Drive permanently.\n * @param fileId The ID of the file to delete.\n */\nexport async function deleteFileFromDrive(fileId: string): Promise<void> {\n    const drive = await getDriveClient();\n    try {\n        await drive.files.delete({\n            fileId: fileId,\n        });\n        console.log(`[Drive] Successfully deleted file with ID: ${fileId}`);\n    } catch (error: any) {\n        if (error.code === 404) {\n            throw new Error('File not found.');\n        }\n        console.error(`[Drive] Error deleting file ${fileId}:`, error);\n        throw error;\n    }\n}\n\n/**\n * Gets the starting page token for the changes feed for the entire user's Drive.\n * @returns The starting page token.\n */\nexport async function getInitialPageTokenForDrive(): Promise<string> {\n    const drive = await getDriveClient();\n    try {\n        const response = await drive.changes.getStartPageToken({\n             supportsAllDrives: true,\n        });\n        if (!response.data.startPageToken) {\n            throw new Error('Failed to get a start page token.');\n        }\n        return response.data.startPageToken;\n    } catch (error) {\n        console.error('[Drive] Error getting initial page token:', error);\n        throw error;\n    }\n}\n\n/**\n * Lists changes for a user's account and checks if they are relevant to the user's folder structure.\n * @param allFolderIds An array of all folder IDs that belong to the user's DAT file structure.\n * @param pageToken The page token from which to retrieve changes.\n * @returns An object with hasChanges boolean and the new page token.\n */\nexport async function listChangesSincePageToken(\n    allFolderIds: string[],\n    pageToken: string\n): Promise<{ hasChanges: boolean; newPageToken: string }> {\n    const drive = await getDriveClient();\n    let newPageToken = pageToken;\n    let hasRelevantChanges = false;\n    let lastResponse: any;\n\n    try {\n        const folderIdSet = new Set(allFolderIds);\n\n        do {\n            lastResponse = await drive.changes.list({\n                pageToken: newPageToken,\n                spaces: \"drive\",\n                fields: \"nextPageToken, newStartPageToken, changes(fileId, removed, file(name, parents, mimeType))\",\n                includeItemsFromAllDrives: true,\n                supportsAllDrives: true,\n            });\n\n            const changes = lastResponse.data.changes || [];\n\n            if (changes.length > 0) {\n                const relevantChange = changes.some((c: any) => {\n                    // A file was deleted. We can't know its parent, so we must refresh.\n                    if (c.removed) return true; \n\n                    if (c.file && c.file.parents) {\n                        // Check if the file's parent is one of our tracked folders.\n                        const parentIsTracked = c.file.parents.some((p: string) => folderIdSet.has(p));\n                        if (parentIsTracked) {\n                            // It's a folder or a .DAT file within our structure\n                            if (c.file.mimeType === 'application/vnd.google-apps.folder' || c.file.name?.toUpperCase().endsWith(\".DAT\")) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                });\n\n                if (relevantChange) {\n                    hasRelevantChanges = true;\n                    break; \n                }\n            }\n\n            if (lastResponse.data.nextPageToken) {\n                newPageToken = lastResponse.data.nextPageToken;\n            } else {\n                break;\n            }\n        } while (lastResponse.data.nextPageToken);\n\n        const finalToken = lastResponse.data.newStartPageToken || newPageToken;\n\n        return { hasChanges: hasRelevantChanges, newPageToken: finalToken };\n    } catch (error) {\n        console.error(\"[Drive] Error listing changes:\", error);\n        return { hasChanges: false, newPageToken: pageToken };\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1148, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions/drive.ts"],"sourcesContent":["'use server';\n\nimport { listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken } from '../drive';\nimport type { DatFile } from '@/lib/schemas';\nimport { DatFileSchema } from '@/lib/schemas';\nimport { z } from 'zod';\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (error: any) {\n        if (error.code === 404) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, error);\n        const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (error: any) {\n        if (error.code === 404) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, error);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAEA;AAEA;AACA;;;;;;;AAGA,MAAM,6BAA6B,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;IAClB,OAAO,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,qHAAA,CAAA,gBAAa,EAAE,QAAQ;IACtC,WAAW,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,oIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ;IACvC,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;AAC5B;AAGO,eAAe,YAAY,QAAgB;IAC9C,IAAI,CAAC,UAAU;QACX,OAAO;YAAE,SAAS;YAAO,OAAO;YAAM,WAAW;YAAM,OAAO;QAA6B;IAC/F;IACA,IAAI;QACA,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,MAAM,CAAA,GAAA,mHAAA,CAAA,eAAY,AAAD,EAAE;QAChD,OAAO;YAAE,SAAS;YAAM;YAAO;YAAW,OAAO;QAAK;IAC1D,EAAE,OAAO,IAAG;QACR,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM,eAAe,cAAa,QAAQ,GAAE,OAAO,GAAG;QACtD,OAAO;YAAE,SAAS;YAAO,OAAO;YAAM,WAAW;YAAM,OAAO,CAAC,8BAA8B,EAAE,cAAc;QAAC;IAClH;AACJ;AAEA,MAAM,6BAA6B,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;IAClB,SAAS,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IAC5B,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;AAC9B;AAGO,eAAe,kBAAkB,MAAc;IAClD,IAAI;QACA,IAAI,CAAC,QAAQ;YACT,OAAO;gBAAE,SAAS;gBAAO,SAAS;gBAAM,OAAO;YAAuB;QAC1E;QACA,MAAM,UAAU,MAAM,CAAA,GAAA,mHAAA,CAAA,wBAAqB,AAAD,EAAE;QAC5C,OAAO;YAAE,SAAS;YAAM,SAAS;YAAS,OAAO;QAAK;IAC1D,EAAE,OAAO,OAAY;QACjB,IAAI,MAAM,IAAI,KAAK,KAAK;YACpB,OAAO;gBAAE,SAAS;gBAAO,SAAS;gBAAM,OAAO;YAAkB;QACrE;QACA,QAAQ,KAAK,CAAC,CAAC,8CAA8C,EAAE,OAAO,CAAC,CAAC,EAAE;QAC1E,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,OAAO;YAAE,SAAS;YAAO,SAAS;YAAM,OAAO,CAAC,iCAAiC,EAAE,cAAc;QAAC;IACtG;AACJ;AAGA,MAAM,qBAAqB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChC,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;IAClB,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;AAC9B;AAIO,eAAe,cAAc,MAAc;IAC9C,IAAI;QACA,IAAI,CAAC,QAAQ;YACT,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAuB;QAC3D;QACA,MAAM,CAAA,GAAA,mHAAA,CAAA,sBAAmB,AAAD,EAAE;QAC1B,OAAO;YAAE,SAAS;YAAM,OAAO;QAAK;IACxC,EAAE,OAAO,OAAY;QACjB,IAAI,MAAM,IAAI,KAAK,KAAK;YACpB,OAAO;gBAAE,SAAS;gBAAO,OAAO;YAAkB;QACtD;QACA,QAAQ,KAAK,CAAC,CAAC,0CAA0C,EAAE,OAAO,CAAC,CAAC,EAAE;QACtE,MAAM,eAAe,aAAa,QAAQ,EAAE,OAAO,GAAG;QACtD,OAAO;YAAE,SAAS;YAAO,OAAO,CAAC,uBAAuB,EAAE,cAAc;QAAC;IAC7E;AACJ;AAEA,MAAM,wBAAwB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrC,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;IAClB,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IAC1B,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;AAC5B;AAGO,eAAe;IAClB,IAAI;QACA,MAAM,QAAQ,MAAM,CAAA,GAAA,mHAAA,CAAA,8BAA2B,AAAD;QAC9C,OAAO;YAAE,SAAS;YAAM;YAAO,OAAO;QAAK;IAC/C,EAAE,OAAO,IAAG;QACR,MAAM,eAAe,cAAa,QAAQ,GAAE,OAAO,GAAG;QACtD,OAAO;YAAE,SAAS;YAAO,OAAO;YAAM,OAAO,CAAC,kCAAkC,EAAE,cAAc;QAAC;IACrG;AACJ;AAEA,MAAM,sBAAsB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnC,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;IAClB,YAAY,oIAAA,CAAA,IAAC,CAAC,OAAO;IACrB,UAAU,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;IAC7B,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ;AAC5B;AAGO,eAAe,uBAAuB,YAAsB,EAAE,SAAiB;IAClF,IAAI,CAAC,gBAAgB,aAAa,MAAM,KAAK,KAAK,CAAC,WAAW;QAC1D,OAAO;YAAE,SAAS;YAAO,YAAY;YAAO,UAAU;YAAM,OAAO;QAA0C;IACjH;IACA,IAAI;QACA,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,GAAG,MAAM,CAAA,GAAA,mHAAA,CAAA,4BAAyB,AAAD,EAAE,cAAc;QACnF,OAAO;YAAE,SAAS;YAAM;YAAY,UAAU;YAAc,OAAO;QAAK;IAC5E,EAAE,OAAO,IAAG;QACR,MAAM,eAAe,cAAa,QAAQ,GAAE,OAAO,GAAG;QACtD,OAAO;YAAE,SAAS;YAAO,YAAY;YAAO,UAAU;YAAW,OAAO,CAAC,6BAA6B,EAAE,cAAc;QAAC;IAC3H;AACJ;;;IAnGsB;IAqBA;IAyBA;IAwBA;IAkBA;;AAxFA,+OAAA;AAqBA,+OAAA;AAyBA,+OAAA;AAwBA,+OAAA;AAkBA,+OAAA","debugId":null}},
    {"offset": {"line": 1343, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/%28app%29/template/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getUserHeaderData as '40b981786947aad3d7b17012761d8eedf3b8c56d37'} from 'ACTIONS_MODULE0'\nexport {getDatFiles as '40a57fcb4a960a37a11746b24812e58ef776483800'} from 'ACTIONS_MODULE1'\nexport {getInitialPageToken as '00e0de5eecd8231df764d2365c49c18983c0b60260'} from 'ACTIONS_MODULE1'\nexport {checkForDatFileChanges as '600ba226d4d3d144eecda0e0fe4cc7cd068fe5c48c'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA","debugId":null}},
    {"offset": {"line": 1413, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/template/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(app)/template/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(app)/template/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAmS,GAChU,iEACA","debugId":null}},
    {"offset": {"line": 1427, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/template/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(app)/template/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(app)/template/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA+Q,GAC5S,6CACA","debugId":null}},
    {"offset": {"line": 1441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}