module.exports = {

"[project]/.next-internal/server/app/api/auth/session/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@opentelemetry/api", () => require("@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/node:events [external] (node:events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:events", () => require("node:events"));

module.exports = mod;
}}),
"[externals]/node:process [external] (node:process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:process", () => require("node:process"));

module.exports = mod;
}}),
"[externals]/node:util [external] (node:util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:util", () => require("node:util"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/http2 [external] (http2, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http2", () => require("http2"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[project]/src/lib/drive-oauth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getOAuth2Client": (()=>getOAuth2Client),
    "getSheetsClient": (()=>getSheetsClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
;
const { GOOGLE_OAUTH_CLIENT_ID, GOOGLE_OAUTH_CLIENT_SECRET, GOOGLE_OAUTH_REFRESH_TOKEN } = process.env;
if (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {
    // This check is important but shouldn't throw an error that crashes the server on startup,
    // as the credentials might not be used on every page load.
    // We will let the functions that use it handle the error.
    console.warn('Google OAuth credentials are not fully configured in .env. Some Drive/Sheets features may not work.');
}
// This is a fixed value for web applications
const GOOGLE_OAUTH_REDIRECT_URI = 'https://developers.google.com/oauthplayground';
let oauth2Client = null;
async function getOAuth2Client() {
    // Add the check here to provide a clear error when the credentials are used.
    if (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {
        throw new Error('Google OAuth credentials (CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN) must be configured in your .env file.');
    }
    if (oauth2Client) {
        // Check if the token is about to expire (within 60 seconds) and refresh if needed
        if (oauth2Client.credentials.expiry_date && oauth2Client.credentials.expiry_date < Date.now() + 60 * 1000) {
            console.log('[OAuth] Access token expiring soon, refreshing...');
            await oauth2Client.refreshAccessToken();
            console.log('[OAuth] Access token refreshed.');
        }
        return oauth2Client;
    }
    const client = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].auth.OAuth2(GOOGLE_OAUTH_CLIENT_ID, GOOGLE_OAUTH_CLIENT_SECRET, GOOGLE_OAUTH_REDIRECT_URI);
    client.setCredentials({
        refresh_token: GOOGLE_OAUTH_REFRESH_TOKEN
    });
    // Do an initial token refresh to get the access token
    try {
        console.log('[OAuth] Initializing and refreshing access token...');
        await client.refreshAccessToken();
        console.log('[OAuth] Initial token refreshed successfully.');
    } catch (error) {
        console.error('[OAuth] Failed to refresh access token:', error);
        throw new Error('Failed to refresh access token. Check your refresh token and credentials.');
    }
    oauth2Client = client;
    return oauth2Client;
}
async function getSheetsClient() {
    const oauth2Client = await getOAuth2Client();
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: oauth2Client
    });
}
}}),
"[project]/src/lib/googlesheets.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "addPendingUser": (()=>addPendingUser),
    "addSessionToSheet": (()=>addSessionToSheet),
    "addUser": (()=>addUser),
    "appendHeaderDataToSheet": (()=>appendHeaderDataToSheet),
    "createDatabaseSheet": (()=>createDatabaseSheet),
    "deleteAllOtherSessionsByToken": (()=>deleteAllOtherSessionsByToken),
    "deleteAllSessionsByEmail": (()=>deleteAllSessionsByEmail),
    "deleteHeaderDataRowInSheet": (()=>deleteHeaderDataRowInSheet),
    "deletePendingUserByRow": (()=>deletePendingUserByRow),
    "deleteSessionByToken": (()=>deleteSessionByToken),
    "findUserByTokenFromSheet": (()=>findUserByTokenFromSheet),
    "getAllHeaderDataFromSheet": (()=>getAllHeaderDataFromSheet),
    "getAllUsers": (()=>getAllUsers),
    "getPendingUserByToken": (()=>getPendingUserByToken),
    "getSessionsByEmail": (()=>getSessionsByEmail),
    "updateHeaderDataInSheet": (()=>updateHeaderDataInSheet),
    "updateUserDataInSheet": (()=>updateUserDataInSheet),
    "updateUserDatabaseId": (()=>updateUserDatabaseId),
    "updateUserFolderId": (()=>updateUserFolderId),
    "updateUserPasswordByEmail": (()=>updateUserPasswordByEmail)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/drive-oauth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/googleapis/build/src/index.js [app-route] (ecmascript)");
;
;
;
const signupSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    userName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    email: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().email(),
    password: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string()
});
const loginSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    userName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string(),
    password: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string()
});
const { GOOGLE_SHEETS_SHEET_ID, GOOGLE_SHEETS_DB_TEMPLATE_ID, GOOGLE_DRIVE_ACCOUNTS_FOLDER_ID } = process.env;
if (!GOOGLE_SHEETS_SHEET_ID) {
    throw new Error('GOOGLE_SHEETS_SHEET_ID is not configured in .env');
}
if (!GOOGLE_SHEETS_DB_TEMPLATE_ID) {
    throw new Error('GOOGLE_SHEETS_DB_TEMPLATE_ID is not configured in .env');
}
if (!GOOGLE_DRIVE_ACCOUNTS_FOLDER_ID) {
    throw new Error('GOOGLE_DRIVE_ACCOUNTS_FOLDER_ID is not configured in .env');
}
const SPREADSHEET_ID = GOOGLE_SHEETS_SHEET_ID;
const TEMPLATE_SPREADSHEET_ID = GOOGLE_SHEETS_DB_TEMPLATE_ID;
const CREDENTIALS_SHEET_NAME = 'credentials';
const PENDING_VERIFICATIONS_SHEET_NAME = 'PendingVerifications';
const SESSIONS_SHEET_NAME = 'ActiveSessions';
async function createDatabaseSheet(userEmail, parentFolderId) {
    const oauth2Client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])();
    const drive = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].drive({
        version: 'v3',
        auth: oauth2Client
    });
    const newSheetName = `Database - ${userEmail}`;
    try {
        const copiedFile = await drive.files.copy({
            fileId: TEMPLATE_SPREADSHEET_ID,
            requestBody: {
                name: newSheetName,
                parents: [
                    parentFolderId
                ]
            }
        });
        const newSpreadsheetId = copiedFile.data.id;
        if (!newSpreadsheetId) {
            throw new Error('Failed to get ID of the new spreadsheet.');
        }
        console.log(`[Sheets] Cloned template sheet for "${newSheetName}" with ID: ${newSpreadsheetId}`);
        return newSpreadsheetId;
    } catch (err) {
        console.error('The API returned an error: ' + err);
        throw new Error('Failed to create database sheet.');
    }
}
async function getAllUsers() {
    try {
        const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
            version: 'v4',
            auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
        });
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: CREDENTIALS_SHEET_NAME
        });
        const rows = response.data.values;
        if (!rows || rows.length < 2) {
            return [];
        }
        const header = rows[0];
        const emailIndex = header.indexOf('emailAddress');
        const userNameIndex = header.indexOf('userName');
        const pwdIndex = header.indexOf('pwd');
        const databaseIdIndex = header.indexOf('databaseID');
        const folderIdIndex = header.indexOf('folderID');
        if (userNameIndex === -1 || pwdIndex === -1 || emailIndex === -1 || databaseIdIndex === -1 || folderIdIndex === -1) {
            console.error('One or more required columns are missing from the credentials sheet:', header);
            throw new Error('Could not find required columns in the credentials sheet. Please check sheet headers.');
        }
        return rows.slice(1).map((row)=>({
                emailAddress: row[emailIndex] || '',
                userName: row[userNameIndex] || '',
                pwd: row[pwdIndex] || '',
                databaseId: row[databaseIdIndex] || '',
                folderId: row[folderIdIndex] || ''
            })).filter((u)=>u.userName); // Filter out empty rows
    } catch (err) {
        console.error('The API returned an error when getting all users: ' + err);
        throw new Error('Failed to retrieve data from Google Sheet.');
    }
}
async function updateUserFolderId(userName, folderId) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${CREDENTIALS_SHEET_NAME}!A:H`;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length === 0) {
        throw new Error('No users found in credentials sheet.');
    }
    const header = rows[0];
    const userNameIndex = header.indexOf('userName');
    const folderIdIndex = header.indexOf('folderID');
    if (userNameIndex === -1 || folderIdIndex === -1) {
        throw new Error('userName or folderID column not found.');
    }
    const userRowIndex = rows.findIndex((row)=>row[userNameIndex] === userName);
    if (userRowIndex === -1) {
        throw new Error(`User ${userName} not found.`);
    }
    const rowToUpdate = userRowIndex + 1;
    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + folderIdIndex);
    await sheets.spreadsheets.values.update({
        spreadsheetId: SPREADSHEET_ID,
        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,
        valueInputOption: 'RAW',
        resource: {
            values: [
                [
                    folderId
                ]
            ]
        }
    });
}
async function updateUserDatabaseId(userName, databaseId) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${CREDENTIALS_SHEET_NAME}!A:H`;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length === 0) {
        throw new Error('No users found in credentials sheet.');
    }
    const header = rows[0];
    const userNameIndex = header.indexOf('userName');
    const databaseIdIndex = header.indexOf('databaseID');
    if (userNameIndex === -1 || databaseIdIndex === -1) {
        throw new Error('userName or databaseID column not found.');
    }
    const userRowIndex = rows.findIndex((row)=>row[userNameIndex] === userName);
    if (userRowIndex === -1) {
        throw new Error(`User ${userName} not found.`);
    }
    const rowToUpdate = userRowIndex + 1;
    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + databaseIdIndex);
    await sheets.spreadsheets.values.update({
        spreadsheetId: SPREADSHEET_ID,
        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,
        valueInputOption: 'RAW',
        resource: {
            values: [
                [
                    databaseId
                ]
            ]
        }
    });
}
async function getAllHeaderDataFromSheet(databaseId) {
    try {
        const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
            version: 'v4',
            auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
        });
        const response = await sheets.spreadsheets.values.get({
            spreadsheetId: databaseId,
            range: 'tpList!A:Q'
        });
        const rows = response.data.values;
        if (!rows || rows.length < 2) {
            return [];
        }
        const header = rows[0];
        const dataRows = rows.slice(1);
        const objects = dataRows.map((row)=>{
            const rowData = {};
            header.forEach((key, headerIndex)=>{
                rowData[key] = row[headerIndex] || '';
            });
            return rowData;
        }).filter((profile)=>profile.tpTIN && typeof profile.tpTIN === 'string' && profile.tpTIN.trim() !== '');
        return objects;
    } catch (err) {
        console.error(`The API returned an error for spreadsheet ${databaseId}: ` + err);
        throw new Error('Failed to retrieve header data from Google Sheet.');
    }
}
async function appendHeaderDataToSheet(profileData, databaseId) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const headerResponse = await sheets.spreadsheets.values.get({
        spreadsheetId: databaseId,
        range: 'tpList!A1:Q1'
    });
    const headers = headerResponse.data.values?.[0];
    if (!headers) {
        throw new Error('Could not retrieve headers from tpList sheet.');
    }
    const values = [
        headers.map((header)=>profileData[header] || '')
    ];
    const request = {
        spreadsheetId: databaseId,
        range: `tpList!A1`,
        valueInputOption: 'USER_ENTERED',
        resource: {
            values
        }
    };
    try {
        const response = await sheets.spreadsheets.values.append(request);
        console.log('Appended to sheet:', response.data);
        return response.data;
    } catch (err) {
        console.error('The API returned an error: ' + err);
        throw new Error('Failed to append data to Google Sheet.');
    }
}
async function updateHeaderDataInSheet(profileData, databaseId) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = 'tpList!A:Q';
    const getResponse = await sheets.spreadsheets.values.get({
        spreadsheetId: databaseId,
        range
    });
    const rows = getResponse.data.values;
    if (!rows || rows.length === 0) {
        throw new Error('No data found in the sheet.');
    }
    const headers = rows[0];
    const tinIndex = headers.indexOf('tpTIN');
    if (tinIndex === -1) {
        throw new Error('TIN column not found in the sheet.');
    }
    const rowIndex = rows.findIndex((row)=>row[tinIndex] === profileData.tpTIN);
    if (rowIndex === -1) {
        throw new Error('Profile with the specified TIN not found.');
    }
    const rowToUpdate = rowIndex + 1;
    const values = [
        headers.map((header)=>profileData[header] || '')
    ];
    const request = {
        spreadsheetId: databaseId,
        range: `tpList!A${rowToUpdate}`,
        valueInputOption: 'USER_ENTERED',
        resource: {
            values
        }
    };
    try {
        const response = await sheets.spreadsheets.values.update(request);
        console.log('Updated sheet:', response.data);
        return response.data;
    } catch (err) {
        console.error('The API returned an error: ' + err);
        throw new Error('Failed to update data in Google Sheet.');
    }
}
async function getSheetId(spreadsheetId, sheetName) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const response = await sheets.spreadsheets.get({
        spreadsheetId
    });
    const sheet = response.data.sheets?.find((s)=>s.properties?.title === sheetName);
    return sheet?.properties?.sheetId ?? null;
}
async function deleteHeaderDataRowInSheet(tpTIN, databaseId) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const sheetName = 'tpList';
    const range = `${sheetName}!A:Q`;
    const getResponse = await sheets.spreadsheets.values.get({
        spreadsheetId: databaseId,
        range
    });
    const rows = getResponse.data.values;
    if (!rows || rows.length === 0) {
        console.log('No data found in the sheet to delete.');
        return;
    }
    const headers = rows[0];
    const tinIndex = headers.indexOf('tpTIN');
    if (tinIndex === -1) {
        throw new Error('TIN column not found in the sheet.');
    }
    const rowIndex = rows.findIndex((row)=>row[tinIndex] === tpTIN);
    if (rowIndex === -1) {
        console.log(`Profile with TIN ${tpTIN} not found for deletion.`);
        return;
    }
    const sheetId = await getSheetId(databaseId, sheetName);
    if (sheetId === null) {
        throw new Error(`Sheet with name "${sheetName}" not found.`);
    }
    const batchUpdateRequest = {
        spreadsheetId: databaseId,
        resource: {
            requests: [
                {
                    deleteDimension: {
                        range: {
                            sheetId: sheetId,
                            dimension: 'ROWS',
                            startIndex: rowIndex,
                            endIndex: rowIndex + 1
                        }
                    }
                },
                {
                    appendDimension: {
                        sheetId: sheetId,
                        dimension: "ROWS",
                        length: 1
                    }
                }
            ]
        }
    };
    try {
        await sheets.spreadsheets.batchUpdate(batchUpdateRequest);
        console.log(`Successfully deleted row at index ${rowIndex} and added a new one.`);
    } catch (err) {
        console.error('The API returned an error during batch update: ' + err);
        throw new Error('Failed to delete row from Google Sheet.');
    }
}
async function updateUserDataInSheet(currentUserName, updates) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${CREDENTIALS_SHEET_NAME}!A:H`;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length === 0) {
        throw new Error('No users found in credentials sheet.');
    }
    const header = rows[0];
    const userNameIndex = header.indexOf('userName');
    const pwdIndex = header.indexOf('pwd');
    if (userNameIndex === -1 || pwdIndex === -1) {
        throw new Error('Required columns (userName, pwd) not found.');
    }
    const userRowIndex = rows.findIndex((row)=>row[userNameIndex] === currentUserName);
    if (userRowIndex === -1) {
        throw new Error(`User '${currentUserName}' not found.`);
    }
    const rowToUpdate = userRowIndex + 1;
    const userRow = [
        ...rows[userRowIndex]
    ];
    if (updates.newPassword) {
        if (!updates.currentPassword) {
            throw new Error("Current password is required to change password.");
        }
        if (userRow[pwdIndex] !== updates.currentPassword) {
            throw new Error("Incorrect current password.");
        }
        userRow[pwdIndex] = updates.newPassword;
    }
    if (updates.newUserName) {
        const isUserNameTaken = rows.slice(1).some((row, index)=>index !== userRowIndex - 1 && row[userNameIndex] === updates.newUserName);
        if (isUserNameTaken) {
            throw new Error(`Username '${updates.newUserName}' is already taken.`);
        }
        userRow[userNameIndex] = updates.newUserName;
    }
    const updateRequest = {
        spreadsheetId: SPREADSHEET_ID,
        range: `${CREDENTIALS_SHEET_NAME}!A${rowToUpdate}:H${rowToUpdate}`,
        valueInputOption: 'RAW',
        resource: {
            values: [
                userRow
            ]
        }
    };
    await sheets.spreadsheets.values.update(updateRequest);
    console.log(`Successfully updated user data for '${currentUserName}'. New username: '${updates.newUserName || currentUserName}'`);
}
async function updateUserPasswordByEmail(email, newPassword) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${CREDENTIALS_SHEET_NAME}!A:E`;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length < 2) {
        throw new Error('No users found in credentials sheet.');
    }
    const header = rows[0];
    const emailIndex = header.indexOf('emailAddress');
    const pwdIndex = header.indexOf('pwd');
    if (emailIndex === -1 || pwdIndex === -1) {
        throw new Error('Required columns (emailAddress, pwd) not found.');
    }
    const userRowIndex = rows.findIndex((row)=>row[emailIndex] === email);
    if (userRowIndex === -1) {
        throw new Error(`User with email ${email} not found.`);
    }
    const rowToUpdate = userRowIndex + 1;
    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + pwdIndex);
    await sheets.spreadsheets.values.update({
        spreadsheetId: SPREADSHEET_ID,
        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,
        valueInputOption: 'RAW',
        resource: {
            values: [
                [
                    newPassword
                ]
            ]
        }
    });
    console.log(`Successfully updated password for user ${email}.`);
}
async function addPendingUser(user) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const sheetName = PENDING_VERIFICATIONS_SHEET_NAME;
    const getResponse = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${sheetName}!A:A`
    });
    const rows = getResponse.data.values || [];
    const existingRowIndex = rows.findIndex((row)=>row[0] === user.email);
    const values = [
        [
            user.email,
            user.userName || '',
            user.password || '',
            user.token,
            user.type,
            user.expires
        ]
    ];
    if (existingRowIndex !== -1) {
        const rowToUpdate = existingRowIndex + 1;
        console.log(`[Sheets] Found existing pending verification for ${user.email} at row ${rowToUpdate}. Updating.`);
        await sheets.spreadsheets.values.update({
            spreadsheetId: SPREADSHEET_ID,
            range: `${sheetName}!A${rowToUpdate}:F${rowToUpdate}`,
            valueInputOption: 'USER_ENTERED',
            resource: {
                values
            }
        });
    } else {
        console.log(`[Sheets] No existing pending verification for ${user.email}. Appending new row.`);
        await sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID,
            range: `${sheetName}!A1`,
            valueInputOption: 'USER_ENTERED',
            resource: {
                values
            }
        });
    }
}
async function getPendingUserByToken(token) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: PENDING_VERIFICATIONS_SHEET_NAME
    });
    const rows = response.data.values;
    if (!rows || rows.length < 2) return null;
    const header = rows[0];
    const tokenIndex = header.indexOf('token');
    const rowIndex = rows.findIndex((row, index)=>index > 0 && row[tokenIndex] === token);
    if (rowIndex === -1) return null;
    const userRow = rows[rowIndex];
    const user = {
        email: userRow[header.indexOf('emailAddress')],
        userName: userRow[header.indexOf('userName')],
        password: userRow[header.indexOf('password')],
        token: userRow[tokenIndex],
        type: userRow[header.indexOf('type')],
        expires: userRow[header.indexOf('expiration')]
    };
    return {
        user,
        rowIndex
    };
}
async function deletePendingUserByRow(rowIndex) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const sheetId = await getSheetId(SPREADSHEET_ID, PENDING_VERIFICATIONS_SHEET_NAME);
    if (sheetId === null) throw new Error('Sheet not found');
    await sheets.spreadsheets.batchUpdate({
        spreadsheetId: SPREADSHEET_ID,
        resource: {
            requests: [
                {
                    deleteDimension: {
                        range: {
                            sheetId,
                            dimension: 'ROWS',
                            startIndex: rowIndex,
                            endIndex: rowIndex + 1
                        }
                    }
                }
            ]
        }
    });
}
async function addUser(userData) {
    const { email, userName, password, folderId, databaseId } = userData;
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const headerResponse = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${CREDENTIALS_SHEET_NAME}!A1:E1`
    });
    const headers = headerResponse.data.values?.[0];
    if (!headers) {
        throw new Error('Could not retrieve headers from credentials sheet.');
    }
    const userObject = {
        emailAddress: email,
        userName: userName,
        pwd: password || '',
        databaseID: databaseId,
        folderID: folderId
    };
    const values = [
        headers.map((header)=>userObject[header] || '')
    ];
    const request = {
        spreadsheetId: SPREADSHEET_ID,
        range: `${CREDENTIALS_SHEET_NAME}!A1`,
        valueInputOption: 'USER_ENTERED',
        resource: {
            values
        }
    };
    await sheets.spreadsheets.values.append(request);
}
async function addSessionToSheet(sessionData) {
    const { emailAddress, sessionToken, ipAddress, deviceInfo } = sessionData;
    const loginTime = new Date().toISOString();
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const sheetName = SESSIONS_SHEET_NAME;
    const getResponse = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${sheetName}!A:E`
    });
    const rows = getResponse.data.values;
    if (rows && rows.length > 1) {
        const header = rows[0];
        const emailIndex = header.indexOf('emailAddress');
        const deviceInfoIndex = header.indexOf('deviceInfo');
        const existingSessionRowIndex = rows.findIndex((row, index)=>index > 0 && row[emailIndex] === emailAddress && row[deviceInfoIndex] === deviceInfo);
        if (existingSessionRowIndex !== -1) {
            console.log(`[Sessions] Found existing session for ${emailAddress} on device. Removing before adding new one.`);
            const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);
            if (sheetId === null) {
                throw new Error(`Sheet with name "${sheetName}" not found.`);
            }
            await sheets.spreadsheets.batchUpdate({
                spreadsheetId: SPREADSHEET_ID,
                resource: {
                    requests: [
                        {
                            deleteDimension: {
                                range: {
                                    sheetId,
                                    dimension: 'ROWS',
                                    startIndex: existingSessionRowIndex,
                                    endIndex: existingSessionRowIndex + 1
                                }
                            }
                        }
                    ]
                }
            });
        }
    }
    const values = [
        [
            emailAddress,
            sessionToken,
            loginTime,
            ipAddress,
            deviceInfo
        ]
    ];
    const appendRequest = {
        spreadsheetId: SPREADSHEET_ID,
        range: `${sheetName}!A1`,
        valueInputOption: 'USER_ENTERED',
        resource: {
            values
        }
    };
    try {
        await sheets.spreadsheets.values.append(appendRequest);
        console.log(`[Sessions] Added new session for user ${emailAddress}`);
    } catch (err) {
        console.error('The API returned an error while adding a session: ' + err);
        throw new Error('Failed to add session to Google Sheet.');
    }
}
async function getSessionsByEmail(email) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: SESSIONS_SHEET_NAME
    });
    const rows = response.data.values;
    if (!rows || rows.length < 2) return [];
    const header = rows[0];
    const emailIndex = header.indexOf('emailAddress');
    const tokenIndex = header.indexOf('sessionToken');
    const timeIndex = header.indexOf('loginTime');
    const ipIndex = header.indexOf('ipAddress');
    const deviceIndex = header.indexOf('deviceInfo');
    return rows.slice(1).filter((row)=>row[emailIndex] === email).map((row)=>({
            token: row[tokenIndex],
            loginTime: row[timeIndex],
            ipAddress: row[ipIndex],
            deviceInfo: row[deviceIndex]
        }));
}
async function findRowIndexByToken(token) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const sheetName = SESSIONS_SHEET_NAME;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range: `${sheetName}!B:B`
    });
    const rows = response.data.values;
    if (!rows) throw new Error('Could not find session.');
    const rowIndex = rows.findIndex((row)=>row[0] === token);
    if (rowIndex === -1) throw new Error('Session token not found.');
    const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);
    if (sheetId === null) throw new Error('Could not find sheet ID for sessions.');
    return {
        sheetId,
        rowIndex
    };
}
async function findUserByTokenFromSheet(token) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${SESSIONS_SHEET_NAME}!A:B`; // emailAddress and sessionToken columns
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length < 2) return null;
    const header = rows[0];
    const emailIndex = header.indexOf('emailAddress');
    const tokenIndex = header.indexOf('sessionToken');
    const sessionRow = rows.slice(1).find((row)=>row[tokenIndex] === token);
    if (sessionRow) {
        return {
            email: sessionRow[emailIndex]
        };
    }
    return null;
}
async function deleteSessionByToken(token) {
    const { sheetId, rowIndex } = await findRowIndexByToken(token);
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    await sheets.spreadsheets.batchUpdate({
        spreadsheetId: SPREADSHEET_ID,
        resource: {
            requests: [
                {
                    deleteDimension: {
                        range: {
                            sheetId,
                            dimension: 'ROWS',
                            startIndex: rowIndex,
                            endIndex: rowIndex + 1
                        }
                    }
                }
            ]
        }
    });
    console.log(`[Sessions] Deleted session with token ending in ...${token.slice(-4)}`);
}
async function deleteAllOtherSessionsByToken(currentToken) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${SESSIONS_SHEET_NAME}!A:E`;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length < 2) return;
    const header = rows[0];
    const tokenIndex = header.indexOf('sessionToken');
    const emailIndex = header.indexOf('emailAddress');
    const currentUserRow = rows.find((row)=>row[tokenIndex] === currentToken);
    if (!currentUserRow) return;
    const currentUserEmail = currentUserRow[emailIndex];
    const sheetId = await getSheetId(SPREADSHEET_ID, SESSIONS_SHEET_NAME);
    if (sheetId === null) throw new Error('Could not find sheet ID.');
    const deleteRequests = rows.map((row, index)=>({
            row,
            index
        })).filter(({ row })=>row[emailIndex] === currentUserEmail && row[tokenIndex] !== currentToken).map(({ index })=>({
            deleteDimension: {
                range: {
                    sheetId,
                    dimension: 'ROWS',
                    startIndex: index,
                    endIndex: index + 1
                }
            }
        })).reverse();
    if (deleteRequests.length > 0) {
        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
                requests: deleteRequests
            }
        });
        console.log(`[Sessions] Deleted ${deleteRequests.length} other session(s) for user ${currentUserEmail}`);
    }
}
async function deleteAllSessionsByEmail(email) {
    const sheets = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$googleapis$2f$build$2f$src$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["google"].sheets({
        version: 'v4',
        auth: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$drive$2d$oauth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getOAuth2Client"])()
    });
    const range = `${SESSIONS_SHEET_NAME}!A:E`;
    const response = await sheets.spreadsheets.values.get({
        spreadsheetId: SPREADSHEET_ID,
        range
    });
    const rows = response.data.values;
    if (!rows || rows.length < 2) return;
    const header = rows[0];
    const emailIndex = header.indexOf('emailAddress');
    const sheetId = await getSheetId(SPREADSHEET_ID, SESSIONS_SHEET_NAME);
    if (sheetId === null) throw new Error('Could not find sheet ID.');
    const deleteRequests = rows.map((row, index)=>({
            row,
            index
        })).filter(({ row, index })=>index > 0 && row[emailIndex] === email).map(({ index })=>({
            deleteDimension: {
                range: {
                    sheetId,
                    dimension: 'ROWS',
                    startIndex: index,
                    endIndex: index + 1
                }
            }
        })).reverse(); // Reverse to handle shifting indices correctly
    if (deleteRequests.length > 0) {
        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
                requests: deleteRequests
            }
        });
        console.log(`[Sessions] Deleted ${deleteRequests.length} session(s) for user ${email}`);
    }
}
}}),
"[project]/src/app/api/auth/session/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET),
    "HEAD": (()=>HEAD)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$googlesheets$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/googlesheets.ts [app-route] (ecmascript)");
;
;
async function GET(request) {
    const sessionToken = request.cookies.get('sessionToken')?.value;
    if (!sessionToken) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            isValid: false
        }, {
            status: 401
        });
    }
    try {
        const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$googlesheets$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findUserByTokenFromSheet"])(sessionToken);
        if (user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                isValid: true
            });
        } else {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                isValid: false
            }, {
                status: 401
            });
        }
    } catch (error) {
        console.error('API session validation error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            isValid: false,
            error: 'Internal server error'
        }, {
            status: 500
        });
    }
}
async function HEAD(request) {
    const sessionToken = request.cookies.get('sessionToken')?.value;
    if (!sessionToken) {
        return new Response(null, {
            status: 401
        });
    }
    try {
        const user = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$googlesheets$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["findUserByTokenFromSheet"])(sessionToken);
        if (user) {
            return new Response(null, {
                status: 200
            });
        } else {
            return new Response(null, {
                status: 401
            });
        }
    } catch (error) {
        // In case of a backend error, we should deny access for security.
        return new Response(null, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__378ff0c9._.js.map