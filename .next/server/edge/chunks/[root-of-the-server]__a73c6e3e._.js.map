{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/drive-oauth.ts"],"sourcesContent":["\nimport { google } from 'googleapis';\n\nconst {\n  GOOGLE_OAUTH_CLIENT_ID,\n  GOOGLE_OAUTH_CLIENT_SECRET,\n  GOOGLE_OAUTH_REFRESH_TOKEN,\n} = process.env;\n\nif (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n  // This check is important but shouldn't throw an error that crashes the server on startup,\n  // as the credentials might not be used on every page load.\n  // We will let the functions that use it handle the error.\n  console.warn('Google OAuth credentials are not fully configured in .env. Some Drive/Sheets features may not work.');\n}\n\n// This is a fixed value for web applications\nconst GOOGLE_OAUTH_REDIRECT_URI = 'https://developers.google.com/oauthplayground';\n\nlet oauth2Client: import('google-auth-library').OAuth2Client | null = null;\n\nexport async function getOAuth2Client() {\n  // Add the check here to provide a clear error when the credentials are used.\n  if (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n    throw new Error('Google OAuth credentials (CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN) must be configured in your .env file.');\n  }\n  \n  if (oauth2Client) {\n    // Check if the token is about to expire (within 60 seconds) and refresh if needed\n    if (oauth2Client.credentials.expiry_date && oauth2Client.credentials.expiry_date < (Date.now() + 60 * 1000)) {\n        console.log('[OAuth] Access token expiring soon, refreshing...');\n        await oauth2Client.refreshAccessToken();\n        console.log('[OAuth] Access token refreshed.');\n    }\n    return oauth2Client;\n  }\n\n  const client = new google.auth.OAuth2(\n    GOOGLE_OAUTH_CLIENT_ID,\n    GOOGLE_OAUTH_CLIENT_SECRET,\n    GOOGLE_OAUTH_REDIRECT_URI\n  );\n\n  client.setCredentials({\n    refresh_token: GOOGLE_OAUTH_REFRESH_TOKEN,\n  });\n\n  // Do an initial token refresh to get the access token\n  try {\n    console.log('[OAuth] Initializing and refreshing access token...');\n    await client.refreshAccessToken();\n    console.log('[OAuth] Initial token refreshed successfully.');\n  } catch (error) {\n    console.error('[OAuth] Failed to refresh access token:', error);\n    throw new Error('Failed to refresh access token. Check your refresh token and credentials.');\n  }\n\n  oauth2Client = client;\n  return oauth2Client;\n}\n\nexport async function getSheetsClient() {\n    const oauth2Client = await getOAuth2Client();\n    return google.sheets({ version: 'v4', auth: oauth2Client });\n}\n"],"names":[],"mappings":";;;;AACA;;AAEA,MAAM,EACJ,sBAAsB,EACtB,0BAA0B,EAC1B,0BAA0B,EAC3B,GAAG,QAAQ,GAAG;AAEf,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;IACzF,2FAA2F;IAC3F,2DAA2D;IAC3D,0DAA0D;IAC1D,QAAQ,IAAI,CAAC;AACf;AAEA,6CAA6C;AAC7C,MAAM,4BAA4B;AAElC,IAAI,eAAkE;AAE/D,eAAe;IACpB,6EAA6E;IAC7E,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;QACzF,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,cAAc;QAChB,kFAAkF;QAClF,IAAI,aAAa,WAAW,CAAC,WAAW,IAAI,aAAa,WAAW,CAAC,WAAW,GAAI,KAAK,GAAG,KAAK,KAAK,MAAO;YACzG,QAAQ,GAAG,CAAC;YACZ,MAAM,aAAa,kBAAkB;YACrC,QAAQ,GAAG,CAAC;QAChB;QACA,OAAO;IACT;IAEA,MAAM,SAAS,IAAI,2JAAA,CAAA,SAAM,CAAC,IAAI,CAAC,MAAM,CACnC,wBACA,4BACA;IAGF,OAAO,cAAc,CAAC;QACpB,eAAe;IACjB;IAEA,sDAAsD;IACtD,IAAI;QACF,QAAQ,GAAG,CAAC;QACZ,MAAM,OAAO,kBAAkB;QAC/B,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,eAAe;IACf,OAAO;AACT;AAEO,eAAe;IAClB,MAAM,eAAe,MAAM;IAC3B,OAAO,2JAAA,CAAA,SAAM,CAAC,MAAM,CAAC;QAAE,SAAS;QAAM,MAAM;IAAa;AAC7D"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/googlesheets.ts"],"sourcesContent":["\nimport { z } from 'zod';\nimport type { TaxProfile, UserUpdateData, SessionInfo } from './schemas';\nimport { getSheetsClient } from './drive-oauth';\nimport { headers } from 'next/headers';\n\nconst signupSchema = z.object({\n  userName: z.string(),\n  email: z.string().email(),\n  password: z.string(),\n  folderId: z.string(),\n});\n\nconst loginSchema = z.object({\n  userName: z.string(),\n  password: z.string(),\n});\n\nexport type SignupData = z.infer<typeof signupSchema>;\nexport type LoginData = z.infer<typeof loginSchema>;\n\n\nconst {\n  GOOGLE_SHEETS_SHEET_ID,\n} = process.env;\n\nif (!GOOGLE_SHEETS_SHEET_ID) {\n  throw new Error('GOOGLE_SHEETS_SHEET_ID is not configured in .env');\n}\n\nconst SPREADSHEET_ID = GOOGLE_SHEETS_SHEET_ID;\nconst CREDENTIALS_SHEET_NAME = 'credentials';\nconst SESSIONS_SHEET_NAME = 'ActiveSessions';\n\nexport async function appendUserToSheet(userData: SignupData) {\n  const { email, userName, password, folderId } = userData;\n  const timestamp = new Date().toISOString();\n  const sheets = await getSheetsClient();\n\n  const values = [[email, userName, password, '', folderId, 'active', timestamp, '']];\n\n  const request = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${CREDENTIALS_SHEET_NAME}!A1`, \n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function getAllUsers() {\n    try {\n        const sheets = await getSheetsClient();\n        const response = await sheets.spreadsheets.values.get({\n            spreadsheetId: SPREADSHEET_ID,\n            range: CREDENTIALS_SHEET_NAME,\n        });\n\n        const rows = response.data.values;\n        if (!rows || rows.length === 0) {\n            return [];\n        }\n\n        const header = rows[0];\n        const emailIndex = header.indexOf('emailAddress');\n        const userNameIndex = header.indexOf('userName');\n        const pwdIndex = header.indexOf('pwd');\n        const databaseIdIndex = header.indexOf('databaseID');\n        const folderIdIndex = header.indexOf('folderID');\n\n        if (userNameIndex === -1 || pwdIndex === -1 || emailIndex === -1 || databaseIdIndex === -1 || folderIdIndex === -1) {\n            throw new Error('Could not find required columns in the credentials sheet.');\n        }\n\n        return rows.slice(1).map(row => ({\n            emailAddress: row[emailIndex] || '',\n            userName: row[userNameIndex] || '',\n            pwd: row[pwdIndex] || '',\n            databaseId: row[databaseIdIndex] || '',\n            folderId: row[folderIdIndex] || '',\n        }));\n\n    } catch (err) {\n        console.error('The API returned an error: ' + err);\n        throw new Error('Failed to retrieve data from Google Sheet.');\n    }\n}\n\nexport async function updateUserFolderId(userName: string, folderId: string) {\n    const sheets = await getSheetsClient();\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`; \n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const folderIdIndex = header.indexOf('folderID');\n\n    if (userNameIndex === -1 || folderIdIndex === -1) {\n        throw new Error('userName or folderID column not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === userName);\n    if (userRowIndex === -1) {\n        throw new Error(`User ${userName} not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + folderIdIndex);\n\n    await sheets.spreadsheets.values.update({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [[folderId]],\n        },\n    });\n}\n\n\nexport async function getAllHeaderDataFromSheet(databaseId: string): Promise<TaxProfile[]> {\n  try {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.values.get({\n      spreadsheetId: databaseId,\n      range: 'tpList!A:Q',\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    const header = rows[0];\n    const dataRows = rows.slice(1);\n    \n    const objects = dataRows\n        .map(row => {\n            const rowData: { [key: string]: any } = {};\n            header.forEach((key, headerIndex) => {\n                rowData[key] = row[headerIndex] || '';\n            });\n            return rowData as TaxProfile;\n        })\n        .filter(profile => profile.tpTIN && typeof profile.tpTIN === 'string' && profile.tpTIN.trim() !== '');\n\n    return objects;\n\n  } catch (err) {\n    console.error(`The API returned an error for spreadsheet ${databaseId}: ` + err);\n    throw new Error('Failed to retrieve header data from Google Sheet.');\n  }\n}\n\nexport async function appendHeaderDataToSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const headerResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range: 'tpList!A1:Q1',\n  });\n  \n  const headers = headerResponse.data.values?.[0];\n  if (!headers) {\n    throw new Error('Could not retrieve headers from tpList sheet.');\n  }\n\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function updateHeaderDataInSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const range = 'tpList!A:Q';\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    throw new Error('No data found in the sheet.');\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n  \n  const rowIndex = rows.findIndex(row => row[tinIndex] === profileData.tpTIN);\n\n  if (rowIndex === -1) {\n    throw new Error('Profile with the specified TIN not found.');\n  }\n  \n  const rowToUpdate = rowIndex + 1;\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A${rowToUpdate}`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.update(request);\n    console.log('Updated sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to update data in Google Sheet.');\n  }\n}\n\nasync function getSheetId(spreadsheetId: string, sheetName: string): Promise<number | null> {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.get({\n        spreadsheetId,\n    });\n    const sheet = response.data.sheets?.find(s => s.properties?.title === sheetName);\n    return sheet?.properties?.sheetId ?? null;\n}\n\nexport async function deleteHeaderDataRowInSheet(tpTIN: string, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const sheetName = 'tpList';\n  const range = `${sheetName}!A:Q`;\n\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    console.log('No data found in the sheet to delete.');\n    return;\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n\n  const rowIndex = rows.findIndex(row => row[tinIndex] === tpTIN);\n\n  if (rowIndex === -1) {\n    console.log(`Profile with TIN ${tpTIN} not found for deletion.`);\n    return;\n  }\n\n  const sheetId = await getSheetId(databaseId, sheetName);\n  if (sheetId === null) {\n      throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n  }\n\n  const batchUpdateRequest = {\n    spreadsheetId: databaseId,\n    resource: {\n      requests: [\n        {\n          deleteDimension: {\n            range: {\n              sheetId: sheetId,\n              dimension: 'ROWS',\n              startIndex: rowIndex, \n              endIndex: rowIndex + 1\n            }\n          }\n        },\n        {\n          appendDimension: {\n            sheetId: sheetId,\n            dimension: \"ROWS\",\n            length: 1\n          }\n        }\n      ]\n    }\n  };\n\n  try {\n    await sheets.spreadsheets.batchUpdate(batchUpdateRequest);\n    console.log(`Successfully deleted row at index ${rowIndex} and added a new one.`);\n  } catch (err) {\n    console.error('The API returned an error during batch update: ' + err);\n    throw new Error('Failed to delete row from Google Sheet.');\n  }\n}\n\n\nexport async function updateUserDataInSheet(currentUserName: string, updates: UserUpdateData) {\n    const sheets = await getSheetsClient();\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`; \n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const pwdIndex = header.indexOf('pwd');\n\n    if (userNameIndex === -1 || pwdIndex === -1) {\n        throw new Error('Required columns (userName, pwd) not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === currentUserName);\n    if (userRowIndex === -1) {\n        throw new Error(`User '${currentUserName}' not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const userRow = [...rows[userRowIndex]];\n\n    if (updates.newPassword) {\n        if (!updates.currentPassword) {\n            throw new Error(\"Current password is required to change password.\");\n        }\n        if (userRow[pwdIndex] !== updates.currentPassword) {\n            throw new Error(\"Incorrect current password.\");\n        }\n        userRow[pwdIndex] = updates.newPassword;\n    }\n\n    if (updates.newUserName) {\n         const isUserNameTaken = rows.slice(1).some((row, index) => index !== userRowIndex -1 && row[userNameIndex] === updates.newUserName);\n         if (isUserNameTaken) {\n            throw new Error(`Username '${updates.newUserName}' is already taken.`);\n         }\n        userRow[userNameIndex] = updates.newUserName;\n    }\n\n    const updateRequest = {\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!A${rowToUpdate}:H${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [userRow],\n        },\n    };\n\n    await sheets.spreadsheets.values.update(updateRequest);\n    console.log(`Successfully updated user data for '${currentUserName}'. New username: '${updates.newUserName || currentUserName}'`);\n}\n\n// ============== ActiveSessions Sheet Functions ==============\n\nexport async function addSessionToSheet(sessionData: {\n  userName: string;\n  sessionToken: string;\n  ipAddress: string;\n  deviceInfo: string;\n}) {\n  const { userName, sessionToken, ipAddress, deviceInfo } = sessionData;\n  const loginTime = new Date().toISOString();\n  const sheets = await getSheetsClient();\n  const sheetName = SESSIONS_SHEET_NAME;\n\n  // First, find and delete any existing session for the same user on the same device\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${sheetName}!A:E`,\n  });\n\n  const rows = getResponse.data.values;\n  if (rows && rows.length > 1) { // Check if there's more than a header\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const deviceInfoIndex = header.indexOf('deviceInfo');\n\n    const existingSessionRowIndex = rows.findIndex(\n      (row, index) => index > 0 && row[userNameIndex] === userName && row[deviceInfoIndex] === deviceInfo\n    );\n\n    if (existingSessionRowIndex !== -1) {\n      console.log(`[Sessions] Found existing session for ${userName} on device. Removing before adding new one.`);\n      const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);\n      if (sheetId === null) {\n        throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n      }\n\n      await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n          requests: [{\n            deleteDimension: {\n              range: {\n                sheetId,\n                dimension: 'ROWS',\n                startIndex: existingSessionRowIndex,\n                endIndex: existingSessionRowIndex + 1,\n              },\n            },\n          }],\n        },\n      });\n    }\n  }\n\n  // Now, append the new session\n  const values = [[userName, sessionToken, loginTime, ipAddress, deviceInfo]];\n  const appendRequest = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${sheetName}!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    await sheets.spreadsheets.values.append(appendRequest);\n    console.log(`[Sessions] Added new session for user ${userName}`);\n  } catch (err) {\n    console.error('The API returned an error while adding a session: ' + err);\n    throw new Error('Failed to add session to Google Sheet.');\n  }\n}\n\nexport async function getSessionsByUserName(userName: string): Promise<SessionInfo[]> {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: SESSIONS_SHEET_NAME,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return [];\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const tokenIndex = header.indexOf('sessionToken');\n    const timeIndex = header.indexOf('loginTime');\n    const ipIndex = header.indexOf('ipAddress');\n    const deviceIndex = header.indexOf('deviceInfo');\n\n    return rows.slice(1)\n        .filter(row => row[userNameIndex] === userName)\n        .map(row => ({\n            token: row[tokenIndex],\n            loginTime: row[timeIndex],\n            ipAddress: row[ipIndex],\n            deviceInfo: row[deviceIndex],\n        }));\n}\n\nasync function findRowIndexByToken(token: string): Promise<{ sheetId: number, rowIndex: number }> {\n    const sheets = await getSheetsClient();\n    const sheetName = SESSIONS_SHEET_NAME;\n\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${sheetName}!B:B`, // Only need to check the token column\n    });\n\n    const rows = response.data.values;\n    if (!rows) throw new Error('Could not find session.');\n\n    const rowIndex = rows.findIndex(row => row[0] === token);\n    if (rowIndex === -1) throw new Error('Session token not found.');\n\n    const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);\n    if (sheetId === null) throw new Error('Could not find sheet ID for sessions.');\n    \n    return { sheetId, rowIndex };\n}\n\nexport async function findUserBySessionToken(token: string): Promise<{ userName: string } | null> {\n    const sheets = await getSheetsClient();\n    const range = `${SESSIONS_SHEET_NAME}!A:B`; // userName and sessionToken columns\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return null;\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const tokenIndex = header.indexOf('sessionToken');\n\n    const sessionRow = rows.slice(1).find(row => row[tokenIndex] === token);\n\n    if (sessionRow) {\n        return { userName: sessionRow[userNameIndex] };\n    }\n    return null;\n}\n\n\nexport async function deleteSessionByToken(token: string) {\n    const { sheetId, rowIndex } = await findRowIndexByToken(token);\n    \n    const sheets = await getSheetsClient();\n    await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n            requests: [{\n                deleteDimension: {\n                    range: {\n                        sheetId,\n                        dimension: 'ROWS',\n                        startIndex: rowIndex,\n                        endIndex: rowIndex + 1,\n                    },\n                },\n            }],\n        },\n    });\n    console.log(`[Sessions] Deleted session with token ending in ...${token.slice(-4)}`);\n}\n\nexport async function deleteAllOtherSessionsByToken(currentToken: string) {\n    const sheets = await getSheetsClient();\n    const range = `${SESSIONS_SHEET_NAME}!A:E`;\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return;\n\n    const header = rows[0];\n    const tokenIndex = header.indexOf('sessionToken');\n    const userNameIndex = header.indexOf('userName');\n    \n    const currentUserRow = rows.find(row => row[tokenIndex] === currentToken);\n    if (!currentUserRow) return; // Current session not found, do nothing.\n\n    const currentUserName = currentUserRow[userNameIndex];\n\n    const sheetId = await getSheetId(SPREADSHEET_ID, SESSIONS_SHEET_NAME);\n    if (sheetId === null) throw new Error('Could not find sheet ID.');\n\n    const deleteRequests = rows\n        .map((row, index) => ({ row, index }))\n        .filter(({ row }) => row[userNameIndex] === currentUserName && row[tokenIndex] !== currentToken)\n        .map(({ index }) => ({\n            deleteDimension: {\n                range: {\n                    sheetId,\n                    dimension: 'ROWS',\n                    startIndex: index,\n                    endIndex: index + 1,\n                },\n            },\n        }))\n        // We need to process deletions from bottom to top to avoid shifting indices.\n        .reverse(); \n\n    if (deleteRequests.length > 0) {\n        await sheets.spreadsheets.batchUpdate({\n            spreadsheetId: SPREADSHEET_ID,\n            resource: { requests: deleteRequests },\n        });\n        console.log(`[Sessions] Deleted ${deleteRequests.length} other session(s) for user ${currentUserName}`);\n    }\n}\n\n    "],"names":[],"mappings":"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"}},
    {"offset": {"line": 656, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["\nimport { NextResponse } from 'next/server'\nimport type { NextRequest } from 'next/server'\nimport { findUserBySessionToken } from '@/lib/googlesheets';\n\n// This function can be marked `async` if using `await` inside\nexport async function middleware(request: NextRequest) {\n    const sessionToken = request.cookies.get('sessionToken')?.value;\n    const { pathname } = request.nextUrl;\n\n    const isAuthPage = pathname === '/login' || pathname === '/signup';\n\n    // If the user is on an auth page\n    if (isAuthPage) {\n        if (sessionToken) {\n            // Validate the token. If valid, redirect to home.\n            const user = await findUserBySessionToken(sessionToken);\n            if (user) {\n                return NextResponse.redirect(new URL('/home', request.url));\n            }\n            // If token is invalid, clear it and let them stay on auth page\n            const response = NextResponse.next();\n            response.cookies.delete('sessionToken');\n            return response;\n        }\n        // No token, allow access to auth page\n        return NextResponse.next();\n    }\n\n    // If the user is on a protected page\n    if (!sessionToken) {\n        // No token, redirect to login\n        return NextResponse.redirect(new URL('/login', request.url));\n    }\n    \n    // Validate the token for protected routes\n    const user = await findUserBySessionToken(sessionToken);\n    if (!user) {\n        // If token is invalid, redirect to login and clear the cookie\n        const response = NextResponse.redirect(new URL('/login', request.url));\n        response.cookies.delete('sessionToken');\n        return response;\n    }\n\n    // If everything is fine, allow access\n    return NextResponse.next();\n}\n\n// See \"Matching Paths\" below to learn more\nexport const config = {\n  matcher: [\n    '/home',\n    '/profile',\n    '/tax-profiles',\n    '/dat-files',\n    '/template',\n    '/login',\n    '/signup'\n  ],\n}\n"],"names":[],"mappings":";;;;AACA;AAAA;AAEA;;;AAGO,eAAe,WAAW,OAAoB;IACjD,MAAM,eAAe,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB;IAC1D,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,MAAM,aAAa,aAAa,YAAY,aAAa;IAEzD,iCAAiC;IACjC,IAAI,YAAY;QACZ,IAAI,cAAc;YACd,kDAAkD;YAClD,MAAM,OAAO,MAAM,CAAA,GAAA,kIAAA,CAAA,yBAAsB,AAAD,EAAE;YAC1C,IAAI,MAAM;gBACN,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,SAAS,QAAQ,GAAG;YAC7D;YACA,+DAA+D;YAC/D,MAAM,WAAW,6LAAA,CAAA,eAAY,CAAC,IAAI;YAClC,SAAS,OAAO,CAAC,MAAM,CAAC;YACxB,OAAO;QACX;QACA,sCAAsC;QACtC,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC5B;IAEA,qCAAqC;IACrC,IAAI,CAAC,cAAc;QACf,8BAA8B;QAC9B,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;IAC9D;IAEA,0CAA0C;IAC1C,MAAM,OAAO,MAAM,CAAA,GAAA,kIAAA,CAAA,yBAAsB,AAAD,EAAE;IAC1C,IAAI,CAAC,MAAM;QACP,8DAA8D;QAC9D,MAAM,WAAW,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,UAAU,QAAQ,GAAG;QACpE,SAAS,OAAO,CAAC,MAAM,CAAC;QACxB,OAAO;IACX;IAEA,sCAAsC;IACtC,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC5B;AAGO,MAAM,SAAS;IACpB,SAAS;QACP;QACA;QACA;QACA;QACA;QACA;QACA;KACD;AACH"}}]
}