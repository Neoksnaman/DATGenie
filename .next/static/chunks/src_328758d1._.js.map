{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/card.tsx"],"sourcesContent":["import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n"],"names":[],"mappings":";;;;;;;;;AAAA;AAEA;;;;AAEA,MAAM,qBAAO,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAG1B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,4DACA;QAED,GAAG,KAAK;;;;;;;AAGb,KAAK,WAAW,GAAG;AAEnB,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,0BAAY,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAG/B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;;AAGb,UAAU,WAAW,GAAG;AAExB,MAAM,gCAAkB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGrC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,gBAAgB,WAAW,GAAG;AAE9B,MAAM,4BAAc,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QAAI,KAAK;QAAK,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,YAAY;QAAa,GAAG,KAAK;;;;;;;AAEhE,YAAY,WAAW,GAAG;AAE1B,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,SAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,8BAA8B;QAC3C,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/popover.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n"],"names":[],"mappings":";;;;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,UAAU,sKAAA,CAAA,OAAqB;AAErC,MAAM,iBAAiB,sKAAA,CAAA,UAAwB;AAE/C,MAAM,+BAAiB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,QAAQ,EAAE,aAAa,CAAC,EAAE,GAAG,OAAO,EAAE,oBAC5D,6LAAC,sKAAA,CAAA,SAAuB;kBACtB,cAAA,6LAAC,sKAAA,CAAA,UAAwB;YACvB,KAAK;YACL,OAAO;YACP,YAAY;YACZ,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,8aACA;YAED,GAAG,KAAK;;;;;;;;;;;;AAIf,eAAe,WAAW,GAAG,sKAAA,CAAA,UAAwB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,SAAS,qKAAA,CAAA,OAAoB;AAEnC,MAAM,gBAAgB,qKAAA,CAAA,UAAuB;AAE7C,MAAM,eAAe,qKAAA,CAAA,SAAsB;AAE3C,MAAM,cAAc,qKAAA,CAAA,QAAqB;AAEzC,MAAM,8BAAgB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,EAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,qKAAA,CAAA,UAAuB;QACtB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,0JACA;QAED,GAAG,KAAK;;;;;;KAVP;AAaN,cAAc,WAAW,GAAG,qKAAA,CAAA,UAAuB,CAAC,WAAW;AAE/D,MAAM,8BAAgB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGnC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,6LAAC;;0BACC,6LAAC;;;;;0BACD,6LAAC,qKAAA,CAAA,UAAuB;gBACtB,KAAK;gBACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,+fACA;gBAED,GAAG,KAAK;;oBAER;kCACD,6LAAC,qKAAA,CAAA,QAAqB;wBAAC,WAAU;;0CAC/B,6LAAC,+LAAA,CAAA,IAAC;gCAAC,WAAU;;;;;;0CACb,6LAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,cAAc,WAAW,GAAG,qKAAA,CAAA,UAAuB,CAAC,WAAW;AAE/D,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,sDACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,aAAa,WAAW,GAAG;AAE3B,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,6LAAC;QACC,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,iEACA;QAED,GAAG,KAAK;;;;;;MATP;AAYN,aAAa,WAAW,GAAG;AAE3B,MAAM,4BAAc,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGjC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,qKAAA,CAAA,QAAqB;QACpB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,qDACA;QAED,GAAG,KAAK;;;;;;;AAGb,YAAY,WAAW,GAAG,qKAAA,CAAA,QAAqB,CAAC,WAAW;AAE3D,MAAM,kCAAoB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGvC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,qKAAA,CAAA,cAA2B;QAC1B,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,kBAAkB,WAAW,GAAG,qKAAA,CAAA,cAA2B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/command.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\ninterface CommandDialogProps extends DialogProps {}\n\nconst CommandDialog = ({ children, ...props }: CommandDialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 490, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/profile-selector.tsx"],"sourcesContent":["\n'use client';\n\nimport * as React from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from '@/components/ui/command';\nimport type { TaxProfile } from '@/lib/schemas';\nimport { PlusCircle, Check, ChevronsUpDown } from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\ninterface ProfileSelectorProps {\n  profiles: TaxProfile[];\n  onProfileSelect: (tin: string) => void;\n  onNewProfile: () => void;\n  selectedProfile: string;\n}\n\nexport function ProfileSelector({ profiles, onProfileSelect, onNewProfile, selectedProfile }: ProfileSelectorProps) {\n  const [open, setOpen] = React.useState(false);\n\n  const getDisplayName = (profile: TaxProfile) => {\n    return profile.entityType === 'Individual' ? profile.tradeName : profile.companyName;\n  };\n\n  const sortedProfiles = React.useMemo(() => {\n    return [...profiles].sort((a, b) => {\n        const nameA = getDisplayName(a)?.toLowerCase() || '';\n        const nameB = getDisplayName(b)?.toLowerCase() || '';\n        if (nameA < nameB) return -1;\n        if (nameA > nameB) return 1;\n        return 0;\n    });\n  }, [profiles]);\n\n  const selectedValue = selectedProfile\n    ? `${getDisplayName(profiles.find(p => p.tpTIN === selectedProfile)!)} (${selectedProfile})`\n    : \"Select a profile...\";\n\n  return (\n    <div className=\"flex flex-col sm:flex-row items-center gap-4\">\n      <div className=\"w-full sm:w-auto sm:flex-1\">\n        <Popover open={open} onOpenChange={setOpen}>\n          <PopoverTrigger asChild>\n            <Button\n              variant=\"outline\"\n              role=\"combobox\"\n              aria-expanded={open}\n              className=\"w-full justify-between h-auto min-h-[2.5rem]\"\n            >\n              <span className=\"text-left whitespace-normal\">{selectedValue}</span>\n              <ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent align=\"start\" className=\"w-[--radix-popover-trigger-width] p-0\">\n            <Command>\n              <CommandInput placeholder=\"Search profile by name or TIN...\" />\n              <CommandList>\n                <CommandEmpty>No profile found.</CommandEmpty>\n                <CommandGroup>\n                  {sortedProfiles.map((profile) => (\n                    <CommandItem\n                      key={profile.tpTIN}\n                      value={`${getDisplayName(profile)} ${profile.tpTIN}`}\n                      onSelect={() => {\n                        onProfileSelect(profile.tpTIN);\n                        setOpen(false);\n                      }}\n                      className=\"flex items-start\"\n                    >\n                      <Check\n                        className={cn(\n                          \"mr-2 h-4 w-4 mt-1 shrink-0\",\n                          selectedProfile === profile.tpTIN ? \"opacity-100\" : \"opacity-0\"\n                        )}\n                      />\n                      <div>\n                        {getDisplayName(profile)} ({profile.tpTIN})\n                      </div>\n                    </CommandItem>\n                  ))}\n                </CommandGroup>\n              </CommandList>\n            </Command>\n          </PopoverContent>\n        </Popover>\n      </div>\n      <Button onClick={onNewProfile} variant=\"outline\" className=\"w-full sm:w-auto\">\n        <PlusCircle className=\"mr-2 h-4 w-4\" />\n        New Profile\n      </Button>\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;;;AARA;;;;;;;AAiBO,SAAS,gBAAgB,EAAE,QAAQ,EAAE,eAAe,EAAE,YAAY,EAAE,eAAe,EAAwB;;IAChH,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAc,AAAD,EAAE;IAEvC,MAAM,iBAAiB,CAAC;QACtB,OAAO,QAAQ,UAAU,KAAK,eAAe,QAAQ,SAAS,GAAG,QAAQ,WAAW;IACtF;IAEA,MAAM,iBAAiB,CAAA,GAAA,6JAAA,CAAA,UAAa,AAAD;mDAAE;YACnC,OAAO;mBAAI;aAAS,CAAC,IAAI;2DAAC,CAAC,GAAG;oBAC1B,MAAM,QAAQ,eAAe,IAAI,iBAAiB;oBAClD,MAAM,QAAQ,eAAe,IAAI,iBAAiB;oBAClD,IAAI,QAAQ,OAAO,OAAO,CAAC;oBAC3B,IAAI,QAAQ,OAAO,OAAO;oBAC1B,OAAO;gBACX;;QACF;kDAAG;QAAC;KAAS;IAEb,MAAM,gBAAgB,kBAClB,GAAG,eAAe,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK,kBAAmB,EAAE,EAAE,gBAAgB,CAAC,CAAC,GAC1F;IAEJ,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC;gBAAI,WAAU;0BACb,cAAA,6LAAC,sIAAA,CAAA,UAAO;oBAAC,MAAM;oBAAM,cAAc;;sCACjC,6LAAC,sIAAA,CAAA,iBAAc;4BAAC,OAAO;sCACrB,cAAA,6LAAC,qIAAA,CAAA,SAAM;gCACL,SAAQ;gCACR,MAAK;gCACL,iBAAe;gCACf,WAAU;;kDAEV,6LAAC;wCAAK,WAAU;kDAA+B;;;;;;kDAC/C,6LAAC,iOAAA,CAAA,iBAAc;wCAAC,WAAU;;;;;;;;;;;;;;;;;sCAG9B,6LAAC,sIAAA,CAAA,iBAAc;4BAAC,OAAM;4BAAQ,WAAU;sCACtC,cAAA,6LAAC,sIAAA,CAAA,UAAO;;kDACN,6LAAC,sIAAA,CAAA,eAAY;wCAAC,aAAY;;;;;;kDAC1B,6LAAC,sIAAA,CAAA,cAAW;;0DACV,6LAAC,sIAAA,CAAA,eAAY;0DAAC;;;;;;0DACd,6LAAC,sIAAA,CAAA,eAAY;0DACV,eAAe,GAAG,CAAC,CAAC,wBACnB,6LAAC,sIAAA,CAAA,cAAW;wDAEV,OAAO,GAAG,eAAe,SAAS,CAAC,EAAE,QAAQ,KAAK,EAAE;wDACpD,UAAU;4DACR,gBAAgB,QAAQ,KAAK;4DAC7B,QAAQ;wDACV;wDACA,WAAU;;0EAEV,6LAAC,uMAAA,CAAA,QAAK;gEACJ,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,8BACA,oBAAoB,QAAQ,KAAK,GAAG,gBAAgB;;;;;;0EAGxD,6LAAC;;oEACE,eAAe;oEAAS;oEAAG,QAAQ,KAAK;oEAAC;;;;;;;;uDAfvC,QAAQ,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAyBlC,6LAAC,qIAAA,CAAA,SAAM;gBAAC,SAAS;gBAAc,SAAQ;gBAAU,WAAU;;kCACzD,6LAAC,qNAAA,CAAA,aAAU;wBAAC,WAAU;;;;;;oBAAiB;;;;;;;;;;;;;AAK/C;GA3EgB;KAAA","debugId":null}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/label.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB;AAGF,MAAM,sBAAQ,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAI3B,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,oKAAA,CAAA,OAAmB;QAClB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iBAAiB;QAC9B,GAAG,KAAK;;;;;;;AAGb,MAAM,WAAW,GAAG,oKAAA,CAAA,OAAmB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/select.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/accordion.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,YAAY,wKAAA,CAAA,OAAuB;AAEzC,MAAM,8BAAgB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAGnC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC,wKAAA,CAAA,OAAuB;QACtB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,YAAY;QACzB,GAAG,KAAK;;;;;;;AAGb,cAAc,WAAW,GAAG;AAE5B,MAAM,iCAAmB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGtC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,6LAAC,wKAAA,CAAA,SAAyB;QAAC,WAAU;kBACnC,cAAA,6LAAC,wKAAA,CAAA,UAA0B;YACzB,KAAK;YACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,gIACA;YAED,GAAG,KAAK;;gBAER;8BACD,6LAAC,uNAAA,CAAA,cAAW;oBAAC,WAAU;;;;;;;;;;;;;;;;;;AAI7B,iBAAiB,WAAW,GAAG,wKAAA,CAAA,UAA0B,CAAC,WAAW;AAErE,MAAM,iCAAmB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGtC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,6LAAC,wKAAA,CAAA,UAA0B;QACzB,KAAK;QACL,WAAU;QACT,GAAG,KAAK;kBAET,cAAA,6LAAC;YAAI,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,aAAa;sBAAa;;;;;;;;;;;;AAIjD,iBAAiB,WAAW,GAAG,wKAAA,CAAA,UAA0B,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/radio-group.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AAQA,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IAC1B,qBACE,6LAAC,6KAAA,CAAA,OAAwB;QACvB,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;QAC3B,GAAG,KAAK;QACT,KAAK;;;;;;AAGX;;AACA,WAAW,WAAW,GAAG,6KAAA,CAAA,OAAwB,CAAC,WAAW;AAE7D,MAAM,+BAAiB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGpC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE;IAC1B,qBACE,6LAAC,6KAAA,CAAA,OAAwB;QACvB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,4OACA;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,6KAAA,CAAA,YAA6B;YAAC,WAAU;sBACvC,cAAA,6LAAC,yMAAA,CAAA,SAAM;gBAAC,WAAU;;;;;;;;;;;;;;;;AAI1B;;AACA,eAAe,WAAW,GAAG,6KAAA,CAAA,OAAwB,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 1122, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/generation-card.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useCallback, type ChangeEvent, type DragEvent } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { UploadCloud, File as FileIcon, X, Loader2, AlertTriangle, FileUp, Upload } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useToast } from '@/hooks/use-toast';\nimport { Label } from './ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from './ui/accordion';\nimport { RadioGroup, RadioGroupItem } from './ui/radio-group';\nimport { Input } from './ui/input';\n\ninterface GenerationCardProps {\n  title: string;\n  description: string;\n  buttonText: string;\n  onGenerate: (file: File, ...args: any[]) => Promise<void>;\n  icon: React.ReactNode;\n  isDatGeneration: boolean;\n  reminders?: string[];\n}\n\nconst months = [\n    { name: \"January\", value: \"01\" },\n    { name: \"February\", value: \"02\" },\n    { name: \"March\", value: \"03\" },\n    { name: \"April\", value: \"04\" },\n    { name: \"May\", value: \"05\" },\n    { name: \"June\", value: \"06\" },\n    { name: \"July\", value: \"07\" },\n    { name: \"August\", value: \"08\" },\n    { name: \"September\", value: \"09\" },\n    { name: \"October\", value: \"10\" },\n    { name: \"November\", value: \"11\" },\n    { name: \"December\", value: \"12\" }\n];\n\nconst reportTypes = [\n    \"Summary of Sales (SLS)\",\n    \"Summary of Purchases (SLP)\",\n    \"Summary of Importations (SLI)\",\n    \"Summary Alphalist of Withholding Tax (SAWT)\",\n    \"1601-EQ (Schedule 1 and 2)\",\n    \"1601-FQ (Schedule 1, 2, and 3)\",\n    \"1604-CF (Schedule 3 and 4)\",\n    \"1604-E (Schedule 4)\",\n    \"1604-F (Schedule 5, 6, and 7)\",\n];\n\nconst sawtSchedules = [\n    \"1700\", \"1702\", \"2550Q\",\n    \"1701\", \"1702Q\", \"2551M\",\n    \"1701Q\", \"2550M\", \"2553\"\n];\n\nconst currentYear = new Date().getFullYear();\nconst years = Array.from({ length: currentYear - 1999 }, (_, i) => (currentYear - i).toString());\n\nexport function GenerationCard({ title, description, buttonText, onGenerate, icon, isDatGeneration, reminders }: GenerationCardProps) {\n  const [selectedFile, setSelectedFile] = useState<File | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [isGenerating, setIsGenerating] = useState(false);\n  const { toast } = useToast();\n\n  // DAT Gen State\n  const [month, setMonth] = useState(months[0].value);\n  const [year, setYear] = useState(currentYear.toString());\n  const [reportType, setReportType] = useState(reportTypes[0]);\n  const [sawtSchedule, setSawtSchedule] = useState(sawtSchedules[0]);\n\n  // Cert Gen State\n  const [signatoryName, setSignatoryName] = useState('');\n  const [signatoryTIN, setSignatoryTIN] = useState('');\n  const [signatoryPosition, setSignatoryPosition] = useState('');\n  const [signatureFile, setSignatureFile] = useState<File | null>(null);\n\n\n  const handleFileChange = (files: FileList | null) => {\n    const file = files?.[0];\n    if (file) {\n      if (file.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || file.type === 'application/vnd.ms-excel') {\n        setSelectedFile(file);\n      } else {\n        toast({\n          title: 'Invalid File Type',\n          description: 'Please upload a valid Excel file (.xlsx, .xls).',\n          variant: 'destructive',\n        });\n      }\n    }\n  };\n  \n  const handleInputElementChange = (e: ChangeEvent<HTMLInputElement>) => {\n    handleFileChange(e.target.files);\n    e.target.value = ''; // Allow re-uploading the same file\n  };\n\n  const handleSignatureFileChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file) {\n        if (file.type.startsWith('image/')) {\n            setSignatureFile(file);\n        } else {\n            toast({\n                title: 'Invalid File Type',\n                description: 'Please upload a valid image file for the signature.',\n                variant: 'destructive',\n            });\n        }\n    }\n    e.target.value = '';\n  };\n\n\n  const handleDragEnter = (e: DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(true);\n  };\n\n  const handleDragLeave = (e: DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(false);\n  };\n\n  const handleDrop = useCallback((e: DragEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(false);\n    handleFileChange(e.dataTransfer.files);\n  }, []);\n\n  const handleGenerateClick = async () => {\n    if (!selectedFile) {\n        toast({ title: 'No file selected', description: 'Please upload a file to generate.', variant: 'destructive'});\n        return;\n    };\n    setIsGenerating(true);\n    \n    try {\n        if (isDatGeneration) {\n            await onGenerate(selectedFile, month, year, reportType, sawtSchedule);\n        } else {\n            await onGenerate(selectedFile, signatoryName, signatoryTIN, signatoryPosition, signatureFile);\n        }\n    } catch (error) {\n         // Toast is handled by the calling component\n    } finally {\n        setIsGenerating(false);\n    }\n  }\n\n  const clearFile = () => {\n    setSelectedFile(null);\n  }\n\n  return (\n    <Card>\n      <CardHeader>\n        <div className=\"flex items-center gap-3\">\n          <div className=\"flex-shrink-0 w-10 h-10 bg-primary/10 text-primary rounded-lg flex items-center justify-center\">\n            {icon}\n          </div>\n          <div>\n            <CardTitle>{title}</CardTitle>\n            <CardDescription>{description}</CardDescription>\n          </div>\n        </div>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        {isDatGeneration ? (\n            <div className=\"space-y-4\">\n                 <div className=\"space-y-2\">\n                    <Label>Reporting Period</Label>\n                    <div className=\"grid grid-cols-2 gap-2\">\n                        <Select value={month} onValueChange={setMonth}>\n                            <SelectTrigger><SelectValue /></SelectTrigger>\n                            <SelectContent>\n                                {months.map(m => <SelectItem key={m.value} value={m.value}>{m.name}</SelectItem>)}\n                            </SelectContent>\n                        </Select>\n                        <Select value={year} onValueChange={setYear}>\n                            <SelectTrigger><SelectValue /></SelectTrigger>\n                            <SelectContent>\n                                {years.map(y => <SelectItem key={y} value={y}>{y}</SelectItem>)}\n                            </SelectContent>\n                        </Select>\n                    </div>\n                </div>\n                 <div className=\"space-y-2\">\n                    <Label>Reporting Type</Label>\n                    <Select value={reportType} onValueChange={setReportType}>\n                        <SelectTrigger><SelectValue /></SelectTrigger>\n                        <SelectContent>\n                            {reportTypes.map(rt => <SelectItem key={rt} value={rt}>{rt}</SelectItem>)}\n                        </SelectContent>\n                    </Select>\n                </div>\n                {reportType === \"Summary Alphalist of Withholding Tax (SAWT)\" && (\n                  <div className=\"space-y-2 animate-in fade-in-50 duration-300\">\n                    <Label>Schedules</Label>\n                     <div className=\"pl-8\">\n                        <RadioGroup \n                            value={sawtSchedule} \n                            onValueChange={setSawtSchedule}\n                            className=\"grid grid-cols-3 gap-x-4 gap-y-2\"\n                        >\n                            {sawtSchedules.map(schedule => (\n                                <div key={schedule} className=\"flex items-center space-x-2\">\n                                    <RadioGroupItem value={schedule} id={`r-${schedule}`} />\n                                    <Label htmlFor={`r-${schedule}`} className=\"font-normal\">{schedule}</Label>\n                                </div>\n                            ))}\n                        </RadioGroup>\n                    </div>\n                  </div>\n                )}\n            </div>\n        ) : (\n            <div className=\"space-y-4\">\n                <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\n                    <div className=\"space-y-2\">\n                        <Label htmlFor=\"signatory-name\">Name</Label>\n                        <Input id=\"signatory-name\" value={signatoryName} onChange={e => setSignatoryName(e.target.value)} maxLength={30} />\n                    </div>\n                    <div className=\"space-y-2\">\n                        <Label htmlFor=\"signatory-tin\">TIN</Label>\n                        <Input \n                          id=\"signatory-tin\" \n                          value={signatoryTIN} \n                          onChange={e => setSignatoryTIN(e.target.value.replace(/[^0-9]/g, ''))} \n                          maxLength={9}\n                          pattern=\"[0-9]*\"\n                        />\n                    </div>\n                </div>\n                <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\n                    <div className=\"space-y-2\">\n                        <Label htmlFor=\"signatory-position\">Position</Label>\n                        <Input id=\"signatory-position\" value={signatoryPosition} onChange={e => setSignatoryPosition(e.target.value)} maxLength={30} />\n                    </div>\n                     <div className=\"space-y-2\">\n                        <Label htmlFor=\"signature-file\">Signature</Label>\n                        <div className=\"relative\">\n                            <Input id=\"signature-file\" type=\"file\" accept=\"image/*\" onChange={handleSignatureFileChange} className=\"hidden\" />\n                            <label htmlFor=\"signature-file\" className={cn(\n                                \"cursor-pointer h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background\",\n                                \"flex items-center gap-2 text-muted-foreground\",\n                                \"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\"\n                            )}>\n                                {!signatureFile ? (\n                                    <>\n                                        <Upload className=\"h-4 w-4\" />\n                                        <span>Upload Signature</span>\n                                    </>\n                                ) : (\n                                    <div className=\"flex items-center gap-2 w-full\">\n                                        <FileIcon className=\"h-4 w-4 flex-shrink-0\" />\n                                        <span className=\"flex-1 truncate\">{signatureFile.name}</span>\n                                        <Button\n                                            variant=\"ghost\"\n                                            size=\"icon\"\n                                            className=\"h-6 w-6 shrink-0\"\n                                            onClick={(e) => {\n                                                e.preventDefault();\n                                                e.stopPropagation();\n                                                setSignatureFile(null)\n                                            }}\n                                        >\n                                            <X className=\"h-4 w-4\" />\n                                            <span className=\"sr-only\">Clear signature</span>\n                                        </Button>\n                                    </div>\n                                )}\n                            </label>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        )}\n\n\n        {selectedFile ? (\n            <div className=\"relative flex items-center p-3 border-2 border-dashed rounded-lg border-primary/50 bg-primary/10\">\n                <FileIcon className=\"w-8 h-8 mr-3 text-primary flex-shrink-0\" />\n                <div className=\"flex-grow overflow-hidden\">\n                    <p className=\"font-semibold truncate\">{selectedFile.name}</p>\n                    <p className=\"text-sm text-muted-foreground\">\n                    {(selectedFile.size / 1024).toFixed(2)} KB\n                    </p>\n                </div>\n                <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={clearFile}\n                    className=\"flex-shrink-0 w-8 h-8\"\n                    disabled={isGenerating}\n                >\n                    <X className=\"w-5 h-5\" />\n                    <span className=\"sr-only\">Clear file</span>\n                </Button>\n            </div>\n        ) : (\n            <div\n                className={cn(\n                    'w-full p-6 border-2 border-dashed rounded-lg text-center transition-colors duration-300',\n                    isDragging ? 'border-primary bg-primary/10' : 'border-border hover:border-primary/50'\n                )}\n                onDragEnter={handleDragEnter}\n                onDragOver={handleDragEnter}\n                onDragLeave={handleDragLeave}\n                onDrop={handleDrop}\n            >\n                <input\n                    type=\"file\"\n                    id={`file-upload-${title.replace(/\\s+/g, '-')}`}\n                    className=\"hidden\"\n                    onChange={handleInputElementChange}\n                    accept=\".xlsx, .xls\"\n                    disabled={isGenerating}\n                />\n                <label htmlFor={`file-upload-${title.replace(/\\s+/g, '-')}`} className=\"cursor-pointer space-y-2 flex flex-col items-center\">\n                    <UploadCloud className=\"w-10 h-10 text-muted-foreground\" />\n                     <div className=\"space-y-1\">\n                        <p className=\"font-semibold\">Drag & drop or <span className=\"text-primary\">browse</span></p>\n                        <p className=\"text-xs text-muted-foreground\">Supports .xlsx, .xls</p>\n                    </div>\n                </label>\n            </div>\n        )}\n\n        <Button className=\"w-full\" onClick={handleGenerateClick} disabled={isGenerating || !selectedFile}>\n          {isGenerating && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n          {buttonText}\n        </Button>\n        \n        {reminders && reminders.length > 0 && (\n          <Accordion type=\"single\" collapsible className=\"w-full\">\n            <AccordionItem value=\"reminders\">\n              <AccordionTrigger className=\"text-sm\">\n                <div className=\"flex items-center gap-2\">\n                  <AlertTriangle className=\"h-4 w-4 text-primary\" />\n                  Important Reminders\n                </div>\n              </AccordionTrigger>\n              <AccordionContent>\n                <ol className=\"space-y-3 list-decimal list-outside pl-5 text-xs text-muted-foreground\">\n                  {reminders.map((reminder, index) => (\n                    <li key={index} className=\"pl-1\">{reminder}</li>\n                  ))}\n                </ol>\n              </AccordionContent>\n            </AccordionItem>\n          </Accordion>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2073, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/tax-profiles-skeleton.tsx"],"sourcesContent":["\n'use client';\n\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';\n\nexport function TaxProfilesSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      <Skeleton className=\"h-10 w-full\" />\n      <Skeleton className=\"h-10 w-24\" />\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AAFA;;;AAKO,SAAS;IACd,qBACE,6LAAC;QAAI,WAAU;;0BACb,6LAAC,uIAAA,CAAA,WAAQ;gBAAC,WAAU;;;;;;0BACpB,6LAAC,uIAAA,CAAA,WAAQ;gBAAC,WAAU;;;;;;;;;;;;AAG1B;KAPgB","debugId":null}},
    {"offset": {"line": 2118, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/alert.tsx"],"sourcesContent":["\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n"],"names":[],"mappings":";;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,gBAAgB,CAAA,GAAA,mKAAA,CAAA,MAAG,AAAD,EACtB,6JACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,MAAM,sBAAQ,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAG3B,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE,oBACnC,6LAAC;QACC,KAAK;QACL,MAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;;AAGb,MAAM,WAAW,GAAG;AAEpB,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGhC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,gDAAgD;QAC7D,GAAG,KAAK;;;;;;;AAGb,WAAW,WAAW,GAAG;AAEzB,MAAM,iCAAmB,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,QAGtC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,6LAAC;QACC,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;;AAGb,iBAAiB,WAAW,GAAG","debugId":null}},
    {"offset": {"line": 2195, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, updateUserFolderId } from './googlesheets';\nimport type { TaxProfile, DatFile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema, DatFileSchema } from './schemas';\nimport * as xlsx from 'xlsx';\nimport { uploadFileToDrive, listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken, createFolderInDrive } from './drive';\nimport { atcWE, atcExempt, atcWG } from './schedules';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    const folderId = await createFolderInDrive(`DATGenie_${userData.userName}`);\n    await appendUserToSheet({ ...userData, folderId });\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId, folderId: folderId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    fileExists: z.boolean().optional(),\n    datFile: DatFileSchema.nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    // 1601-EQ and SAWT Totals\n    totalTaxableIncomePayment: z.number().nullable(),\n    totalExemptIncomePayment: z.number().nullable(),\n    totalWithholdingTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ñ/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nasync function generateSalesDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin } = profile;\n    \n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n    if (fileErrors.length > 0) {\n        return { \n            success: false, \n            errors: fileErrors, \n            datContent: null, fileName: null, error: null, datFile: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n        if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n        \n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n        \n        const numericFields = [\n            { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n            { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n        }\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return {\n            success: false, errors: validationErrors, error: \"Validation failed.\", datFile: null,\n            datContent: null, fileName: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n    \n    const datFileName = `${tin}S${month}${year}.DAT`;\n    const reportTypeShort = \"Sales\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'S', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const headerRow = ['H', 'S', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    // Check for existing file before returning immediately\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null,\n        };\n    }\n            \n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()}, // Return dummy file data immediately\n        totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax,\n        error: null, errors: null, totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nasync function generate1601EQDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin, branchCode } = profile;\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const { data: sched1DataRows, validationErrors: sched1FileErrors } = await processExcelFile(file, \"1601EQ_sched1\");\n    if (sched1FileErrors.length > 0) return { ...defaultErrorResult, errors: sched1FileErrors };\n\n    const { data: sched2DataRows, validationErrors: sched2FileErrors } = await processExcelFile(file, \"1601EQ_sched2\");\n    if (sched2FileErrors.length > 0) return { ...defaultErrorResult, errors: sched2FileErrors };\n\n    const sched1HasData = sched1DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n    const sched2HasData = sched2DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n\n    if (!sched1HasData && !sched2HasData) {\n        return { ...defaultErrorResult, errors: [\"No data found in Schedule 1 or Schedule 2 sheets.\"] };\n    }\n\n    const validationErrors: string[] = [];\n\n    // Process Schedule 1 (Taxable)\n    const processedSched1Data = sched1DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched1 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched1 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], `Sched1 ${field.name}`, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = atcWE.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Sched1 Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 1.`);\n                }\n            } else validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    // Process Schedule 2 (Exempt)\n    const processedSched2Data = sched2DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n\n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched2 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n\n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched2 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const result = sanitizeAndValidateNumber(processedRow[7], `Sched2 Income Payment`, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[7] = result.value;\n\n            if (atc) {\n                const atcData = atcExempt.find(item => item.atc === atc);\n                if (!atcData) validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 2.`);\n            } else validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) return { ...defaultErrorResult, errors: validationErrors };\n    \n    // All validations passed, now check for existing file\n    const datFileName = `${tin}${branchCode}${month.padStart(2, '0')}${year}1601EQ.DAT`;\n    const reportTypeShort = \"1601EQ\";\n    const drivePath = [tin, reportTypeShort, year];\n    \n    processedSched1Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    processedSched2Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n    let datContentParts: string[] = [];\n    \n    // Header Row\n    const taxpayerName = profile.entityType === 'Individual'\n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const mainHeader = ['HQAP', 'H1601EQ', profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), reportingPeriod, profile.rdoCode].join(',');\n    datContentParts.push(mainHeader);\n\n    let totalTaxableIncomePayment = 0;\n    let totalWithholdingTax = 0;\n    let totalExemptIncomePayment = 0;\n\n    // Schedule 1 Content\n    if (processedSched1Data.length > 0) {\n        const detailRows1 = processedSched1Data.map((row, index) => ['D1', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7], row[8], row[9]].join(',')).join('\\n');\n        totalTaxableIncomePayment = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        totalWithholdingTax = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const footerRow1 = ['C1', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalTaxableIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n        datContentParts.push(detailRows1, footerRow1);\n    }\n\n    // Schedule 2 Content\n    if (processedSched2Data.length > 0) {\n        const detailRows2 = processedSched2Data.map((row, index) => ['D2', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7]].join(',')).join('\\n');\n        totalExemptIncomePayment = processedSched2Data.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const footerRow2 = ['C2', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalExemptIncomePayment.toFixed(2)].join(',');\n        datContentParts.push(detailRows2, footerRow2);\n    }\n\n    const datContent = datContentParts.join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment,\n        totalExemptIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!file || !reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for conversion.' };\n    }\n\n    try {\n        const profile: TaxProfile = JSON.parse(profileString);\n        if (reportType === \"Summary of Sales (SLS)\") {\n            return await generateSalesDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            return await validateExcelForPurchases(formData);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n            return await generate1601EQDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!schedule) {\n                return { ...defaultErrorResult, error: 'SAWT schedule is missing.' };\n            }\n            const result = await validateAndProcessSAWT(formData, false);\n            if (result.success) {\n                 return { ...result };\n            }\n            return result;\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function overwriteDatFile(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const processedDataString = formData.get('processedData') as string | null;\n    const nonCreditableTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for overwrite.' };\n    }\n     const profile: TaxProfile = JSON.parse(profileString);\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n            return await generateSalesDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            if (!processedDataString || nonCreditableTaxString === null) return { ...defaultErrorResult, error: 'Missing processed data for overwrite.' };\n            const processedData = JSON.parse(processedDataString);\n            const nonCreditableInputTax = parseFloat(nonCreditableTaxString);\n            return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, true);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n             if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n             return await generate1601EQDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!file || !schedule) return { ...defaultErrorResult, error: 'Missing file or schedule for SAWT overwrite.' };\n            return await validateAndProcessSAWT(formData, true);\n        }\n\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported for overwrite.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during overwrite.';\n        console.error('[overwriteDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Overwrite failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\nasync function generatePurchasesDatFile(\n    processedData: any[][],\n    profile: TaxProfile,\n    month: string,\n    year: string,\n    nonCreditableInputTax: number,\n    folderId: string,\n    overwrite: boolean = false\n): Promise<DatFileResult> {\n     const { tpTIN: tin } = profile;\n    const datFileName = `${tin}P${month}${year}.DAT`;\n    const reportTypeShort = \"Purchases\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'P', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], row[11], row[12], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n    const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n    const headerRow = ['H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true);\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null, totalExempt: null, totalZeroRated: null,\n            totalTaxableSales: null, totalOutputTax: null, totalServices: null, totalCapitalGoods: null,\n            totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalExempt, totalZeroRated,\n        totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax,\n        error: null, errors: null, totalTaxableSales: null, totalOutputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nexport async function createPurchasesDatFile(formData: FormData): Promise<DatFileResult> {\n    const processedDataString = formData.get('processedData') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const nonCreditableInputTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    if (!processedDataString || !profileString || !month || !year || nonCreditableInputTaxString === null || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for purchase file creation.' };\n    }\n    \n    try {\n        const processedData = JSON.parse(processedDataString);\n        const profile: TaxProfile = JSON.parse(profileString);\n        const nonCreditableInputTax = parseFloat(nonCreditableInputTaxString);\n\n        return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, false);\n\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nexport async function validateAndProcessSAWT(formData: FormData, overwrite: boolean = false): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const schedule = formData.get('schedule') as string;\n    const profileString = formData.get('profile') as string;\n    const month = formData.get('month') as string;\n    const year = formData.get('year') as string;\n    const folderId = formData.get('folderId') as string;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const profile: TaxProfile = JSON.parse(profileString);\n\n    const sheetName = `sawt_${schedule}`;\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, sheetName);\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    if (dataRows.length === 0) {\n        return { ...defaultErrorResult, success: false, errors: [`No data found in sheet \"${sheetName}\".`] };\n    }\n\n    const validationErrors: string[] = [];\n    const combinedATC = [...atcWE, ...atcWG];\n\n    const processedData = dataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = combinedATC.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Row ${originalRowNumber}: ATC code '${atc}' is not valid for SAWT.`);\n                }\n            } else {\n                validationErrors.push(`Row ${originalRowNumber}: ATC code is missing.`);\n            }\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    processedData.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    \n    const datFileName = `${profile.tpTIN}${profile.branchCode}${month.padStart(2, '0')}${year}${schedule}.DAT`;\n    const reportTypeShort = `SAWT_${schedule}`;\n    const drivePath = [profile.tpTIN, reportTypeShort, year];\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n\n    const taxpayerName = profile.entityType === 'Individual' \n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const header = ['HSAWT', `H${schedule}`, profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.middleName), reportingPeriod, profile.rdoCode].join(',');\n\n    const detailRows = processedData.map((row, index) => {\n        return [\n            'DSAWT', `D${schedule}`, index + 1, row[0], row[1],\n            quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n            reportingPeriod, '', row[6], row[7], row[8], row[9]\n        ].join(',');\n    }).join('\\n');\n\n    const totalIncomePayment = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalWithholdingTax = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    \n    const footer = ['CSAWT', `C${schedule}`, profile.tpTIN, profile.branchCode, reportingPeriod, totalIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n\n    const datContent = [header, detailRows, footer].join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent: datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment: totalIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;IAu3BsB,yBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2211, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, updateUserFolderId } from './googlesheets';\nimport type { TaxProfile, DatFile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema, DatFileSchema } from './schemas';\nimport * as xlsx from 'xlsx';\nimport { uploadFileToDrive, listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken, createFolderInDrive } from './drive';\nimport { atcWE, atcExempt, atcWG } from './schedules';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    const folderId = await createFolderInDrive(`DATGenie_${userData.userName}`);\n    await appendUserToSheet({ ...userData, folderId });\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId, folderId: folderId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    fileExists: z.boolean().optional(),\n    datFile: DatFileSchema.nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    // 1601-EQ and SAWT Totals\n    totalTaxableIncomePayment: z.number().nullable(),\n    totalExemptIncomePayment: z.number().nullable(),\n    totalWithholdingTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ñ/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nasync function generateSalesDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin } = profile;\n    \n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n    if (fileErrors.length > 0) {\n        return { \n            success: false, \n            errors: fileErrors, \n            datContent: null, fileName: null, error: null, datFile: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n        if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n        \n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n        \n        const numericFields = [\n            { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n            { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n        }\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return {\n            success: false, errors: validationErrors, error: \"Validation failed.\", datFile: null,\n            datContent: null, fileName: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n    \n    const datFileName = `${tin}S${month}${year}.DAT`;\n    const reportTypeShort = \"Sales\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'S', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const headerRow = ['H', 'S', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    // Check for existing file before returning immediately\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null,\n        };\n    }\n            \n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()}, // Return dummy file data immediately\n        totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax,\n        error: null, errors: null, totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nasync function generate1601EQDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin, branchCode } = profile;\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const { data: sched1DataRows, validationErrors: sched1FileErrors } = await processExcelFile(file, \"1601EQ_sched1\");\n    if (sched1FileErrors.length > 0) return { ...defaultErrorResult, errors: sched1FileErrors };\n\n    const { data: sched2DataRows, validationErrors: sched2FileErrors } = await processExcelFile(file, \"1601EQ_sched2\");\n    if (sched2FileErrors.length > 0) return { ...defaultErrorResult, errors: sched2FileErrors };\n\n    const sched1HasData = sched1DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n    const sched2HasData = sched2DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n\n    if (!sched1HasData && !sched2HasData) {\n        return { ...defaultErrorResult, errors: [\"No data found in Schedule 1 or Schedule 2 sheets.\"] };\n    }\n\n    const validationErrors: string[] = [];\n\n    // Process Schedule 1 (Taxable)\n    const processedSched1Data = sched1DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched1 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched1 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], `Sched1 ${field.name}`, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = atcWE.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Sched1 Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 1.`);\n                }\n            } else validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    // Process Schedule 2 (Exempt)\n    const processedSched2Data = sched2DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n\n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched2 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n\n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched2 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const result = sanitizeAndValidateNumber(processedRow[7], `Sched2 Income Payment`, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[7] = result.value;\n\n            if (atc) {\n                const atcData = atcExempt.find(item => item.atc === atc);\n                if (!atcData) validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 2.`);\n            } else validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) return { ...defaultErrorResult, errors: validationErrors };\n    \n    // All validations passed, now check for existing file\n    const datFileName = `${tin}${branchCode}${month.padStart(2, '0')}${year}1601EQ.DAT`;\n    const reportTypeShort = \"1601EQ\";\n    const drivePath = [tin, reportTypeShort, year];\n    \n    processedSched1Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    processedSched2Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n    let datContentParts: string[] = [];\n    \n    // Header Row\n    const taxpayerName = profile.entityType === 'Individual'\n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const mainHeader = ['HQAP', 'H1601EQ', profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), reportingPeriod, profile.rdoCode].join(',');\n    datContentParts.push(mainHeader);\n\n    let totalTaxableIncomePayment = 0;\n    let totalWithholdingTax = 0;\n    let totalExemptIncomePayment = 0;\n\n    // Schedule 1 Content\n    if (processedSched1Data.length > 0) {\n        const detailRows1 = processedSched1Data.map((row, index) => ['D1', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7], row[8], row[9]].join(',')).join('\\n');\n        totalTaxableIncomePayment = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        totalWithholdingTax = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const footerRow1 = ['C1', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalTaxableIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n        datContentParts.push(detailRows1, footerRow1);\n    }\n\n    // Schedule 2 Content\n    if (processedSched2Data.length > 0) {\n        const detailRows2 = processedSched2Data.map((row, index) => ['D2', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7]].join(',')).join('\\n');\n        totalExemptIncomePayment = processedSched2Data.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const footerRow2 = ['C2', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalExemptIncomePayment.toFixed(2)].join(',');\n        datContentParts.push(detailRows2, footerRow2);\n    }\n\n    const datContent = datContentParts.join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment,\n        totalExemptIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!file || !reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for conversion.' };\n    }\n\n    try {\n        const profile: TaxProfile = JSON.parse(profileString);\n        if (reportType === \"Summary of Sales (SLS)\") {\n            return await generateSalesDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            return await validateExcelForPurchases(formData);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n            return await generate1601EQDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!schedule) {\n                return { ...defaultErrorResult, error: 'SAWT schedule is missing.' };\n            }\n            const result = await validateAndProcessSAWT(formData, false);\n            if (result.success) {\n                 return { ...result };\n            }\n            return result;\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function overwriteDatFile(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const processedDataString = formData.get('processedData') as string | null;\n    const nonCreditableTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for overwrite.' };\n    }\n     const profile: TaxProfile = JSON.parse(profileString);\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n            return await generateSalesDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            if (!processedDataString || nonCreditableTaxString === null) return { ...defaultErrorResult, error: 'Missing processed data for overwrite.' };\n            const processedData = JSON.parse(processedDataString);\n            const nonCreditableInputTax = parseFloat(nonCreditableTaxString);\n            return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, true);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n             if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n             return await generate1601EQDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!file || !schedule) return { ...defaultErrorResult, error: 'Missing file or schedule for SAWT overwrite.' };\n            return await validateAndProcessSAWT(formData, true);\n        }\n\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported for overwrite.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during overwrite.';\n        console.error('[overwriteDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Overwrite failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\nasync function generatePurchasesDatFile(\n    processedData: any[][],\n    profile: TaxProfile,\n    month: string,\n    year: string,\n    nonCreditableInputTax: number,\n    folderId: string,\n    overwrite: boolean = false\n): Promise<DatFileResult> {\n     const { tpTIN: tin } = profile;\n    const datFileName = `${tin}P${month}${year}.DAT`;\n    const reportTypeShort = \"Purchases\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'P', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], row[11], row[12], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n    const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n    const headerRow = ['H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true);\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null, totalExempt: null, totalZeroRated: null,\n            totalTaxableSales: null, totalOutputTax: null, totalServices: null, totalCapitalGoods: null,\n            totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalExempt, totalZeroRated,\n        totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax,\n        error: null, errors: null, totalTaxableSales: null, totalOutputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nexport async function createPurchasesDatFile(formData: FormData): Promise<DatFileResult> {\n    const processedDataString = formData.get('processedData') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const nonCreditableInputTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    if (!processedDataString || !profileString || !month || !year || nonCreditableInputTaxString === null || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for purchase file creation.' };\n    }\n    \n    try {\n        const processedData = JSON.parse(processedDataString);\n        const profile: TaxProfile = JSON.parse(profileString);\n        const nonCreditableInputTax = parseFloat(nonCreditableInputTaxString);\n\n        return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, false);\n\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nexport async function validateAndProcessSAWT(formData: FormData, overwrite: boolean = false): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const schedule = formData.get('schedule') as string;\n    const profileString = formData.get('profile') as string;\n    const month = formData.get('month') as string;\n    const year = formData.get('year') as string;\n    const folderId = formData.get('folderId') as string;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const profile: TaxProfile = JSON.parse(profileString);\n\n    const sheetName = `sawt_${schedule}`;\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, sheetName);\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    if (dataRows.length === 0) {\n        return { ...defaultErrorResult, success: false, errors: [`No data found in sheet \"${sheetName}\".`] };\n    }\n\n    const validationErrors: string[] = [];\n    const combinedATC = [...atcWE, ...atcWG];\n\n    const processedData = dataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = combinedATC.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Row ${originalRowNumber}: ATC code '${atc}' is not valid for SAWT.`);\n                }\n            } else {\n                validationErrors.push(`Row ${originalRowNumber}: ATC code is missing.`);\n            }\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    processedData.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    \n    const datFileName = `${profile.tpTIN}${profile.branchCode}${month.padStart(2, '0')}${year}${schedule}.DAT`;\n    const reportTypeShort = `SAWT_${schedule}`;\n    const drivePath = [profile.tpTIN, reportTypeShort, year];\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n\n    const taxpayerName = profile.entityType === 'Individual' \n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const header = ['HSAWT', `H${schedule}`, profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.middleName), reportingPeriod, profile.rdoCode].join(',');\n\n    const detailRows = processedData.map((row, index) => {\n        return [\n            'DSAWT', `D${schedule}`, index + 1, row[0], row[1],\n            quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n            reportingPeriod, '', row[6], row[7], row[8], row[9]\n        ].join(',');\n    }).join('\\n');\n\n    const totalIncomePayment = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalWithholdingTax = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    \n    const footer = ['CSAWT', `C${schedule}`, profile.tpTIN, profile.branchCode, reportingPeriod, totalIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n\n    const datContent = [header, detailRows, footer].join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent: datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment: totalIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;IA2nBsB,oBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2227, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, updateUserFolderId } from './googlesheets';\nimport type { TaxProfile, DatFile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema, DatFileSchema } from './schemas';\nimport * as xlsx from 'xlsx';\nimport { uploadFileToDrive, listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken, createFolderInDrive } from './drive';\nimport { atcWE, atcExempt, atcWG } from './schedules';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    const folderId = await createFolderInDrive(`DATGenie_${userData.userName}`);\n    await appendUserToSheet({ ...userData, folderId });\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId, folderId: folderId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    fileExists: z.boolean().optional(),\n    datFile: DatFileSchema.nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    // 1601-EQ and SAWT Totals\n    totalTaxableIncomePayment: z.number().nullable(),\n    totalExemptIncomePayment: z.number().nullable(),\n    totalWithholdingTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ñ/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nasync function generateSalesDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin } = profile;\n    \n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n    if (fileErrors.length > 0) {\n        return { \n            success: false, \n            errors: fileErrors, \n            datContent: null, fileName: null, error: null, datFile: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n        if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n        \n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n        \n        const numericFields = [\n            { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n            { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n        }\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return {\n            success: false, errors: validationErrors, error: \"Validation failed.\", datFile: null,\n            datContent: null, fileName: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n    \n    const datFileName = `${tin}S${month}${year}.DAT`;\n    const reportTypeShort = \"Sales\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'S', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const headerRow = ['H', 'S', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    // Check for existing file before returning immediately\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null,\n        };\n    }\n            \n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()}, // Return dummy file data immediately\n        totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax,\n        error: null, errors: null, totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nasync function generate1601EQDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin, branchCode } = profile;\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const { data: sched1DataRows, validationErrors: sched1FileErrors } = await processExcelFile(file, \"1601EQ_sched1\");\n    if (sched1FileErrors.length > 0) return { ...defaultErrorResult, errors: sched1FileErrors };\n\n    const { data: sched2DataRows, validationErrors: sched2FileErrors } = await processExcelFile(file, \"1601EQ_sched2\");\n    if (sched2FileErrors.length > 0) return { ...defaultErrorResult, errors: sched2FileErrors };\n\n    const sched1HasData = sched1DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n    const sched2HasData = sched2DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n\n    if (!sched1HasData && !sched2HasData) {\n        return { ...defaultErrorResult, errors: [\"No data found in Schedule 1 or Schedule 2 sheets.\"] };\n    }\n\n    const validationErrors: string[] = [];\n\n    // Process Schedule 1 (Taxable)\n    const processedSched1Data = sched1DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched1 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched1 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], `Sched1 ${field.name}`, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = atcWE.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Sched1 Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 1.`);\n                }\n            } else validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    // Process Schedule 2 (Exempt)\n    const processedSched2Data = sched2DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n\n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched2 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n\n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched2 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const result = sanitizeAndValidateNumber(processedRow[7], `Sched2 Income Payment`, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[7] = result.value;\n\n            if (atc) {\n                const atcData = atcExempt.find(item => item.atc === atc);\n                if (!atcData) validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 2.`);\n            } else validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) return { ...defaultErrorResult, errors: validationErrors };\n    \n    // All validations passed, now check for existing file\n    const datFileName = `${tin}${branchCode}${month.padStart(2, '0')}${year}1601EQ.DAT`;\n    const reportTypeShort = \"1601EQ\";\n    const drivePath = [tin, reportTypeShort, year];\n    \n    processedSched1Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    processedSched2Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n    let datContentParts: string[] = [];\n    \n    // Header Row\n    const taxpayerName = profile.entityType === 'Individual'\n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const mainHeader = ['HQAP', 'H1601EQ', profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), reportingPeriod, profile.rdoCode].join(',');\n    datContentParts.push(mainHeader);\n\n    let totalTaxableIncomePayment = 0;\n    let totalWithholdingTax = 0;\n    let totalExemptIncomePayment = 0;\n\n    // Schedule 1 Content\n    if (processedSched1Data.length > 0) {\n        const detailRows1 = processedSched1Data.map((row, index) => ['D1', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7], row[8], row[9]].join(',')).join('\\n');\n        totalTaxableIncomePayment = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        totalWithholdingTax = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const footerRow1 = ['C1', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalTaxableIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n        datContentParts.push(detailRows1, footerRow1);\n    }\n\n    // Schedule 2 Content\n    if (processedSched2Data.length > 0) {\n        const detailRows2 = processedSched2Data.map((row, index) => ['D2', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7]].join(',')).join('\\n');\n        totalExemptIncomePayment = processedSched2Data.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const footerRow2 = ['C2', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalExemptIncomePayment.toFixed(2)].join(',');\n        datContentParts.push(detailRows2, footerRow2);\n    }\n\n    const datContent = datContentParts.join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment,\n        totalExemptIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!file || !reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for conversion.' };\n    }\n\n    try {\n        const profile: TaxProfile = JSON.parse(profileString);\n        if (reportType === \"Summary of Sales (SLS)\") {\n            return await generateSalesDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            return await validateExcelForPurchases(formData);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n            return await generate1601EQDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!schedule) {\n                return { ...defaultErrorResult, error: 'SAWT schedule is missing.' };\n            }\n            const result = await validateAndProcessSAWT(formData, false);\n            if (result.success) {\n                 return { ...result };\n            }\n            return result;\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function overwriteDatFile(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const processedDataString = formData.get('processedData') as string | null;\n    const nonCreditableTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for overwrite.' };\n    }\n     const profile: TaxProfile = JSON.parse(profileString);\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n            return await generateSalesDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            if (!processedDataString || nonCreditableTaxString === null) return { ...defaultErrorResult, error: 'Missing processed data for overwrite.' };\n            const processedData = JSON.parse(processedDataString);\n            const nonCreditableInputTax = parseFloat(nonCreditableTaxString);\n            return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, true);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n             if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n             return await generate1601EQDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!file || !schedule) return { ...defaultErrorResult, error: 'Missing file or schedule for SAWT overwrite.' };\n            return await validateAndProcessSAWT(formData, true);\n        }\n\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported for overwrite.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during overwrite.';\n        console.error('[overwriteDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Overwrite failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\nasync function generatePurchasesDatFile(\n    processedData: any[][],\n    profile: TaxProfile,\n    month: string,\n    year: string,\n    nonCreditableInputTax: number,\n    folderId: string,\n    overwrite: boolean = false\n): Promise<DatFileResult> {\n     const { tpTIN: tin } = profile;\n    const datFileName = `${tin}P${month}${year}.DAT`;\n    const reportTypeShort = \"Purchases\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'P', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], row[11], row[12], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n    const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n    const headerRow = ['H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true);\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null, totalExempt: null, totalZeroRated: null,\n            totalTaxableSales: null, totalOutputTax: null, totalServices: null, totalCapitalGoods: null,\n            totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalExempt, totalZeroRated,\n        totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax,\n        error: null, errors: null, totalTaxableSales: null, totalOutputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nexport async function createPurchasesDatFile(formData: FormData): Promise<DatFileResult> {\n    const processedDataString = formData.get('processedData') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const nonCreditableInputTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    if (!processedDataString || !profileString || !month || !year || nonCreditableInputTaxString === null || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for purchase file creation.' };\n    }\n    \n    try {\n        const processedData = JSON.parse(processedDataString);\n        const profile: TaxProfile = JSON.parse(profileString);\n        const nonCreditableInputTax = parseFloat(nonCreditableInputTaxString);\n\n        return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, false);\n\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nexport async function validateAndProcessSAWT(formData: FormData, overwrite: boolean = false): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const schedule = formData.get('schedule') as string;\n    const profileString = formData.get('profile') as string;\n    const month = formData.get('month') as string;\n    const year = formData.get('year') as string;\n    const folderId = formData.get('folderId') as string;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const profile: TaxProfile = JSON.parse(profileString);\n\n    const sheetName = `sawt_${schedule}`;\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, sheetName);\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    if (dataRows.length === 0) {\n        return { ...defaultErrorResult, success: false, errors: [`No data found in sheet \"${sheetName}\".`] };\n    }\n\n    const validationErrors: string[] = [];\n    const combinedATC = [...atcWE, ...atcWG];\n\n    const processedData = dataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = combinedATC.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Row ${originalRowNumber}: ATC code '${atc}' is not valid for SAWT.`);\n                }\n            } else {\n                validationErrors.push(`Row ${originalRowNumber}: ATC code is missing.`);\n            }\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    processedData.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    \n    const datFileName = `${profile.tpTIN}${profile.branchCode}${month.padStart(2, '0')}${year}${schedule}.DAT`;\n    const reportTypeShort = `SAWT_${schedule}`;\n    const drivePath = [profile.tpTIN, reportTypeShort, year];\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n\n    const taxpayerName = profile.entityType === 'Individual' \n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const header = ['HSAWT', `H${schedule}`, profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.middleName), reportingPeriod, profile.rdoCode].join(',');\n\n    const detailRows = processedData.map((row, index) => {\n        return [\n            'DSAWT', `D${schedule}`, index + 1, row[0], row[1],\n            quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n            reportingPeriod, '', row[6], row[7], row[8], row[9]\n        ].join(',');\n    }).join('\\n');\n\n    const totalIncomePayment = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalWithholdingTax = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    \n    const footer = ['CSAWT', `C${schedule}`, profile.tpTIN, profile.branchCode, reportingPeriod, totalIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n\n    const datContent = [header, detailRows, footer].join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent: datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment: totalIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;IAmuBsB,4BAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2243, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, updateUserFolderId } from './googlesheets';\nimport type { TaxProfile, DatFile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema, DatFileSchema } from './schemas';\nimport * as xlsx from 'xlsx';\nimport { uploadFileToDrive, listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken, createFolderInDrive } from './drive';\nimport { atcWE, atcExempt, atcWG } from './schedules';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    const folderId = await createFolderInDrive(`DATGenie_${userData.userName}`);\n    await appendUserToSheet({ ...userData, folderId });\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId, folderId: folderId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    fileExists: z.boolean().optional(),\n    datFile: DatFileSchema.nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    // 1601-EQ and SAWT Totals\n    totalTaxableIncomePayment: z.number().nullable(),\n    totalExemptIncomePayment: z.number().nullable(),\n    totalWithholdingTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ñ/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nasync function generateSalesDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin } = profile;\n    \n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n    if (fileErrors.length > 0) {\n        return { \n            success: false, \n            errors: fileErrors, \n            datContent: null, fileName: null, error: null, datFile: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n        if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n        \n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n        \n        const numericFields = [\n            { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n            { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n        }\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return {\n            success: false, errors: validationErrors, error: \"Validation failed.\", datFile: null,\n            datContent: null, fileName: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n    \n    const datFileName = `${tin}S${month}${year}.DAT`;\n    const reportTypeShort = \"Sales\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'S', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const headerRow = ['H', 'S', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    // Check for existing file before returning immediately\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null,\n        };\n    }\n            \n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()}, // Return dummy file data immediately\n        totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax,\n        error: null, errors: null, totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nasync function generate1601EQDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin, branchCode } = profile;\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const { data: sched1DataRows, validationErrors: sched1FileErrors } = await processExcelFile(file, \"1601EQ_sched1\");\n    if (sched1FileErrors.length > 0) return { ...defaultErrorResult, errors: sched1FileErrors };\n\n    const { data: sched2DataRows, validationErrors: sched2FileErrors } = await processExcelFile(file, \"1601EQ_sched2\");\n    if (sched2FileErrors.length > 0) return { ...defaultErrorResult, errors: sched2FileErrors };\n\n    const sched1HasData = sched1DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n    const sched2HasData = sched2DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n\n    if (!sched1HasData && !sched2HasData) {\n        return { ...defaultErrorResult, errors: [\"No data found in Schedule 1 or Schedule 2 sheets.\"] };\n    }\n\n    const validationErrors: string[] = [];\n\n    // Process Schedule 1 (Taxable)\n    const processedSched1Data = sched1DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched1 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched1 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], `Sched1 ${field.name}`, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = atcWE.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Sched1 Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 1.`);\n                }\n            } else validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    // Process Schedule 2 (Exempt)\n    const processedSched2Data = sched2DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n\n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched2 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n\n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched2 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const result = sanitizeAndValidateNumber(processedRow[7], `Sched2 Income Payment`, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[7] = result.value;\n\n            if (atc) {\n                const atcData = atcExempt.find(item => item.atc === atc);\n                if (!atcData) validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 2.`);\n            } else validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) return { ...defaultErrorResult, errors: validationErrors };\n    \n    // All validations passed, now check for existing file\n    const datFileName = `${tin}${branchCode}${month.padStart(2, '0')}${year}1601EQ.DAT`;\n    const reportTypeShort = \"1601EQ\";\n    const drivePath = [tin, reportTypeShort, year];\n    \n    processedSched1Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    processedSched2Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n    let datContentParts: string[] = [];\n    \n    // Header Row\n    const taxpayerName = profile.entityType === 'Individual'\n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const mainHeader = ['HQAP', 'H1601EQ', profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), reportingPeriod, profile.rdoCode].join(',');\n    datContentParts.push(mainHeader);\n\n    let totalTaxableIncomePayment = 0;\n    let totalWithholdingTax = 0;\n    let totalExemptIncomePayment = 0;\n\n    // Schedule 1 Content\n    if (processedSched1Data.length > 0) {\n        const detailRows1 = processedSched1Data.map((row, index) => ['D1', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7], row[8], row[9]].join(',')).join('\\n');\n        totalTaxableIncomePayment = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        totalWithholdingTax = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const footerRow1 = ['C1', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalTaxableIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n        datContentParts.push(detailRows1, footerRow1);\n    }\n\n    // Schedule 2 Content\n    if (processedSched2Data.length > 0) {\n        const detailRows2 = processedSched2Data.map((row, index) => ['D2', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7]].join(',')).join('\\n');\n        totalExemptIncomePayment = processedSched2Data.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const footerRow2 = ['C2', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalExemptIncomePayment.toFixed(2)].join(',');\n        datContentParts.push(detailRows2, footerRow2);\n    }\n\n    const datContent = datContentParts.join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment,\n        totalExemptIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!file || !reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for conversion.' };\n    }\n\n    try {\n        const profile: TaxProfile = JSON.parse(profileString);\n        if (reportType === \"Summary of Sales (SLS)\") {\n            return await generateSalesDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            return await validateExcelForPurchases(formData);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n            return await generate1601EQDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!schedule) {\n                return { ...defaultErrorResult, error: 'SAWT schedule is missing.' };\n            }\n            const result = await validateAndProcessSAWT(formData, false);\n            if (result.success) {\n                 return { ...result };\n            }\n            return result;\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function overwriteDatFile(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const processedDataString = formData.get('processedData') as string | null;\n    const nonCreditableTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for overwrite.' };\n    }\n     const profile: TaxProfile = JSON.parse(profileString);\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n            return await generateSalesDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            if (!processedDataString || nonCreditableTaxString === null) return { ...defaultErrorResult, error: 'Missing processed data for overwrite.' };\n            const processedData = JSON.parse(processedDataString);\n            const nonCreditableInputTax = parseFloat(nonCreditableTaxString);\n            return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, true);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n             if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n             return await generate1601EQDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!file || !schedule) return { ...defaultErrorResult, error: 'Missing file or schedule for SAWT overwrite.' };\n            return await validateAndProcessSAWT(formData, true);\n        }\n\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported for overwrite.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during overwrite.';\n        console.error('[overwriteDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Overwrite failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\nasync function generatePurchasesDatFile(\n    processedData: any[][],\n    profile: TaxProfile,\n    month: string,\n    year: string,\n    nonCreditableInputTax: number,\n    folderId: string,\n    overwrite: boolean = false\n): Promise<DatFileResult> {\n     const { tpTIN: tin } = profile;\n    const datFileName = `${tin}P${month}${year}.DAT`;\n    const reportTypeShort = \"Purchases\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'P', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], row[11], row[12], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n    const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n    const headerRow = ['H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true);\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null, totalExempt: null, totalZeroRated: null,\n            totalTaxableSales: null, totalOutputTax: null, totalServices: null, totalCapitalGoods: null,\n            totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalExempt, totalZeroRated,\n        totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax,\n        error: null, errors: null, totalTaxableSales: null, totalOutputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nexport async function createPurchasesDatFile(formData: FormData): Promise<DatFileResult> {\n    const processedDataString = formData.get('processedData') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const nonCreditableInputTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    if (!processedDataString || !profileString || !month || !year || nonCreditableInputTaxString === null || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for purchase file creation.' };\n    }\n    \n    try {\n        const processedData = JSON.parse(processedDataString);\n        const profile: TaxProfile = JSON.parse(profileString);\n        const nonCreditableInputTax = parseFloat(nonCreditableInputTaxString);\n\n        return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, false);\n\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nexport async function validateAndProcessSAWT(formData: FormData, overwrite: boolean = false): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const schedule = formData.get('schedule') as string;\n    const profileString = formData.get('profile') as string;\n    const month = formData.get('month') as string;\n    const year = formData.get('year') as string;\n    const folderId = formData.get('folderId') as string;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const profile: TaxProfile = JSON.parse(profileString);\n\n    const sheetName = `sawt_${schedule}`;\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, sheetName);\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    if (dataRows.length === 0) {\n        return { ...defaultErrorResult, success: false, errors: [`No data found in sheet \"${sheetName}\".`] };\n    }\n\n    const validationErrors: string[] = [];\n    const combinedATC = [...atcWE, ...atcWG];\n\n    const processedData = dataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = combinedATC.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Row ${originalRowNumber}: ATC code '${atc}' is not valid for SAWT.`);\n                }\n            } else {\n                validationErrors.push(`Row ${originalRowNumber}: ATC code is missing.`);\n            }\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    processedData.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    \n    const datFileName = `${profile.tpTIN}${profile.branchCode}${month.padStart(2, '0')}${year}${schedule}.DAT`;\n    const reportTypeShort = `SAWT_${schedule}`;\n    const drivePath = [profile.tpTIN, reportTypeShort, year];\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n\n    const taxpayerName = profile.entityType === 'Individual' \n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const header = ['HSAWT', `H${schedule}`, profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.middleName), reportingPeriod, profile.rdoCode].join(',');\n\n    const detailRows = processedData.map((row, index) => {\n        return [\n            'DSAWT', `D${schedule}`, index + 1, row[0], row[1],\n            quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n            reportingPeriod, '', row[6], row[7], row[8], row[9]\n        ].join(',');\n    }).join('\\n');\n\n    const totalIncomePayment = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalWithholdingTax = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    \n    const footer = ['CSAWT', `C${schedule}`, profile.tpTIN, profile.branchCode, reportingPeriod, totalIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n\n    const datContent = [header, detailRows, footer].join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent: datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment: totalIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;IA8qBsB,mBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 2259, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/scroll-area.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollBar orientation=\"horizontal\" />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,OAGhC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,6LAAC,6KAAA,CAAA,OAAwB;QACvB,KAAK;QACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,4BAA4B;QACzC,GAAG,KAAK;;0BAET,6LAAC,6KAAA,CAAA,WAA4B;gBAAC,WAAU;0BACrC;;;;;;0BAEH,6LAAC;;;;;0BACD,6LAAC;gBAAU,aAAY;;;;;;0BACvB,6LAAC,6KAAA,CAAA,SAA0B;;;;;;;;;;;;AAG/B,WAAW,WAAW,GAAG,6KAAA,CAAA,OAAwB,CAAC,WAAW;AAE7D,MAAM,0BAAY,CAAA,GAAA,6JAAA,CAAA,aAAgB,AAAD,EAG/B,CAAC,EAAE,SAAS,EAAE,cAAc,UAAU,EAAE,GAAG,OAAO,EAAE,oBACpD,6LAAC,6KAAA,CAAA,sBAAuC;QACtC,KAAK;QACL,aAAa;QACb,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,iDACA,gBAAgB,cACd,sDACF,gBAAgB,gBACd,wDACF;QAED,GAAG,KAAK;kBAET,cAAA,6LAAC,6KAAA,CAAA,kBAAmC;YAAC,WAAU;;;;;;;;;;;MAjB7C;AAoBN,UAAU,WAAW,GAAG,6KAAA,CAAA,sBAAuC,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 2343, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/dat-preview-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/components/ui/dialog';\nimport { Button } from './ui/button';\nimport { Download, CheckCircle, Eye } from 'lucide-react';\nimport { ScrollArea, ScrollBar } from './ui/scroll-area';\n\ninterface Totals {\n    exempt?: number;\n    zeroRated?: number;\n    vatable?: number;\n    outputVat?: number;\n    services?: number;\n    capitalGoods?: number;\n    otherGoods?: number;\n    inputTax?: number;\n    taxableIncome?: number;\n    exemptIncome?: number;\n    withholdingTax?: number;\n}\n\nexport interface DatPreviewState {\n    fileName: string;\n    content: string;\n    isViewing?: boolean;\n    reportType?: 'sales' | 'purchases' | '1601eq' | 'sawt' | 'none';\n    totals?: Totals;\n}\n\ninterface DatPreviewDialogProps extends DatPreviewState {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\n\nexport function DatPreviewDialog({\n  isOpen,\n  onOpenChange,\n  fileName,\n  content,\n  isViewing = false,\n  reportType = 'none',\n  totals = {},\n}: DatPreviewDialogProps) {\n\n  const handleDownload = () => {\n    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = fileName;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  };\n  \n  const formatCurrency = (value: number | undefined) => {\n    if (value === undefined) return '0.00';\n    return new Intl.NumberFormat('en-US', {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    }).format(value);\n  }\n\n  const showDownload = !isViewing || (isViewing && reportType !== 'none');\n\n  const title = isViewing ? \"DAT File Preview\" : \"Conversion Successful\";\n  const description = isViewing \n        ? \"Review the content of the DAT file below.\"\n        : \"Your DAT file is ready. Please review the content below before downloading.\";\n  const icon = isViewing ? <Eye className=\"w-6 h-6 text-primary\" /> : <CheckCircle className=\"w-6 h-6 text-accent-foreground\" />;\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-4xl w-full h-[80vh] flex flex-col p-0 bg-white text-black\">\n        <DialogHeader className=\"p-6 pb-4 shrink-0\">\n            <div className=\"flex items-center gap-4\">\n                <div className=\"flex-shrink-0 w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center\">\n                    {icon}\n                </div>\n                <div>\n                    <DialogTitle className=\"text-xl text-black\">{title}</DialogTitle>\n                    <DialogDescription className=\"text-slate-600\">\n                        {description}\n                    </DialogDescription>\n                </div>\n            </div>\n        </DialogHeader>\n        <div className=\"flex-1 px-6 pb-4 flex flex-col gap-4 min-h-0\">\n            <div className=\"font-mono text-sm space-y-1 shrink-0\">\n                <p><span className=\"font-semibold\">Filename:</span> {fileName}</p>\n                {reportType === 'sales' && (\n                    <>\n                        <p><span className=\"font-semibold\">Total Exempt:</span> {formatCurrency(totals.exempt)}</p>\n                        <p><span className=\"font-semibold\">Total Zero-Rated:</span> {formatCurrency(totals.zeroRated)}</p>\n                        <p><span className=\"font-semibold\">Total Vatable:</span> {formatCurrency(totals.vatable)}</p>\n                        <p><span className=\"font-semibold\">Total Output VAT:</span> {formatCurrency(totals.outputVat)}</p>\n                    </>\n                )}\n                {reportType === 'purchases' && (\n                    <>\n                        <p><span className=\"font-semibold\">Total Exempt Purchases:</span> {formatCurrency(totals.exempt)}</p>\n                        <p><span className=\"font-semibold\">Total Zero-Rated Purchases:</span> {formatCurrency(totals.zeroRated)}</p>\n                        <p><span className=\"font-semibold\">Total Purchases of Services:</span> {formatCurrency(totals.services)}</p>\n                        <p><span className=\"font-semibold\">Total Purchases of Capital Goods:</span> {formatCurrency(totals.capitalGoods)}</p>\n                        <p><span className=\"font-semibold\">Total Purchases of Other Goods:</span> {formatCurrency(totals.otherGoods)}</p>\n                        <p><span className=\"font-semibold\">Total Input Tax:</span> {formatCurrency(totals.inputTax)}</p>\n                    </>\n                )}\n                {reportType === '1601eq' && (\n                    <>\n                        <p><span className=\"font-semibold\">Total Taxable Income Payment:</span> {formatCurrency(totals.taxableIncome)}</p>\n                        <p><span className=\"font-semibold\">Total Exempt Income Payment:</span> {formatCurrency(totals.exemptIncome)}</p>\n                        <p><span className=\"font-semibold\">Total Withholding Tax:</span> {formatCurrency(totals.withholdingTax)}</p>\n                    </>\n                )}\n                 {reportType === 'sawt' && (\n                    <>\n                        <p><span className=\"font-semibold\">Total Income Payment:</span> {formatCurrency(totals.taxableIncome)}</p>\n                        <p><span className=\"font-semibold\">Total Tax Withheld:</span> {formatCurrency(totals.withholdingTax)}</p>\n                    </>\n                )}\n            </div>\n            <ScrollArea className=\"flex-1 border rounded-md\">\n                <pre className=\"p-4 text-xs font-mono whitespace-pre\">{content}</pre>\n                <ScrollBar orientation=\"horizontal\" />\n            </ScrollArea>\n        </div>\n        <DialogFooter className=\"p-4 border-t shrink-0\">\n          {showDownload && (\n              <Button onClick={handleDownload}>\n                <Download className=\"mr-2 h-4 w-4\" />\n                Download\n              </Button>\n          )}\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2846, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/error-summary-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/components/ui/dialog';\nimport { Button } from './ui/button';\nimport { AlertTriangle } from 'lucide-react';\nimport { ScrollArea } from './ui/scroll-area';\nimport { Card, CardContent, CardHeader } from './ui/card';\n\ninterface ErrorSummaryDialogProps {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n  errors: string[];\n}\n\nexport function ErrorSummaryDialog({\n  isOpen,\n  onOpenChange,\n  errors,\n}: ErrorSummaryDialogProps) {\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-2xl w-full flex flex-col p-0 bg-white text-black\">\n        <DialogHeader className=\"p-6\">\n            <div className=\"flex items-center gap-4\">\n                <div className=\"flex-shrink-0 w-12 h-12 rounded-full bg-destructive/10 flex items-center justify-center\">\n                    <AlertTriangle className=\"w-6 h-6 text-destructive\" />\n                </div>\n                <div>\n                    <DialogTitle className=\"text-xl text-black\">Validation Errors Found</DialogTitle>\n                    <DialogDescription className=\"text-slate-600\">\n                        Please correct the following issues in your Excel file and upload it again.\n                    </DialogDescription>\n                </div>\n            </div>\n        </DialogHeader>\n        <div className=\"px-6 pb-6 flex-1 overflow-hidden\">\n            <ScrollArea className=\"h-full max-h-[50vh] pr-4 -mr-4\">\n                <div className=\"space-y-2 font-mono text-sm\">\n                    {errors.map((error, index) => (\n                        <div key={index} className=\"p-3 rounded-md border bg-slate-50 text-slate-700 text-xs\">\n                           {error}\n                        </div>\n                    ))}\n                </div>\n            </ScrollArea>\n        </div>\n        <DialogFooter className=\"p-4 border-t\">\n          <Button onClick={() => onOpenChange(false)}>\n            Close\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AAQA;AACA;AACA;AAZA;;;;;;AAqBO,SAAS,mBAAmB,EACjC,MAAM,EACN,YAAY,EACZ,MAAM,EACkB;IAExB,qBACE,6LAAC,qIAAA,CAAA,SAAM;QAAC,MAAM;QAAQ,cAAc;kBAClC,cAAA,6LAAC,qIAAA,CAAA,gBAAa;YAAC,WAAU;;8BACvB,6LAAC,qIAAA,CAAA,eAAY;oBAAC,WAAU;8BACpB,cAAA,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC,2NAAA,CAAA,gBAAa;oCAAC,WAAU;;;;;;;;;;;0CAE7B,6LAAC;;kDACG,6LAAC,qIAAA,CAAA,cAAW;wCAAC,WAAU;kDAAqB;;;;;;kDAC5C,6LAAC,qIAAA,CAAA,oBAAiB;wCAAC,WAAU;kDAAiB;;;;;;;;;;;;;;;;;;;;;;;8BAM1D,6LAAC;oBAAI,WAAU;8BACX,cAAA,6LAAC,6IAAA,CAAA,aAAU;wBAAC,WAAU;kCAClB,cAAA,6LAAC;4BAAI,WAAU;sCACV,OAAO,GAAG,CAAC,CAAC,OAAO,sBAChB,6LAAC;oCAAgB,WAAU;8CACvB;mCADM;;;;;;;;;;;;;;;;;;;;8BAO1B,6LAAC,qIAAA,CAAA,eAAY;oBAAC,WAAU;8BACtB,cAAA,6LAAC,qIAAA,CAAA,SAAM;wBAAC,SAAS,IAAM,aAAa;kCAAQ;;;;;;;;;;;;;;;;;;;;;;AAOtD;KAzCgB","debugId":null}},
    {"offset": {"line": 2989, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/non-creditable-tax-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/components/ui/dialog';\nimport { Button } from './ui/button';\nimport { Input } from './ui/input';\nimport { Label } from './ui/label';\nimport { Loader2 } from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\ninterface NonCreditableTaxDialogProps {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n  totalInputTax: number;\n  onContinue: (nonCreditableTax: number) => void;\n  isCreating: boolean;\n}\n\nconst formatCurrency = (value: number | undefined) => {\n    if (value === undefined || isNaN(value)) return '0.00';\n    return new Intl.NumberFormat('en-US', {\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2,\n    }).format(value);\n};\n\nconst formatInputValue = (value: string): string => {\n    if (!value) return '';\n    const parts = value.split('.');\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n    return parts.join('.');\n};\n\n\nexport function NonCreditableTaxDialog({\n  isOpen,\n  onOpenChange,\n  totalInputTax,\n  onContinue,\n  isCreating,\n}: NonCreditableTaxDialogProps) {\n  const [nonCreditableTax, setNonCreditableTax] = useState(0);\n  const [inputValue, setInputValue] = useState('0.00');\n  const [error, setError] = useState<string | null>(null);\n  const creditableTax = totalInputTax - nonCreditableTax;\n\n  useEffect(() => {\n    // Reset when dialog opens\n    if (isOpen) {\n      setNonCreditableTax(0);\n      setInputValue('0.00');\n      setError(null);\n    }\n  }, [isOpen]);\n\n  const handleContinueClick = () => {\n    if (!error) {\n      onContinue(nonCreditableTax);\n    }\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const rawValue = e.target.value;\n    const sanitizedValue = rawValue.replace(/[^0-9.]/g, '');\n    const parts = sanitizedValue.split('.');\n    \n    // Ensure only one decimal point\n    if (parts.length > 2) {\n      return; \n    }\n\n    const numericValue = parseFloat(sanitizedValue);\n\n    if (isNaN(numericValue)) {\n        setNonCreditableTax(0);\n        setError(null);\n        setInputValue('');\n        return;\n    }\n    \n    setNonCreditableTax(numericValue);\n\n    if (numericValue > totalInputTax) {\n        setError('Amount cannot exceed Total Input Tax.');\n    } else {\n        setError(null);\n    }\n\n    // Format for display\n    const formattedValue = formatInputValue(sanitizedValue);\n    setInputValue(formattedValue);\n  };\n  \n  const handleBlur = () => {\n     let numericValue = parseFloat(inputValue.replace(/,/g, ''));\n      if (isNaN(numericValue)) {\n        numericValue = 0;\n      }\n      setInputValue(formatCurrency(numericValue));\n  };\n\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md bg-white text-black\">\n        <DialogHeader>\n          <DialogTitle className=\"text-black\">Enter Value</DialogTitle>\n          <DialogDescription className=\"text-slate-600\">\n            Please provide the non-creditable input tax amount.\n          </DialogDescription>\n        </DialogHeader>\n        <div className=\"space-y-4 py-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"non-creditable\" className=\"text-black\">\n              Non-Creditable Input Tax\n            </Label>\n            <Input\n              id=\"non-creditable\"\n              type=\"text\"\n              inputMode=\"decimal\"\n              value={inputValue}\n              onChange={handleInputChange}\n              onBlur={handleBlur}\n              className={cn(\"bg-slate-100\", error && 'border-destructive focus-visible:ring-destructive')}\n              disabled={isCreating}\n            />\n            {error && <p className=\"text-sm text-destructive mt-1\">{error}</p>}\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"total-input\" className=\"text-black\">\n              Total Input Tax\n            </Label>\n            <Input\n              id=\"total-input\"\n              value={formatCurrency(totalInputTax)}\n              disabled\n              className=\"bg-slate-200\"\n            />\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"creditable\" className=\"text-black\">\n              Creditable Input Tax\n            </Label>\n            <Input\n              id=\"creditable\"\n              value={formatCurrency(error ? 0 : creditableTax)}\n              disabled\n              className=\"bg-slate-200\"\n            />\n          </div>\n        </div>\n        <DialogFooter>\n          <Button onClick={handleContinueClick} disabled={isCreating || !!error}>\n            {isCreating && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n            Continue\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3262, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/alert-dialog.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3414, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/overwrite-dialog.tsx"],"sourcesContent":["\n'use client';\n\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/components/ui/alert-dialog';\nimport { Button } from '@/components/ui/button';\nimport { AlertTriangle, Loader2 } from 'lucide-react';\n\ninterface OverwriteDialogProps {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n  fileName: string;\n  transactionType: string;\n  reportingPeriod: string;\n  onConfirm: () => void;\n  isOverwriting: boolean;\n}\n\nexport function OverwriteDialog({\n  isOpen,\n  onOpenChange,\n  fileName,\n  transactionType,\n  reportingPeriod,\n  onConfirm,\n  isOverwriting,\n}: OverwriteDialogProps) {\n  return (\n    <AlertDialog open={isOpen} onOpenChange={onOpenChange}>\n      <AlertDialogContent className=\"bg-white text-black\">\n        <AlertDialogHeader>\n            <div className=\"flex items-center gap-4\">\n                <div className=\"flex-shrink-0 w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center\">\n                    <AlertTriangle className=\"w-6 h-6 text-primary\" />\n                </div>\n                <div>\n                    <AlertDialogTitle className=\"text-xl text-black\">Existing File Found!</AlertDialogTitle>\n                    <AlertDialogDescription className=\"text-slate-600 pt-1\">\n                        An existing file was found. Do you want to overwrite it?\n                    </AlertDialogDescription>\n                </div>\n            </div>\n        </AlertDialogHeader>\n        <div className=\"pl-16 pr-6 py-4 space-y-2 text-sm text-slate-800\">\n            <p><span className=\"font-semibold text-slate-500\">File Name:</span> {fileName}</p>\n            <p><span className=\"font-semibold text-slate-500\">Transaction Type:</span> {transactionType}</p>\n            <p><span className=\"font-semibold text-slate-500\">Reporting Period:</span> {reportingPeriod}</p>\n        </div>\n        <AlertDialogFooter>\n          <AlertDialogCancel disabled={isOverwriting}>Cancel</AlertDialogCancel>\n          <AlertDialogAction asChild>\n            <Button\n              onClick={onConfirm}\n              disabled={isOverwriting}\n            >\n              {isOverwriting && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n              Overwrite\n            </Button>\n          </AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AAUA;AACA;AAAA;AAbA;;;;;AAyBO,SAAS,gBAAgB,EAC9B,MAAM,EACN,YAAY,EACZ,QAAQ,EACR,eAAe,EACf,eAAe,EACf,SAAS,EACT,aAAa,EACQ;IACrB,qBACE,6LAAC,8IAAA,CAAA,cAAW;QAAC,MAAM;QAAQ,cAAc;kBACvC,cAAA,6LAAC,8IAAA,CAAA,qBAAkB;YAAC,WAAU;;8BAC5B,6LAAC,8IAAA,CAAA,oBAAiB;8BACd,cAAA,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC,2NAAA,CAAA,gBAAa;oCAAC,WAAU;;;;;;;;;;;0CAE7B,6LAAC;;kDACG,6LAAC,8IAAA,CAAA,mBAAgB;wCAAC,WAAU;kDAAqB;;;;;;kDACjD,6LAAC,8IAAA,CAAA,yBAAsB;wCAAC,WAAU;kDAAsB;;;;;;;;;;;;;;;;;;;;;;;8BAMpE,6LAAC;oBAAI,WAAU;;sCACX,6LAAC;;8CAAE,6LAAC;oCAAK,WAAU;8CAA+B;;;;;;gCAAiB;gCAAE;;;;;;;sCACrE,6LAAC;;8CAAE,6LAAC;oCAAK,WAAU;8CAA+B;;;;;;gCAAwB;gCAAE;;;;;;;sCAC5E,6LAAC;;8CAAE,6LAAC;oCAAK,WAAU;8CAA+B;;;;;;gCAAwB;gCAAE;;;;;;;;;;;;;8BAEhF,6LAAC,8IAAA,CAAA,oBAAiB;;sCAChB,6LAAC,8IAAA,CAAA,oBAAiB;4BAAC,UAAU;sCAAe;;;;;;sCAC5C,6LAAC,8IAAA,CAAA,oBAAiB;4BAAC,OAAO;sCACxB,cAAA,6LAAC,qIAAA,CAAA,SAAM;gCACL,SAAS;gCACT,UAAU;;oCAET,+BAAiB,6LAAC,oNAAA,CAAA,UAAO;wCAAC,WAAU;;;;;;oCAA+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQlF;KA7CgB","debugId":null}},
    {"offset": {"line": 3615, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/home-content.tsx"],"sourcesContent":["\n'use client';\n\nimport Link from 'next/link';\nimport type { TaxProfile } from '@/lib/schemas';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { ProfileSelector } from '@/components/profile-selector';\nimport { GenerationCard } from '@/components/generation-card';\nimport { FileUp, FileText, Download, Terminal, Loader2 } from 'lucide-react';\nimport { TaxProfilesSkeleton } from './tax-profiles-skeleton';\nimport { Button } from './ui/button';\nimport { Alert, AlertDescription, AlertTitle } from './ui/alert';\nimport { createPurchasesDatFile, convertExcelToDat, validateExcelForPurchases, overwriteDatFile, validateAndProcessSAWT } from '@/lib/actions';\nimport { useToast } from '@/hooks/use-toast';\nimport { DatPreviewDialog } from './dat-preview-dialog';\nimport type { DatPreviewState } from './dat-preview-dialog';\nimport { useState } from 'react';\nimport { ErrorSummaryDialog } from './error-summary-dialog';\nimport { NonCreditableTaxDialog } from './non-creditable-tax-dialog';\nimport { OverwriteDialog } from './overwrite-dialog';\nimport { useDatFiles } from '@/hooks/use-dat-files';\n\ninterface HomeContentProps {\n  profiles: TaxProfile[];\n  isPending: boolean;\n  initialFetchComplete: boolean;\n  onNewProfile: () => void;\n  selectedProfile: string;\n  onProfileSelect: (tin: string) => void;\n}\n\nconst datFileReminders = [\n  \"Ensure all required data fields in the Excel template are populated accurately.\",\n  \"Specify the reporting month and reporting year. Select the reporting type you need to generate. Each reporting type has a corresponding Excel template. Verify that you are using the correct template for the chosen reporting type.\",\n  \"Before submission, validate the generated DAT File using the BIR Validation Module. This step is crucial to ensure the file complies with BIR standards. Once validated, email the DAT File to esubmission@bir.gov.ph.\"\n];\n\ninterface PurchaseTotalsState {\n    totalInputTax: number;\n    processedData: any[]; // Store the successfully processed data\n}\n\ninterface OverwriteState {\n    isOpen: boolean;\n    fileName: string;\n    transactionType: string;\n    reportingPeriod: string;\n    formData: FormData | null;\n    processedData?: any[];\n    nonCreditableTax?: number;\n}\n\nexport function HomeContent({ \n  profiles, \n  isPending, \n  initialFetchComplete, \n  onNewProfile,\n  selectedProfile,\n  onProfileSelect\n}: HomeContentProps) {\n  const { toast } = useToast();\n  const { addOrUpdateFile } = useDatFiles();\n  const [isPreviewOpen, setIsPreviewOpen] = useState(false);\n  const [datPreview, setDatPreview] = useState<DatPreviewState>({ \n    fileName: '', \n    content: '',\n    reportType: 'none',\n    totals: {}\n  });\n  const [isErrorsOpen, setIsErrorsOpen] = useState(false);\n  const [validationErrors, setValidationErrors] = useState<string[]>([]);\n  const [isNonCreditableDialogOpen, setIsNonCreditableDialogOpen] = useState(false);\n  const [purchaseTotals, setPurchaseTotals] = useState<PurchaseTotalsState | null>(null);\n  const [currentGenerationArgs, setCurrentGenerationArgs] = useState<any>(null);\n  const [isCreatingDat, setIsCreatingDat] = useState(false);\n  const [isOverwriting, setIsOverwriting] = useState(false);\n  const [overwriteState, setOverwriteState] = useState<OverwriteState>({\n    isOpen: false,\n    fileName: '',\n    transactionType: '',\n    reportingPeriod: '',\n    formData: null,\n    processedData: undefined,\n    nonCreditableTax: undefined,\n  });\n\n  const getSimpleTransactionType = (type: string, schedule?: string) => {\n      if (type.includes('Sales')) return 'Sales';\n      if (type.includes('Purchases')) return 'Purchases';\n      if (type.includes('1601-EQ')) return '1601-EQ';\n      if (type.includes('SAWT')) return `SAWT-${schedule}`;\n      return type;\n  }\n\n  const handleDatGeneration = async (file: File, month: string, year: string, type: string, schedule?: string) => {\n    const profile = profiles.find(p => p.tpTIN === selectedProfile);\n    if (!profile) {\n        toast({ title: 'Profile not found', description: 'Please select a valid profile.', variant: 'destructive'});\n        return;\n    }\n\n    const folderId = localStorage.getItem('folderId');\n    if (!folderId) {\n        toast({ title: 'User folder not found', description: 'Please log in again to sync your user folder.', variant: 'destructive'});\n        return;\n    }\n    \n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('reportType', type);\n    formData.append('month', month);\n    formData.append('year', year);\n    formData.append('profile', JSON.stringify(profile));\n    formData.append('folderId', folderId);\n     if (schedule) {\n        formData.append('schedule', schedule);\n    }\n    \n    if (type === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n        if (!schedule) {\n            toast({ title: 'Schedule Missing', description: 'Please select a schedule for SAWT.', variant: 'destructive' });\n            return;\n        }\n        const result = await convertExcelToDat(formData);\n        if (result.success && result.datContent && result.fileName) {\n            if (result.datFile) addOrUpdateFile(result.datFile);\n            setDatPreview({\n                fileName: result.fileName,\n                content: result.datContent,\n                reportType: 'sawt',\n                totals: {\n                    taxableIncome: result.totalTaxableIncomePayment ?? 0,\n                    withholdingTax: result.totalWithholdingTax ?? 0,\n                }\n            });\n            setIsPreviewOpen(true);\n        } else if (!result.success && result.errors && result.errors.length > 0) {\n            setValidationErrors(result.errors);\n            setIsErrorsOpen(true);\n        } else if (!result.success && result.fileExists) {\n             const reportingPeriod = new Date(parseInt(year), parseInt(month) - 1).toLocaleString('default', { month: 'long', year: 'numeric' });\n             setOverwriteState({\n                isOpen: true,\n                fileName: result.fileName || 'Unknown',\n                transactionType: getSimpleTransactionType(type, schedule),\n                reportingPeriod: reportingPeriod,\n                formData: formData,\n            });\n        } else {\n             toast({\n                title: 'SAWT Processing Failed',\n                description: result.error || 'An unexpected error occurred during SAWT processing.',\n                variant: 'destructive',\n            });\n        }\n        return;\n    }\n\n\n    if (type === 'Summary of Purchases (SLP)') {\n        const validationResult = await validateExcelForPurchases(formData);\n        if (validationResult.success && validationResult.totalInputTax !== null && validationResult.processedData) {\n            setPurchaseTotals({\n                totalInputTax: validationResult.totalInputTax,\n                processedData: validationResult.processedData,\n            });\n            setCurrentGenerationArgs({ month, year, profile, folderId, reportType: type }); // Save args for the next step\n            setIsNonCreditableDialogOpen(true);\n        } else if (!validationResult.success && validationResult.errors && validationResult.errors.length > 0) {\n            setValidationErrors(validationResult.errors);\n            setIsErrorsOpen(true);\n        } else {\n             toast({\n                title: 'Validation Failed',\n                description: validationResult.error || 'An unexpected error occurred during validation.',\n                variant: 'destructive',\n            });\n        }\n        return;\n    }\n\n    const result = await convertExcelToDat(formData);\n\n    if (result.success && result.datContent !== null && result.fileName) {\n        if (result.datFile) addOrUpdateFile(result.datFile);\n        if (type === 'Summary of Sales (SLS)') {\n            setDatPreview({ \n                fileName: result.fileName, \n                content: result.datContent,\n                reportType: 'sales',\n                totals: {\n                    exempt: result.totalExempt ?? 0,\n                    zeroRated: result.totalZeroRated ?? 0,\n                    vatable: result.totalTaxableSales ?? 0,\n                    outputVat: result.totalOutputTax ?? 0,\n                }\n            });\n        } else if (type === '1601-EQ (Schedule 1 and 2)') {\n            setDatPreview({ \n                fileName: result.fileName, \n                content: result.datContent,\n                reportType: '1601eq',\n                totals: {\n                    taxableIncome: result.totalTaxableIncomePayment ?? 0,\n                    exemptIncome: result.totalExemptIncomePayment ?? 0,\n                    withholdingTax: result.totalWithholdingTax ?? 0,\n                }\n            });\n        } else {\n             setDatPreview({ \n                fileName: result.fileName, \n                content: result.datContent,\n                reportType: 'none',\n                totals: {}\n            });\n        }\n        setIsPreviewOpen(true);\n    } else if (!result.success && result.errors && result.errors.length > 0) {\n        setValidationErrors(result.errors);\n        setIsErrorsOpen(true);\n    } else if (!result.success && result.fileExists) {\n        const reportingPeriod = new Date(parseInt(year), parseInt(month) - 1).toLocaleString('default', { month: 'long', year: 'numeric' });\n        setOverwriteState({\n            isOpen: true,\n            fileName: result.fileName || 'Unknown',\n            transactionType: getSimpleTransactionType(type),\n            reportingPeriod: reportingPeriod,\n            formData: formData,\n        });\n    } else {\n        toast({\n            title: 'Conversion Failed',\n            description: result.error || 'An unexpected error occurred.',\n            variant: 'destructive',\n        });\n    }\n  };\n\n  const handleOverwriteConfirm = async () => {\n    if (!overwriteState.formData) return;\n    setIsOverwriting(true);\n    \n    // For purchases, the overwrite function needs the processed data, not the original file.\n    // The `overwriteDatFile` action now handles this logic.\n    const result = await overwriteDatFile(overwriteState.formData);\n    \n    setIsOverwriting(false);\n    setOverwriteState({ isOpen: false, fileName: '', transactionType: '', reportingPeriod: '', formData: null });\n\n    if (result.success && result.datContent !== null && result.fileName) {\n        if (result.datFile) addOrUpdateFile(result.datFile);\n        if (overwriteState.transactionType === 'Sales') {\n            setDatPreview({\n                fileName: result.fileName,\n                content: result.datContent,\n                reportType: 'sales',\n                totals: {\n                    exempt: result.totalExempt ?? 0,\n                    zeroRated: result.totalZeroRated ?? 0,\n                    vatable: result.totalTaxableSales ?? 0,\n                    outputVat: result.totalOutputTax ?? 0,\n                }\n            });\n        } else if (overwriteState.transactionType === 'Purchases') {\n            setDatPreview({\n                fileName: result.fileName,\n                content: result.datContent,\n                reportType: 'purchases',\n                totals: {\n                    exempt: result.totalExempt ?? 0,\n                    zeroRated: result.totalZeroRated ?? 0,\n                    services: result.totalServices ?? 0,\n                    capitalGoods: result.totalCapitalGoods ?? 0,\n                    otherGoods: result.totalOtherGoods ?? 0,\n                    inputTax: result.totalInputTax ?? 0,\n                }\n            });\n        } else if (overwriteState.transactionType === '1601-EQ') {\n            setDatPreview({\n                fileName: result.fileName,\n                content: result.datContent,\n                reportType: '1601eq',\n                totals: {\n                    taxableIncome: result.totalTaxableIncomePayment ?? 0,\n                    exemptIncome: result.totalExemptIncomePayment ?? 0,\n                    withholdingTax: result.totalWithholdingTax ?? 0,\n                }\n            });\n        } else if (overwriteState.transactionType.startsWith('SAWT')) {\n             setDatPreview({\n                fileName: result.fileName,\n                content: result.datContent,\n                reportType: 'sawt',\n                totals: {\n                    taxableIncome: result.totalTaxableIncomePayment ?? 0,\n                    withholdingTax: result.totalWithholdingTax ?? 0,\n                }\n            });\n        }\n        setIsPreviewOpen(true);\n    } else {\n        toast({\n            title: 'Overwrite Failed',\n            description: result.error || 'An unexpected error occurred.',\n            variant: 'destructive',\n        });\n    }\n  };\n\n\n  const handleNonCreditableContinue = async (nonCreditableTax: number) => {\n    if (!purchaseTotals || !currentGenerationArgs) return;\n    \n    setIsCreatingDat(true);\n\n    try {\n        const { month, year, profile, folderId, reportType } = currentGenerationArgs;\n        \n        const formData = new FormData();\n        formData.append('processedData', JSON.stringify(purchaseTotals.processedData));\n        formData.append('profile', JSON.stringify(profile));\n        formData.append('month', month);\n        formData.append('year', year);\n        formData.append('nonCreditableInputTax', nonCreditableTax.toString());\n        formData.append('folderId', folderId);\n        formData.append('reportType', reportType);\n\n        const result = await createPurchasesDatFile(formData);\n\n        if (result.success && result.datContent && result.fileName) {\n             if (result.datFile) addOrUpdateFile(result.datFile);\n             setDatPreview({\n                fileName: result.fileName,\n                content: result.datContent,\n                reportType: 'purchases',\n                totals: {\n                    exempt: result.totalExempt ?? 0,\n                    zeroRated: result.totalZeroRated ?? 0,\n                    services: result.totalServices ?? 0,\n                    capitalGoods: result.totalCapitalGoods ?? 0,\n                    otherGoods: result.totalOtherGoods ?? 0,\n                    inputTax: result.totalInputTax ?? 0,\n                }\n            });\n            setIsPreviewOpen(true);\n        } else if (!result.success && result.fileExists && result.fileName) {\n             const reportingPeriod = new Date(parseInt(year), parseInt(month) - 1).toLocaleString('default', { month: 'long', year: 'numeric' });\n             // We need to save the processed data and non-creditable tax for the overwrite action\n             const overwriteFormData = new FormData();\n             overwriteFormData.append('processedData', JSON.stringify(purchaseTotals.processedData));\n             overwriteFormData.append('profile', JSON.stringify(profile));\n             overwriteFormData.append('month', month);\n             overwriteFormData.append('year', year);\n             overwriteFormData.append('nonCreditableInputTax', nonCreditableTax.toString());\n             overwriteFormData.append('folderId', folderId);\n             overwriteFormData.append('reportType', reportType);\n             \n             setOverwriteState({\n                isOpen: true,\n                fileName: result.fileName,\n                transactionType: getSimpleTransactionType(reportType),\n                reportingPeriod: reportingPeriod,\n                formData: overwriteFormData,\n            });\n        } else {\n            toast({\n                title: 'Conversion Failed',\n                description: result.error || 'An unexpected error occurred.',\n                variant: 'destructive',\n            });\n        }\n    } finally {\n        setIsCreatingDat(false);\n        setIsNonCreditableDialogOpen(false);\n        setPurchaseTotals(null);\n        setCurrentGenerationArgs(null);\n    }\n  }\n\n  const handleCertGeneration = (file: File, name: string, tin: string, position: string, signatureFile: File | null) => {\n    console.log('Generating Certificate for:', selectedProfile, 'with details:', {\n      file: file.name,\n      signatoryName: name,\n      signatoryTIN: tin,\n      signatoryPosition: position,\n      signatureFile: signatureFile?.name,\n    });\n    // Placeholder for Certificate generation logic\n  };\n\n  const showLoading = isPending || !initialFetchComplete;\n\n  return (\n    <>\n      <div className=\"flex-1 space-y-4 p-4 md:p-6\">\n        <div className=\"space-y-1\">\n          <h1 className=\"text-3xl font-bold\">Welcome to DATGenie!</h1>\n          <p className=\"text-muted-foreground\">Effortlessly convert your Excel files to DAT format and generate BIR Certificates.</p>\n        </div>\n\n        <div className=\"space-y-6\">\n          <Card className=\"w-full\">\n            <CardHeader>\n              <CardTitle>Step 1: Select a Profile</CardTitle>\n              <CardDescription>Choose the tax profile you want to work with or create a new one.</CardDescription>\n            </CardHeader>\n            <CardContent>\n              {showLoading ? (\n                <div className=\"w-full max-w-lg\">\n                    <TaxProfilesSkeleton />\n                </div>\n              ) : (\n                <ProfileSelector \n                    profiles={profiles} \n                    onProfileSelect={onProfileSelect} \n                    onNewProfile={onNewProfile}\n                    selectedProfile={selectedProfile}\n                />\n              )}\n            </CardContent>\n          </Card>\n          \n          {selectedProfile && (\n            <>\n              <Card className=\"w-full animate-in fade-in-50 duration-500\">\n                <CardHeader>\n                  <CardTitle>Step 2: Get Your Template</CardTitle>\n                  <CardDescription>If you don't have the template, download the required Excel file before proceeding.</CardDescription>\n                </CardHeader>\n                <CardContent>\n                  <Button asChild>\n                    <Link href=\"/template\">\n                      <Download className=\"mr-2 h-4 w-4\" />\n                      Download Templates\n                    </Link>\n                  </Button>\n                </CardContent>\n              </Card>\n\n              <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6 animate-in fade-in-50 duration-700\">\n                <GenerationCard\n                    title=\"Final Step: Generate .DAT File\"\n                    description=\"Upload the corresponding Excel file to convert it into a .DAT file.\"\n                    buttonText=\"Generate .DAT\"\n                    onGenerate={handleDatGeneration}\n                    icon={<FileUp className=\"w-6 h-6\" />}\n                    isDatGeneration={true}\n                    reminders={datFileReminders}\n                />\n                <GenerationCard\n                    title=\"Final Step: Generate BIR Certificate\"\n                    description=\"Upload the Excel file and provide signatory details to generate the certificate.\"\n                    buttonText=\"Generate Certificate\"\n                    onGenerate={handleCertGeneration}\n                    icon={<FileText className=\"w-6 h-6\" />}\n                    isDatGeneration={false}\n                />\n              </div>\n            </>\n          )}\n\n          {!showLoading && profiles.length === 0 && (\n            <Alert>\n                <Terminal className=\"h-4 w-4\" />\n                <AlertTitle>No Tax Profiles Found</AlertTitle>\n                <AlertDescription>\n                    You haven't created any tax profiles yet. Please create a new profile to begin.\n                </AlertDescription>\n            </Alert>\n          )}\n        </div>\n      </div>\n      <DatPreviewDialog\n        isOpen={isPreviewOpen}\n        onOpenChange={setIsPreviewOpen}\n        fileName={datPreview.fileName}\n        content={datPreview.content}\n        reportType={datPreview.reportType}\n        totals={datPreview.totals}\n        isViewing={datPreview.isViewing}\n      />\n      <ErrorSummaryDialog\n        isOpen={isErrorsOpen}\n        onOpenChange={setIsErrorsOpen}\n        errors={validationErrors}\n      />\n      {purchaseTotals && (\n        <NonCreditableTaxDialog\n          isOpen={isNonCreditableDialogOpen}\n          onOpenChange={(open) => {\n            if (!isCreatingDat) {\n                setIsNonCreditableDialogOpen(open);\n            }\n          }}\n          totalInputTax={purchaseTotals.totalInputTax}\n          onContinue={handleNonCreditableContinue}\n          isCreating={isCreatingDat}\n        />\n      )}\n      <OverwriteDialog\n        isOpen={overwriteState.isOpen}\n        onOpenChange={(open) => {\n            if (!isOverwriting) {\n                setOverwriteState(prev => ({...prev, isOpen: open}));\n            }\n        }}\n        fileName={overwriteState.fileName}\n        transactionType={overwriteState.transactionType}\n        reportingPeriod={overwriteState.reportingPeriod}\n        onConfirm={handleOverwriteConfirm}\n        isOverwriting={isOverwriting}\n      />\n    </>\n  );\n}\n\n    \n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4329, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, updateUserFolderId } from './googlesheets';\nimport type { TaxProfile, DatFile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema, DatFileSchema } from './schemas';\nimport * as xlsx from 'xlsx';\nimport { uploadFileToDrive, listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken, createFolderInDrive } from './drive';\nimport { atcWE, atcExempt, atcWG } from './schedules';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    const folderId = await createFolderInDrive(`DATGenie_${userData.userName}`);\n    await appendUserToSheet({ ...userData, folderId });\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId, folderId: folderId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    fileExists: z.boolean().optional(),\n    datFile: DatFileSchema.nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    // 1601-EQ and SAWT Totals\n    totalTaxableIncomePayment: z.number().nullable(),\n    totalExemptIncomePayment: z.number().nullable(),\n    totalWithholdingTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ñ/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nasync function generateSalesDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin } = profile;\n    \n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n    if (fileErrors.length > 0) {\n        return { \n            success: false, \n            errors: fileErrors, \n            datContent: null, fileName: null, error: null, datFile: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n        if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n        \n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n        \n        const numericFields = [\n            { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n            { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n        }\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return {\n            success: false, errors: validationErrors, error: \"Validation failed.\", datFile: null,\n            datContent: null, fileName: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n    \n    const datFileName = `${tin}S${month}${year}.DAT`;\n    const reportTypeShort = \"Sales\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'S', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const headerRow = ['H', 'S', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    // Check for existing file before returning immediately\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null,\n        };\n    }\n            \n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()}, // Return dummy file data immediately\n        totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax,\n        error: null, errors: null, totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nasync function generate1601EQDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin, branchCode } = profile;\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const { data: sched1DataRows, validationErrors: sched1FileErrors } = await processExcelFile(file, \"1601EQ_sched1\");\n    if (sched1FileErrors.length > 0) return { ...defaultErrorResult, errors: sched1FileErrors };\n\n    const { data: sched2DataRows, validationErrors: sched2FileErrors } = await processExcelFile(file, \"1601EQ_sched2\");\n    if (sched2FileErrors.length > 0) return { ...defaultErrorResult, errors: sched2FileErrors };\n\n    const sched1HasData = sched1DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n    const sched2HasData = sched2DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n\n    if (!sched1HasData && !sched2HasData) {\n        return { ...defaultErrorResult, errors: [\"No data found in Schedule 1 or Schedule 2 sheets.\"] };\n    }\n\n    const validationErrors: string[] = [];\n\n    // Process Schedule 1 (Taxable)\n    const processedSched1Data = sched1DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched1 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched1 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], `Sched1 ${field.name}`, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = atcWE.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Sched1 Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 1.`);\n                }\n            } else validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    // Process Schedule 2 (Exempt)\n    const processedSched2Data = sched2DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n\n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched2 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n\n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched2 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const result = sanitizeAndValidateNumber(processedRow[7], `Sched2 Income Payment`, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[7] = result.value;\n\n            if (atc) {\n                const atcData = atcExempt.find(item => item.atc === atc);\n                if (!atcData) validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 2.`);\n            } else validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) return { ...defaultErrorResult, errors: validationErrors };\n    \n    // All validations passed, now check for existing file\n    const datFileName = `${tin}${branchCode}${month.padStart(2, '0')}${year}1601EQ.DAT`;\n    const reportTypeShort = \"1601EQ\";\n    const drivePath = [tin, reportTypeShort, year];\n    \n    processedSched1Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    processedSched2Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n    let datContentParts: string[] = [];\n    \n    // Header Row\n    const taxpayerName = profile.entityType === 'Individual'\n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const mainHeader = ['HQAP', 'H1601EQ', profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), reportingPeriod, profile.rdoCode].join(',');\n    datContentParts.push(mainHeader);\n\n    let totalTaxableIncomePayment = 0;\n    let totalWithholdingTax = 0;\n    let totalExemptIncomePayment = 0;\n\n    // Schedule 1 Content\n    if (processedSched1Data.length > 0) {\n        const detailRows1 = processedSched1Data.map((row, index) => ['D1', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7], row[8], row[9]].join(',')).join('\\n');\n        totalTaxableIncomePayment = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        totalWithholdingTax = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const footerRow1 = ['C1', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalTaxableIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n        datContentParts.push(detailRows1, footerRow1);\n    }\n\n    // Schedule 2 Content\n    if (processedSched2Data.length > 0) {\n        const detailRows2 = processedSched2Data.map((row, index) => ['D2', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7]].join(',')).join('\\n');\n        totalExemptIncomePayment = processedSched2Data.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const footerRow2 = ['C2', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalExemptIncomePayment.toFixed(2)].join(',');\n        datContentParts.push(detailRows2, footerRow2);\n    }\n\n    const datContent = datContentParts.join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment,\n        totalExemptIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!file || !reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for conversion.' };\n    }\n\n    try {\n        const profile: TaxProfile = JSON.parse(profileString);\n        if (reportType === \"Summary of Sales (SLS)\") {\n            return await generateSalesDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            return await validateExcelForPurchases(formData);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n            return await generate1601EQDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!schedule) {\n                return { ...defaultErrorResult, error: 'SAWT schedule is missing.' };\n            }\n            const result = await validateAndProcessSAWT(formData, false);\n            if (result.success) {\n                 return { ...result };\n            }\n            return result;\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function overwriteDatFile(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const processedDataString = formData.get('processedData') as string | null;\n    const nonCreditableTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for overwrite.' };\n    }\n     const profile: TaxProfile = JSON.parse(profileString);\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n            return await generateSalesDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            if (!processedDataString || nonCreditableTaxString === null) return { ...defaultErrorResult, error: 'Missing processed data for overwrite.' };\n            const processedData = JSON.parse(processedDataString);\n            const nonCreditableInputTax = parseFloat(nonCreditableTaxString);\n            return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, true);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n             if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n             return await generate1601EQDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!file || !schedule) return { ...defaultErrorResult, error: 'Missing file or schedule for SAWT overwrite.' };\n            return await validateAndProcessSAWT(formData, true);\n        }\n\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported for overwrite.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during overwrite.';\n        console.error('[overwriteDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Overwrite failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\nasync function generatePurchasesDatFile(\n    processedData: any[][],\n    profile: TaxProfile,\n    month: string,\n    year: string,\n    nonCreditableInputTax: number,\n    folderId: string,\n    overwrite: boolean = false\n): Promise<DatFileResult> {\n     const { tpTIN: tin } = profile;\n    const datFileName = `${tin}P${month}${year}.DAT`;\n    const reportTypeShort = \"Purchases\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'P', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], row[11], row[12], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n    const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n    const headerRow = ['H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true);\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null, totalExempt: null, totalZeroRated: null,\n            totalTaxableSales: null, totalOutputTax: null, totalServices: null, totalCapitalGoods: null,\n            totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalExempt, totalZeroRated,\n        totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax,\n        error: null, errors: null, totalTaxableSales: null, totalOutputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nexport async function createPurchasesDatFile(formData: FormData): Promise<DatFileResult> {\n    const processedDataString = formData.get('processedData') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const nonCreditableInputTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    if (!processedDataString || !profileString || !month || !year || nonCreditableInputTaxString === null || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for purchase file creation.' };\n    }\n    \n    try {\n        const processedData = JSON.parse(processedDataString);\n        const profile: TaxProfile = JSON.parse(profileString);\n        const nonCreditableInputTax = parseFloat(nonCreditableInputTaxString);\n\n        return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, false);\n\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nexport async function validateAndProcessSAWT(formData: FormData, overwrite: boolean = false): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const schedule = formData.get('schedule') as string;\n    const profileString = formData.get('profile') as string;\n    const month = formData.get('month') as string;\n    const year = formData.get('year') as string;\n    const folderId = formData.get('folderId') as string;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const profile: TaxProfile = JSON.parse(profileString);\n\n    const sheetName = `sawt_${schedule}`;\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, sheetName);\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    if (dataRows.length === 0) {\n        return { ...defaultErrorResult, success: false, errors: [`No data found in sheet \"${sheetName}\".`] };\n    }\n\n    const validationErrors: string[] = [];\n    const combinedATC = [...atcWE, ...atcWG];\n\n    const processedData = dataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = combinedATC.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Row ${originalRowNumber}: ATC code '${atc}' is not valid for SAWT.`);\n                }\n            } else {\n                validationErrors.push(`Row ${originalRowNumber}: ATC code is missing.`);\n            }\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    processedData.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    \n    const datFileName = `${profile.tpTIN}${profile.branchCode}${month.padStart(2, '0')}${year}${schedule}.DAT`;\n    const reportTypeShort = `SAWT_${schedule}`;\n    const drivePath = [profile.tpTIN, reportTypeShort, year];\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n\n    const taxpayerName = profile.entityType === 'Individual' \n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const header = ['HSAWT', `H${schedule}`, profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.middleName), reportingPeriod, profile.rdoCode].join(',');\n\n    const detailRows = processedData.map((row, index) => {\n        return [\n            'DSAWT', `D${schedule}`, index + 1, row[0], row[1],\n            quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n            reportingPeriod, '', row[6], row[7], row[8], row[9]\n        ].join(',');\n    }).join('\\n');\n\n    const totalIncomePayment = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalWithholdingTax = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    \n    const footer = ['CSAWT', `C${schedule}`, profile.tpTIN, profile.branchCode, reportingPeriod, totalIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n\n    const datContent = [header, detailRows, footer].join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent: datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment: totalIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;IAwIsB,gBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 4345, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, updateUserFolderId } from './googlesheets';\nimport type { TaxProfile, DatFile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema, DatFileSchema } from './schemas';\nimport * as xlsx from 'xlsx';\nimport { uploadFileToDrive, listDatFiles, downloadFileFromDrive, deleteFileFromDrive, getInitialPageTokenForDrive, listChangesSincePageToken, createFolderInDrive } from './drive';\nimport { atcWE, atcExempt, atcWG } from './schedules';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    const folderId = await createFolderInDrive(`DATGenie_${userData.userName}`);\n    await appendUserToSheet({ ...userData, folderId });\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId, folderId: folderId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    fileExists: z.boolean().optional(),\n    datFile: DatFileSchema.nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    // 1601-EQ and SAWT Totals\n    totalTaxableIncomePayment: z.number().nullable(),\n    totalExemptIncomePayment: z.number().nullable(),\n    totalWithholdingTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ñ/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nasync function generateSalesDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin } = profile;\n    \n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n    if (fileErrors.length > 0) {\n        return { \n            success: false, \n            errors: fileErrors, \n            datContent: null, fileName: null, error: null, datFile: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n        if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n        \n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n        \n        const numericFields = [\n            { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n            { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n        }\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return {\n            success: false, errors: validationErrors, error: \"Validation failed.\", datFile: null,\n            datContent: null, fileName: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n    \n    const datFileName = `${tin}S${month}${year}.DAT`;\n    const reportTypeShort = \"Sales\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'S', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const headerRow = ['H', 'S', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    // Check for existing file before returning immediately\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null,\n            totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n            totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null,\n        };\n    }\n            \n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()}, // Return dummy file data immediately\n        totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax,\n        error: null, errors: null, totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nasync function generate1601EQDatFile(file: File, profile: TaxProfile, month: string, year: string, folderId: string, overwrite: boolean = false): Promise<DatFileResult> {\n    const { tpTIN: tin, branchCode } = profile;\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const { data: sched1DataRows, validationErrors: sched1FileErrors } = await processExcelFile(file, \"1601EQ_sched1\");\n    if (sched1FileErrors.length > 0) return { ...defaultErrorResult, errors: sched1FileErrors };\n\n    const { data: sched2DataRows, validationErrors: sched2FileErrors } = await processExcelFile(file, \"1601EQ_sched2\");\n    if (sched2FileErrors.length > 0) return { ...defaultErrorResult, errors: sched2FileErrors };\n\n    const sched1HasData = sched1DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n    const sched2HasData = sched2DataRows.some(row => row.some(cell => String(cell).trim() !== ''));\n\n    if (!sched1HasData && !sched2HasData) {\n        return { ...defaultErrorResult, errors: [\"No data found in Schedule 1 or Schedule 2 sheets.\"] };\n    }\n\n    const validationErrors: string[] = [];\n\n    // Process Schedule 1 (Taxable)\n    const processedSched1Data = sched1DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched1 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched1 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], `Sched1 ${field.name}`, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = atcWE.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Sched1 Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 1.`);\n                }\n            } else validationErrors.push(`Sched1 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    // Process Schedule 2 (Exempt)\n    const processedSched2Data = sched2DataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n\n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Sched2 Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n\n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], `Sched2 ${field.name}`, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const result = sanitizeAndValidateNumber(processedRow[7], `Sched2 Income Payment`, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[7] = result.value;\n\n            if (atc) {\n                const atcData = atcExempt.find(item => item.atc === atc);\n                if (!atcData) validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code '${atc}' is not valid for Schedule 2.`);\n            } else validationErrors.push(`Sched2 Row ${originalRowNumber}: ATC code is missing.`);\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) return { ...defaultErrorResult, errors: validationErrors };\n    \n    // All validations passed, now check for existing file\n    const datFileName = `${tin}${branchCode}${month.padStart(2, '0')}${year}1601EQ.DAT`;\n    const reportTypeShort = \"1601EQ\";\n    const drivePath = [tin, reportTypeShort, year];\n    \n    processedSched1Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    processedSched2Data.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n    let datContentParts: string[] = [];\n    \n    // Header Row\n    const taxpayerName = profile.entityType === 'Individual'\n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const mainHeader = ['HQAP', 'H1601EQ', profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), reportingPeriod, profile.rdoCode].join(',');\n    datContentParts.push(mainHeader);\n\n    let totalTaxableIncomePayment = 0;\n    let totalWithholdingTax = 0;\n    let totalExemptIncomePayment = 0;\n\n    // Schedule 1 Content\n    if (processedSched1Data.length > 0) {\n        const detailRows1 = processedSched1Data.map((row, index) => ['D1', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7], row[8], row[9]].join(',')).join('\\n');\n        totalTaxableIncomePayment = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        totalWithholdingTax = processedSched1Data.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const footerRow1 = ['C1', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalTaxableIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n        datContentParts.push(detailRows1, footerRow1);\n    }\n\n    // Schedule 2 Content\n    if (processedSched2Data.length > 0) {\n        const detailRows2 = processedSched2Data.map((row, index) => ['D2', '1601EQ', index + 1, row[0], row[1], quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), reportingPeriod, row[6], row[7]].join(',')).join('\\n');\n        totalExemptIncomePayment = processedSched2Data.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const footerRow2 = ['C2', '1601EQ', profile.tpTIN, profile.branchCode, reportingPeriod, totalExemptIncomePayment.toFixed(2)].join(',');\n        datContentParts.push(detailRows2, footerRow2);\n    }\n\n    const datContent = datContentParts.join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment,\n        totalExemptIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!file || !reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for conversion.' };\n    }\n\n    try {\n        const profile: TaxProfile = JSON.parse(profileString);\n        if (reportType === \"Summary of Sales (SLS)\") {\n            return await generateSalesDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            return await validateExcelForPurchases(formData);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n            return await generate1601EQDatFile(file, profile, month, year, folderId, false);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!schedule) {\n                return { ...defaultErrorResult, error: 'SAWT schedule is missing.' };\n            }\n            const result = await validateAndProcessSAWT(formData, false);\n            if (result.success) {\n                 return { ...result };\n            }\n            return result;\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function overwriteDatFile(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n    const processedDataString = formData.get('processedData') as string | null;\n    const nonCreditableTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const schedule = formData.get('schedule') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null,\n    };\n\n    if (!reportType || !month || !year || !profileString || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for overwrite.' };\n    }\n     const profile: TaxProfile = JSON.parse(profileString);\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n            return await generateSalesDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary of Purchases (SLP)\") {\n            if (!processedDataString || nonCreditableTaxString === null) return { ...defaultErrorResult, error: 'Missing processed data for overwrite.' };\n            const processedData = JSON.parse(processedDataString);\n            const nonCreditableInputTax = parseFloat(nonCreditableTaxString);\n            return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, true);\n        }\n        if (reportType === \"1601-EQ (Schedule 1 and 2)\") {\n             if (!file) return { ...defaultErrorResult, error: 'Missing file for overwrite.' };\n             return await generate1601EQDatFile(file, profile, month, year, folderId, true);\n        }\n        if (reportType === \"Summary Alphalist of Withholding Tax (SAWT)\") {\n            if (!file || !schedule) return { ...defaultErrorResult, error: 'Missing file or schedule for SAWT overwrite.' };\n            return await validateAndProcessSAWT(formData, true);\n        }\n\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported for overwrite.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during overwrite.';\n        console.error('[overwriteDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Overwrite failed: ${errorMessage}` };\n    }\n}\n\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 50, required: true },\n            { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false },\n            { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: true },\n            { name: 'Address 2', index: 6, maxLength: 30, required: true },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    }).filter(row => row.length > 0 && row.some(cell => String(cell).trim() !== ''));\n\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n    \n    processedData.sort((a, b) => String(a[1]).localeCompare(String(b[1])));\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\nasync function generatePurchasesDatFile(\n    processedData: any[][],\n    profile: TaxProfile,\n    month: string,\n    year: string,\n    nonCreditableInputTax: number,\n    folderId: string,\n    overwrite: boolean = false\n): Promise<DatFileResult> {\n     const { tpTIN: tin } = profile;\n    const datFileName = `${tin}P${month}${year}.DAT`;\n    const reportTypeShort = \"Purchases\";\n    const drivePath = [tin, reportTypeShort, year];\n\n    const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n    const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n    const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n    const detailRows = processedData.map(row => ['D', 'P', quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]), quoteIfNotEmpty(row[6]), row[7], row[8], row[9], row[10], row[11], row[12], tin, lastDayDate].join(',')).join('\\n');\n    const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n    const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n    const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n    const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n    const headerRow = ['H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2), totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2), profile.rdoCode, lastDayDate, profile.monthSelect].join(',');\n    const datContent = `${headerRow}\\n${detailRows}`;\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true);\n    if (fileExists && !overwrite) {\n        return {\n            success: false, fileExists: true, fileName: datFileName, datFile: null,\n            datContent: null, error: null, errors: null, totalExempt: null, totalZeroRated: null,\n            totalTaxableSales: null, totalOutputTax: null, totalServices: null, totalCapitalGoods: null,\n            totalOtherGoods: null, totalInputTax: null,\n            totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n            processedData: null\n        };\n    }\n\n    return { \n        success: true, datContent, fileName: datFileName, datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalExempt, totalZeroRated,\n        totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax,\n        error: null, errors: null, totalTaxableSales: null, totalOutputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n}\n\n\nexport async function createPurchasesDatFile(formData: FormData): Promise<DatFileResult> {\n    const processedDataString = formData.get('processedData') as string | null;\n    const profileString = formData.get('profile') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const nonCreditableInputTaxString = formData.get('nonCreditableInputTax') as string | null;\n    const folderId = formData.get('folderId') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    if (!processedDataString || !profileString || !month || !year || nonCreditableInputTaxString === null || !folderId) {\n        return { ...defaultErrorResult, error: 'Missing required parameters for purchase file creation.' };\n    }\n    \n    try {\n        const processedData = JSON.parse(processedDataString);\n        const profile: TaxProfile = JSON.parse(profileString);\n        const nonCreditableInputTax = parseFloat(nonCreditableInputTaxString);\n\n        return await generatePurchasesDatFile(processedData, profile, month, year, nonCreditableInputTax, folderId, false);\n\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\n\nconst DatFileListingResultSchema = z.object({\n  success: z.boolean(),\n  files: z.array(DatFileSchema).nullable(),\n  folderIds: z.array(z.string()).nullable(),\n  error: z.string().nullable(),\n});\ntype DatFileListingResult = z.infer<typeof DatFileListingResultSchema>;\n\nexport async function getDatFiles(folderId: string): Promise<DatFileListingResult> {\n    if (!folderId) {\n        return { success: false, files: null, folderIds: null, error: 'User folder ID is missing.' };\n    }\n    try {\n        const { files, folderIds } = await listDatFiles(folderId);\n        return { success: true, files, folderIds, error: null };\n    } catch (e) {\n        console.error('[getDatFiles] CRITICAL ERROR:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, files: null, folderIds: null, error: `Failed to retrieve DAT files: ${errorMessage}` };\n    }\n}\n\nconst DatFileContentResultSchema = z.object({\n    success: z.boolean(),\n    content: z.string().nullable(),\n    error: z.string().nullable(),\n});\ntype DatFileContentResult = z.infer<typeof DatFileContentResultSchema>;\n\nexport async function getDatFileContent(fileId: string): Promise<DatFileContentResult> {\n    try {\n        if (!fileId) {\n            return { success: false, content: null, error: 'File ID is required.' };\n        }\n        const content = await downloadFileFromDrive(fileId);\n        return { success: true, content: content, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, content: null, error: 'File not found.' };\n        }\n        console.error(`[getDatFileContent] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, content: null, error: `Failed to retrieve file content: ${errorMessage}` };\n    }\n}\n\nexport async function deleteDatFile(fileId: string): Promise<SimpleResult> {\n    try {\n        if (!fileId) {\n            return { success: false, error: 'File ID is required.' };\n        }\n        await deleteFileFromDrive(fileId);\n        return { success: true, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        if (errorMessage.includes('File not found')) {\n            return { success: false, error: 'File not found.' };\n        }\n        console.error(`[deleteDatFile] CRITICAL ERROR for fileId ${fileId}:`, e);\n        return { success: false, error: `Failed to delete file: ${errorMessage}` };\n    }\n}\n\nexport async function validateAndProcessSAWT(formData: FormData, overwrite: boolean = false): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const schedule = formData.get('schedule') as string;\n    const profileString = formData.get('profile') as string;\n    const month = formData.get('month') as string;\n    const year = formData.get('year') as string;\n    const folderId = formData.get('folderId') as string;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null, error: null, datFile: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        totalTaxableIncomePayment: null, totalExemptIncomePayment: null, totalWithholdingTax: null,\n        processedData: null\n    };\n    \n    const profile: TaxProfile = JSON.parse(profileString);\n\n    const sheetName = `sawt_${schedule}`;\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, sheetName);\n    if (fileErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: fileErrors };\n    }\n\n    if (dataRows.length === 0) {\n        return { ...defaultErrorResult, success: false, errors: [`No data found in sheet \"${sheetName}\".`] };\n    }\n\n    const validationErrors: string[] = [];\n    const combinedATC = [...atcWE, ...atcWG];\n\n    const processedData = dataRows\n        .filter(row => row.some(cell => String(cell).trim() !== ''))\n        .map((row, index) => {\n            const originalRowNumber = index + 2;\n            const processedRow = [...row];\n            \n            if (String(processedRow[0] || '').trim()) {\n                const originalTin = String(processedRow[0]);\n                const sanitizedTin = originalTin.replace(/[^0-9]/g, '').substring(0, 9);\n                if (sanitizedTin.length > 0 && sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be 9 digits if provided.`);\n                processedRow[0] = sanitizedTin;\n            } else {\n                 processedRow[0] = '';\n            }\n            \n            let branchCode = String(processedRow[1] || '').replace(/[^0-9]/g, '');\n            processedRow[1] = branchCode ? branchCode.slice(-4).padStart(4, '0') : \"0000\";\n            \n            const nameFieldsInfo = [\n                { name: 'Registered Name', index: 2, maxLength: 50, required: true },\n                { name: 'Last Name', index: 3, maxLength: 30, required: false },\n                { name: 'First Name', index: 4, maxLength: 30, required: false },\n                { name: 'Middle Name', index: 5, maxLength: 30, required: false },\n            ];\n            nameFieldsInfo.forEach(field => {\n                const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            const atc = String(processedRow[6] || '').toUpperCase().replace(/[^A-Z0-9]/g, '');\n            processedRow[6] = atc;\n            \n            const numericFields = [{ name: 'Rate', index: 7 }, { name: 'Income Payment', index: 8 }, { name: 'Withholding Tax', index: 9 }];\n            numericFields.forEach(field => {\n                const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                if (result.error) validationErrors.push(result.error);\n                processedRow[field.index] = result.value;\n            });\n\n            if (atc) {\n                const atcData = combinedATC.find(item => item.atc === atc);\n                if (atcData) {\n                    if (parseFloat(processedRow[7]) !== atcData.rate) {\n                        validationErrors.push(`Row ${originalRowNumber}: Invalid rate for ATC ${atc}. Expected ${atcData.rate}%, but got ${parseFloat(processedRow[7])}%.`);\n                    }\n                } else {\n                    validationErrors.push(`Row ${originalRowNumber}: ATC code '${atc}' is not valid for SAWT.`);\n                }\n            } else {\n                validationErrors.push(`Row ${originalRowNumber}: ATC code is missing.`);\n            }\n            \n            return processedRow;\n        });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    processedData.sort((a, b) => String(a[2]).localeCompare(String(b[2])));\n    \n    const datFileName = `${profile.tpTIN}${profile.branchCode}${month.padStart(2, '0')}${year}${schedule}.DAT`;\n    const reportTypeShort = `SAWT_${schedule}`;\n    const drivePath = [profile.tpTIN, reportTypeShort, year];\n\n    const reportingPeriod = `${month.padStart(2, '0')}/${year}`;\n\n    const taxpayerName = profile.entityType === 'Individual' \n        ? `${profile.lastName} ${profile.firstName} ${profile.middleName}`\n        : profile.companyName;\n\n    const header = ['HSAWT', `H${schedule}`, profile.tpTIN, profile.branchCode, quoteIfNotEmpty(taxpayerName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.middleName), reportingPeriod, profile.rdoCode].join(',');\n\n    const detailRows = processedData.map((row, index) => {\n        return [\n            'DSAWT', `D${schedule}`, index + 1, row[0], row[1],\n            quoteIfNotEmpty(row[2]), quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n            reportingPeriod, '', row[6], row[7], row[8], row[9]\n        ].join(',');\n    }).join('\\n');\n\n    const totalIncomePayment = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n    const totalWithholdingTax = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n    \n    const footer = ['CSAWT', `C${schedule}`, profile.tpTIN, profile.branchCode, reportingPeriod, totalIncomePayment.toFixed(2), totalWithholdingTax.toFixed(2)].join(',');\n\n    const datContent = [header, detailRows, footer].join('\\n');\n    \n    // Non-blocking upload\n    uploadFileToDrive(datFileName, datContent, folderId, drivePath, overwrite).then(({ file: uploadedFile, fileExists }) => {\n        if (fileExists) {\n             console.log(`[actions] File ${datFileName} already exists. Overwrite was false.`);\n        } else if (uploadedFile) {\n            console.log(`[actions] File ${datFileName} uploaded successfully in the background.`);\n        } else {\n            console.error(`[actions] Background upload for ${datFileName} failed.`);\n        }\n    });\n\n    const { fileExists } = await uploadFileToDrive(datFileName, datContent, folderId, drivePath, false, true); // Dry run check\n    if (fileExists && !overwrite) {\n        return { ...defaultErrorResult, success: false, fileExists: true, fileName: datFileName };\n    }\n\n    return {\n        ...defaultErrorResult,\n        success: true,\n        datContent: datContent,\n        fileName: datFileName,\n        datFile: { id: 'temp-id', name: datFileName, path: drivePath.join(' / '), modifiedTime: new Date().toISOString()},\n        totalTaxableIncomePayment: totalIncomePayment,\n        totalWithholdingTax,\n    };\n}\n\n\nconst PageTokenResultSchema = z.object({\n  success: z.boolean(),\n  token: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype PageTokenResult = z.infer<typeof PageTokenResultSchema>;\n\nexport async function getInitialPageToken(): Promise<PageTokenResult> {\n    try {\n        const token = await getInitialPageTokenForDrive();\n        return { success: true, token, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, token: null, error: `Failed to get initial page token: ${errorMessage}` };\n    }\n}\n\nconst ChangesResultSchema = z.object({\n  success: z.boolean(),\n  hasChanges: z.boolean(),\n  newToken: z.string().nullable(),\n  error: z.string().nullable(),\n});\ntype ChangesResult = z.infer<typeof ChangesResultSchema>;\n\nexport async function checkForDatFileChanges(allFolderIds: string[], pageToken: string): Promise<ChangesResult> {\n    if (!allFolderIds || allFolderIds.length === 0 || !pageToken) {\n        return { success: false, hasChanges: false, newToken: null, error: 'Folder IDs and page token are required.' };\n    }\n    try {\n        const { hasChanges, newPageToken } = await listChangesSincePageToken(allFolderIds, pageToken);\n        return { success: true, hasChanges, newToken: newPageToken, error: null };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, hasChanges: false, newToken: pageToken, error: `Failed to check for changes: ${errorMessage}` };\n    }\n}\n\n    "],"names":[],"mappings":";;;;;;IAkKsB,mBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 4361, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/ui/form.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4579, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/schemas.ts"],"sourcesContent":["\nimport { z } from 'zod';\n\nconst alphanumericWithSpaces = (name: string, length: number, required = true) => {\n  const schema = z.string()\n   .max(length, `${name} must be ${length} characters or less.`)\n   .regex(/^[a-zA-Z0-9\\s]*$/, `${name} must only contain letters, numbers, and spaces.`);\n  \n  if (required) {\n    return schema.min(1, `${name} is required.`);\n  }\n  return schema.optional().or(z.literal(''));\n};\n\nexport const TaxProfileSchema = z.object({\n  tpTIN: z.string().regex(/^[0-9]{9}$/, 'TIN must be 9 digits.'),\n  branchCode: z.string().regex(/^[0-9]{4}$/, 'Branch code must be 4 digits.'),\n  rdoCode: z.string().min(1, 'RDO Code is required.'),\n  entityType: z.string(),\n  cycleType: z.string(),\n  monthSelect: z.string().min(1, 'Month is required.'),\n  companyName: alphanumericWithSpaces('Company Name', 50, false),\n  lastName: alphanumericWithSpaces('Last Name', 30, false),\n  firstName: alphanumericWithSpaces('First Name', 30, false),\n  middleName: alphanumericWithSpaces('Middle Name', 30, false),\n  tradeName: alphanumericWithSpaces('Trade Name', 50),\n  subStreet: z.string().max(30, 'Unit/Floor/Substreet must be 30 characters or less.').optional().or(z.literal('')),\n  street: z.string().max(30, 'Street must be 30 characters or less.').min(1, 'Street is required.'),\n  barangay: z.string().max(30, 'Barangay must be 30 characters or less.').min(1, 'Barangay is required.'),\n  cityMunicipality: z.string().max(30, 'City/Municipality must be 30 characters or less.').min(1, 'City/Municipality is required.'),\n  province: z.string().max(30, 'Province must be 30 characters or less.').min(1, 'Province is required.'),\n  zipCode: z.string().regex(/^[0-9]{4}$/, 'Zip code must be 4 digits.'),\n}).passthrough().refine(data => {\n    if (data.entityType === 'Individual') {\n        return !!data.lastName && !!data.firstName && !!data.middleName;\n    }\n    return true;\n}, {\n    message: \"First, Middle, and Last name are required for individuals.\",\n    path: [\"lastName\"], \n}).refine(data => {\n    if (data.entityType === 'Non-Individual') {\n        return !!data.companyName;\n    }\n    return true;\n}, {\n    message: \"Company name is required for non-individuals.\",\n    path: [\"companyName\"],\n});\n\n\nexport type TaxProfile = z.infer<typeof TaxProfileSchema>;\n\n\nexport const MutationResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    data: TaxProfileSchema.nullable(),\n});\n\nexport const DatFileSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  path: z.string(),\n  modifiedTime: z.string(),\n});\nexport type DatFile = z.infer<typeof DatFileSchema>;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4656, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/profile-form.tsx"],"sourcesContent":["\n'use client';\n\nimport { useTransition, useEffect, useState } from 'react';\nimport { useForm, type SubmitHandler } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button';\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n  DialogClose\n} from '@/components/ui/dialog';\nimport { Input } from '@/components/ui/input';\nimport { useToast } from '@/hooks/use-toast';\nimport { Check, ChevronsUpDown, Loader2 } from 'lucide-react';\nimport { addTaxProfile, updateTaxProfile } from '@/lib/actions';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport type { TaxProfile } from '@/lib/schemas';\nimport { TaxProfileSchema } from '@/lib/schemas';\nimport { RadioGroup, RadioGroupItem } from './ui/radio-group';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';\nimport { Popover, PopoverContent, PopoverTrigger } from './ui/popover';\nimport { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from './ui/command';\nimport { cn } from '@/lib/utils';\n\n\ninterface ProfileFormProps {\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  profile: TaxProfile | null;\n  onSuccess: (profile: TaxProfile, isNew: boolean) => void;\n}\n\nconst months = [\n    { name: \"January\", value: \"01\" },\n    { name: \"February\", value: \"02\" },\n    { name: \"March\", value: \"03\" },\n    { name: \"April\", value: \"04\" },\n    { name: \"May\", value: \"05\" },\n    { name: \"June\", value: \"06\" },\n    { name: \"July\", value: \"07\" },\n    { name: \"August\", value: \"08\" },\n    { name: \"September\", value: \"09\" },\n    { name: \"October\", value: \"10\" },\n    { name: \"November\", value: \"11\" },\n    { name: \"December\", value: \"12\" }\n];\n\nconst rdoCodes = [\n    '001', '002', '003', '004', '005', '006', '007', '008', '009', '010',\n    '011', '012', '013', '014', '015', '016', '17A', '17B', '018', '019',\n    '020', '21A', '21B', '022', '23A', '23B', '024', '25A', '25B', '026',\n    '027', '028', '029', '030', '031', '032', '033', '034', '035', '036',\n    '037', '038', '039', '040', '041', '042', '043', '43A', '43B', '044',\n    '045', '046', '047', '048', '049', '050', '051', '052', '53A', '53B',\n    '54A', '54B', '055', '056', '057', '058', '059', '060', '061', '062',\n    '063', '064', '065', '066', '067', '068', '069', '070', '071', '072',\n    '073', '074', '075', '076', '077', '078', '079', '080', '081', '082',\n    '083', '084', '085', '086', '087', '088', '089', '090', '091', '092',\n    '93A', '93B', '094', '095', '096', '097', '098', '099', '100', '101',\n    '102', '103', '104', '105', '106', '107', '108', '109', '110', '111',\n    '112', '113', '114', '115', '116', '117', '118', '119', '120', '121',\n    '122', '123', '124', '125', '126', '127', '132'\n];\n\nconst defaultValues: TaxProfile = {\n    tpTIN: '',\n    branchCode: '0000',\n    rdoCode: '',\n    entityType: 'Individual',\n    cycleType: 'calendar',\n    monthSelect: '12',\n    companyName: '',\n    lastName: '',\n    firstName: '',\n    middleName: '',\n    tradeName: '',\n    subStreet: '',\n    street: '',\n    barangay: '',\n    cityMunicipality: '',\n    province: '',\n    zipCode: '',\n};\n\nexport function ProfileForm({ isOpen, setIsOpen, profile, onSuccess }: ProfileFormProps) {\n  const { toast } = useToast();\n  const [isPending, startTransition] = useTransition();\n  const [popoverOpen, setPopoverOpen] = useState(false);\n\n  const form = useForm<TaxProfile>({\n    resolver: zodResolver(TaxProfileSchema),\n    defaultValues: profile || defaultValues,\n  });\n\n  useEffect(() => {\n    if (isOpen) {\n        form.reset(profile || defaultValues);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [profile, isOpen]);\n\n  const entityType = form.watch('entityType');\n  const cycleType = form.watch('cycleType');\n\n  useEffect(() => {\n    if (cycleType === 'calendar') {\n        form.setValue('monthSelect', '12');\n    }\n  }, [cycleType, form]);\n\n  const onSubmit: SubmitHandler<TaxProfile> = (data) => {\n    startTransition(async () => {\n        const databaseId = localStorage.getItem('databaseId');\n        if (!databaseId) {\n            toast({ title: 'Error', description: 'User session not found. Please log in again.', variant: 'destructive' });\n            return;\n        }\n        \n        const isNew = !profile;\n        const result = isNew\n            ? await addTaxProfile(data, databaseId)\n            : await updateTaxProfile(data, databaseId);\n        \n        if (result.success && result.data) {\n            toast({\n                title: isNew ? 'Profile Created!' : 'Profile Updated!',\n                description: `Profile for ${data.entityType === 'Individual' ? `${data.firstName} ${data.lastName}` : data.companyName} has been saved.`,\n            });\n            onSuccess(result.data, isNew);\n            setIsOpen(false);\n        } else {\n            toast({\n                title: 'Operation Failed',\n                description: result.error,\n                variant: 'destructive',\n            });\n        }\n    });\n  };\n  \n  const inputStyles = \"bg-slate-100\";\n  const sanitizeAlphanumeric = (value: string) => value.replace(/[^a-zA-Z0-9\\s]/g, '');\n  const requiredMark = <span className=\"text-destructive\">*</span>;\n\n  return (\n    <Dialog open={isOpen} onOpenChange={setIsOpen}>\n      <DialogContent className=\"sm:max-w-[800px] bg-white text-black\">\n        <DialogHeader>\n          <DialogTitle className=\"text-black\">{profile ? 'Edit' : 'Create'} Tax Profile</DialogTitle>\n          <DialogDescription className=\"text-slate-600\">\n            Fill in the details below to {profile ? 'update the' : 'create a new'} tax profile. Click save when you're done.\n          </DialogDescription>\n        </DialogHeader>\n        <Form {...form}>\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n            <div className=\"max-h-[60vh] overflow-y-auto pr-4 pl-1 space-y-4\">\n              <FormField\n                control={form.control}\n                name=\"entityType\"\n                render={({ field }) => (\n                  <FormItem className=\"space-y-3\">\n                    <FormLabel className=\"text-black\">Entity Type {requiredMark}</FormLabel>\n                    <FormControl>\n                      <RadioGroup\n                        onValueChange={field.onChange}\n                        defaultValue={field.value}\n                        className=\"flex space-x-4\"\n                      >\n                        <FormItem className=\"flex items-center space-x-2 space-y-0\">\n                          <FormControl>\n                            <RadioGroupItem value=\"Individual\" id=\"individual\" />\n                          </FormControl>\n                          <FormLabel htmlFor=\"individual\" className=\"font-normal text-black\">Individual</FormLabel>\n                        </FormItem>\n                        <FormItem className=\"flex items-center space-x-2 space-y-0\">\n                          <FormControl>\n                            <RadioGroupItem value=\"Non-Individual\" id=\"non-individual\"/>\n                          </FormControl>\n                          <FormLabel htmlFor=\"non-individual\" className=\"font-normal text-black\">Non-Individual</FormLabel>\n                        </FormItem>\n                      </RadioGroup>\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                 <FormField control={form.control} name=\"tpTIN\" render={({ field }) => (\n                    <FormItem>\n                      <FormLabel className=\"text-black\">Taxpayer Identification Number {requiredMark}</FormLabel>\n                      <FormControl><Input placeholder=\"123456789\" {...field} className={inputStyles} readOnly={!!profile} /></FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )} />\n                 <FormField control={form.control} name=\"branchCode\" render={({ field }) => (\n                    <FormItem>\n                      <FormLabel className=\"text-black\">Branch Code {requiredMark}</FormLabel>\n                      <FormControl><Input placeholder=\"0000\" {...field} className={inputStyles} /></FormControl>\n                      <FormMessage />\n                    </FormItem>\n                  )} />\n                 <FormField control={form.control} name=\"rdoCode\" render={({ field }) => (\n                    <FormItem>\n                      <FormLabel className=\"text-black\">RDO Code {requiredMark}</FormLabel>\n                      <Popover open={popoverOpen} onOpenChange={setPopoverOpen}>\n                        <PopoverTrigger asChild>\n                           <FormControl>\n                            <Button\n                              variant=\"outline\"\n                              role=\"combobox\"\n                              className={cn(\"w-full justify-between\", !field.value && \"text-muted-foreground\", inputStyles)}\n                            >\n                              {field.value\n                                ? rdoCodes.find(\n                                    (code) => code === field.value\n                                  )\n                                : \"Select an RDO code\"}\n                              <ChevronsUpDown className=\"ml-2 h-4 w-4 shrink-0 opacity-50\" />\n                            </Button>\n                          </FormControl>\n                        </PopoverTrigger>\n                        <PopoverContent className=\"w-[200px] p-0\">\n                          <Command>\n                            <CommandInput placeholder=\"Search RDO code...\" />\n                            <CommandList>\n                              <CommandEmpty>No RDO code found.</CommandEmpty>\n                              <CommandGroup>\n                                {rdoCodes.map((code) => (\n                                  <CommandItem\n                                    value={code}\n                                    key={code}\n                                    onSelect={() => {\n                                      form.setValue(\"rdoCode\", code)\n                                      setPopoverOpen(false)\n                                    }}\n                                  >\n                                    <Check\n                                      className={cn(\n                                        \"mr-2 h-4 w-4\",\n                                        code === field.value\n                                          ? \"opacity-100\"\n                                          : \"opacity-0\"\n                                      )}\n                                    />\n                                    {code}\n                                  </CommandItem>\n                                ))}\n                              </CommandGroup>\n                            </CommandList>\n                          </Command>\n                        </PopoverContent>\n                      </Popover>\n                      <FormMessage />\n                    </FormItem>\n                  )} />\n              </div>\n\n              {entityType === 'Individual' ? (\n                <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                  <FormField control={form.control} name=\"firstName\" render={({ field }) => (\n                    <FormItem><FormLabel className=\"text-black\">First Name {requiredMark}</FormLabel><FormControl><Input {...field} onChange={(e) => field.onChange(sanitizeAlphanumeric(e.target.value))} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                  )} />\n                  <FormField control={form.control} name=\"middleName\" render={({ field }) => (\n                    <FormItem><FormLabel className=\"text-black\">Middle Name {requiredMark}</FormLabel><FormControl><Input {...field} onChange={(e) => field.onChange(sanitizeAlphanumeric(e.target.value))} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                  )} />\n                  <FormField control={form.control} name=\"lastName\" render={({ field }) => (\n                    <FormItem><FormLabel className=\"text-black\">Last Name {requiredMark}</FormLabel><FormControl><Input {...field} onChange={(e) => field.onChange(sanitizeAlphanumeric(e.target.value))} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                  )} />\n                </div>\n              ) : (\n                <FormField control={form.control} name=\"companyName\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Company Name {requiredMark}</FormLabel><FormControl><Input {...field} onChange={(e) => field.onChange(sanitizeAlphanumeric(e.target.value))} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n              )}\n              \n              <FormField control={form.control} name=\"tradeName\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Trade Name {requiredMark}</FormLabel><FormControl><Input {...field} onChange={(e) => field.onChange(sanitizeAlphanumeric(e.target.value))} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n              )} />\n              \n              <h3 className=\"text-lg font-medium pt-4 text-black\">Registered Address</h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                <FormField control={form.control} name=\"subStreet\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Unit/Floor/Substreet</FormLabel><FormControl><Input {...field} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n                <FormField control={form.control} name=\"street\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Street {requiredMark}</FormLabel><FormControl><Input {...field} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n                <FormField control={form.control} name=\"barangay\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Barangay {requiredMark}</FormLabel><FormControl><Input {...field} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n              </div>\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n                <FormField control={form.control} name=\"cityMunicipality\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">City/Municipality {requiredMark}</FormLabel><FormControl><Input {...field} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n                <FormField control={form.control} name=\"province\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Province {requiredMark}</FormLabel><FormControl><Input {...field} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n                <FormField control={form.control} name=\"zipCode\" render={({ field }) => (\n                  <FormItem><FormLabel className=\"text-black\">Zip Code {requiredMark}</FormLabel><FormControl><Input {...field} className={inputStyles} /></FormControl><FormMessage /></FormItem>\n                )} />\n              </div>\n              \n              <h3 className=\"text-lg font-medium pt-4 text-black\">Taxpayer Type</h3>\n               <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                  <FormField control={form.control} name=\"cycleType\" render={({ field }) => (\n                    <FormItem>\n                      <FormLabel className=\"text-black\">Cycle Type {requiredMark}</FormLabel>\n                        <Select onValueChange={field.onChange} value={field.value}>\n                          <FormControl><SelectTrigger className={inputStyles}><SelectValue placeholder=\"Select a cycle type\" /></SelectTrigger></FormControl>\n                          <SelectContent>\n                            <SelectItem value=\"calendar\">Calendar</SelectItem>\n                            <SelectItem value=\"fiscal\">Fiscal</SelectItem>\n                          </SelectContent>\n                        </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )} />\n                  <FormField control={form.control} name=\"monthSelect\" render={({ field }) => (\n                    <FormItem>\n                      <FormLabel className=\"text-black\">Fiscal Year End Month {requiredMark}</FormLabel>\n                        <Select onValueChange={field.onChange} value={field.value} disabled={cycleType === 'calendar'}>\n                          <FormControl><SelectTrigger className={inputStyles}><SelectValue placeholder=\"Select a month\" /></SelectTrigger></FormControl>\n                          <SelectContent>\n                            {months.map(month => <SelectItem key={month.name} value={month.value}>{month.name}</SelectItem>)}\n                          </SelectContent>\n                        </Select>\n                      <FormMessage />\n                    </FormItem>\n                  )} />\n              </div>\n\n            </div>\n            <DialogFooter className=\"pt-4\">\n              <DialogClose asChild>\n                <Button type=\"button\" variant=\"outline\">Cancel</Button>\n              </DialogClose>\n              <Button type=\"submit\" disabled={isPending}>\n                {isPending && <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />}\n                {profile ? 'Save Changes' : 'Create Profile'}\n              </Button>\n            </DialogFooter>\n          </form>\n        </Form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AA3BA;;;;;;;;;;;;;;;;;AAqCA,MAAM,SAAS;IACX;QAAE,MAAM;QAAW,OAAO;IAAK;IAC/B;QAAE,MAAM;QAAY,OAAO;IAAK;IAChC;QAAE,MAAM;QAAS,OAAO;IAAK;IAC7B;QAAE,MAAM;QAAS,OAAO;IAAK;IAC7B;QAAE,MAAM;QAAO,OAAO;IAAK;IAC3B;QAAE,MAAM;QAAQ,OAAO;IAAK;IAC5B;QAAE,MAAM;QAAQ,OAAO;IAAK;IAC5B;QAAE,MAAM;QAAU,OAAO;IAAK;IAC9B;QAAE,MAAM;QAAa,OAAO;IAAK;IACjC;QAAE,MAAM;QAAW,OAAO;IAAK;IAC/B;QAAE,MAAM;QAAY,OAAO;IAAK;IAChC;QAAE,MAAM;QAAY,OAAO;IAAK;CACnC;AAED,MAAM,WAAW;IACb;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;IAC/D;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;CAC7C;AAED,MAAM,gBAA4B;IAC9B,OAAO;IACP,YAAY;IACZ,SAAS;IACT,YAAY;IACZ,WAAW;IACX,aAAa;IACb,aAAa;IACb,UAAU;IACV,WAAW;IACX,YAAY;IACZ,WAAW;IACX,WAAW;IACX,QAAQ;IACR,UAAU;IACV,kBAAkB;IAClB,UAAU;IACV,SAAS;AACb;AAEO,SAAS,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,SAAS,EAAoB;;IACrF,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,+HAAA,CAAA,WAAQ,AAAD;IACzB,MAAM,CAAC,WAAW,gBAAgB,GAAG,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD;IACjD,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAE/C,MAAM,OAAO,CAAA,GAAA,iKAAA,CAAA,UAAO,AAAD,EAAc;QAC/B,UAAU,CAAA,GAAA,iKAAA,CAAA,cAAW,AAAD,EAAE,wHAAA,CAAA,mBAAgB;QACtC,eAAe,WAAW;IAC5B;IAEA,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;iCAAE;YACR,IAAI,QAAQ;gBACR,KAAK,KAAK,CAAC,WAAW;YAC1B;QACF,uDAAuD;QACvD;gCAAG;QAAC;QAAS;KAAO;IAEpB,MAAM,aAAa,KAAK,KAAK,CAAC;IAC9B,MAAM,YAAY,KAAK,KAAK,CAAC;IAE7B,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;iCAAE;YACR,IAAI,cAAc,YAAY;gBAC1B,KAAK,QAAQ,CAAC,eAAe;YACjC;QACF;gCAAG;QAAC;QAAW;KAAK;IAEpB,MAAM,WAAsC,CAAC;QAC3C,gBAAgB;YACZ,MAAM,aAAa,aAAa,OAAO,CAAC;YACxC,IAAI,CAAC,YAAY;gBACb,MAAM;oBAAE,OAAO;oBAAS,aAAa;oBAAgD,SAAS;gBAAc;gBAC5G;YACJ;YAEA,MAAM,QAAQ,CAAC;YACf,MAAM,SAAS,QACT,MAAM,CAAA,GAAA,qJAAA,CAAA,gBAAa,AAAD,EAAE,MAAM,cAC1B,MAAM,CAAA,GAAA,qJAAA,CAAA,mBAAgB,AAAD,EAAE,MAAM;YAEnC,IAAI,OAAO,OAAO,IAAI,OAAO,IAAI,EAAE;gBAC/B,MAAM;oBACF,OAAO,QAAQ,qBAAqB;oBACpC,aAAa,CAAC,YAAY,EAAE,KAAK,UAAU,KAAK,eAAe,GAAG,KAAK,SAAS,CAAC,CAAC,EAAE,KAAK,QAAQ,EAAE,GAAG,KAAK,WAAW,CAAC,gBAAgB,CAAC;gBAC5I;gBACA,UAAU,OAAO,IAAI,EAAE;gBACvB,UAAU;YACd,OAAO;gBACH,MAAM;oBACF,OAAO;oBACP,aAAa,OAAO,KAAK;oBACzB,SAAS;gBACb;YACJ;QACJ;IACF;IAEA,MAAM,cAAc;IACpB,MAAM,uBAAuB,CAAC,QAAkB,MAAM,OAAO,CAAC,mBAAmB;IACjF,MAAM,6BAAe,6LAAC;QAAK,WAAU;kBAAmB;;;;;;IAExD,qBACE,6LAAC,qIAAA,CAAA,SAAM;QAAC,MAAM;QAAQ,cAAc;kBAClC,cAAA,6LAAC,qIAAA,CAAA,gBAAa;YAAC,WAAU;;8BACvB,6LAAC,qIAAA,CAAA,eAAY;;sCACX,6LAAC,qIAAA,CAAA,cAAW;4BAAC,WAAU;;gCAAc,UAAU,SAAS;gCAAS;;;;;;;sCACjE,6LAAC,qIAAA,CAAA,oBAAiB;4BAAC,WAAU;;gCAAiB;gCACd,UAAU,eAAe;gCAAe;;;;;;;;;;;;;8BAG1E,6LAAC,mIAAA,CAAA,OAAI;oBAAE,GAAG,IAAI;8BACZ,cAAA,6LAAC;wBAAK,UAAU,KAAK,YAAY,CAAC;wBAAW,WAAU;;0CACrD,6LAAC;gCAAI,WAAU;;kDACb,6LAAC,mIAAA,CAAA,YAAS;wCACR,SAAS,KAAK,OAAO;wCACrB,MAAK;wCACL,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAChB,6LAAC,mIAAA,CAAA,WAAQ;gDAAC,WAAU;;kEAClB,6LAAC,mIAAA,CAAA,YAAS;wDAAC,WAAU;;4DAAa;4DAAa;;;;;;;kEAC/C,6LAAC,mIAAA,CAAA,cAAW;kEACV,cAAA,6LAAC,6IAAA,CAAA,aAAU;4DACT,eAAe,MAAM,QAAQ;4DAC7B,cAAc,MAAM,KAAK;4DACzB,WAAU;;8EAEV,6LAAC,mIAAA,CAAA,WAAQ;oEAAC,WAAU;;sFAClB,6LAAC,mIAAA,CAAA,cAAW;sFACV,cAAA,6LAAC,6IAAA,CAAA,iBAAc;gFAAC,OAAM;gFAAa,IAAG;;;;;;;;;;;sFAExC,6LAAC,mIAAA,CAAA,YAAS;4EAAC,SAAQ;4EAAa,WAAU;sFAAyB;;;;;;;;;;;;8EAErE,6LAAC,mIAAA,CAAA,WAAQ;oEAAC,WAAU;;sFAClB,6LAAC,mIAAA,CAAA,cAAW;sFACV,cAAA,6LAAC,6IAAA,CAAA,iBAAc;gFAAC,OAAM;gFAAiB,IAAG;;;;;;;;;;;sFAE5C,6LAAC,mIAAA,CAAA,YAAS;4EAAC,SAAQ;4EAAiB,WAAU;sFAAyB;;;;;;;;;;;;;;;;;;;;;;;kEAI7E,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;kDAKlB,6LAAC;wCAAI,WAAU;;0DACZ,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAQ,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAC9D,6LAAC,mIAAA,CAAA,WAAQ;;0EACP,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAgC;;;;;;;0EAClE,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAC,aAAY;oEAAa,GAAG,KAAK;oEAAE,WAAW;oEAAa,UAAU,CAAC,CAAC;;;;;;;;;;;0EAC3F,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAGjB,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAa,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACnE,6LAAC,mIAAA,CAAA,WAAQ;;0EACP,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAa;;;;;;;0EAC/C,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAC,aAAY;oEAAQ,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAC7D,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAGjB,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAU,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAChE,6LAAC,mIAAA,CAAA,WAAQ;;0EACP,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAU;;;;;;;0EAC5C,6LAAC,sIAAA,CAAA,UAAO;gEAAC,MAAM;gEAAa,cAAc;;kFACxC,6LAAC,sIAAA,CAAA,iBAAc;wEAAC,OAAO;kFACpB,cAAA,6LAAC,mIAAA,CAAA,cAAW;sFACX,cAAA,6LAAC,qIAAA,CAAA,SAAM;gFACL,SAAQ;gFACR,MAAK;gFACL,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EAAE,0BAA0B,CAAC,MAAM,KAAK,IAAI,yBAAyB;;oFAEhF,MAAM,KAAK,GACR,SAAS,IAAI,CACX,CAAC,OAAS,SAAS,MAAM,KAAK,IAEhC;kGACJ,6LAAC,iOAAA,CAAA,iBAAc;wFAAC,WAAU;;;;;;;;;;;;;;;;;;;;;;kFAIhC,6LAAC,sIAAA,CAAA,iBAAc;wEAAC,WAAU;kFACxB,cAAA,6LAAC,sIAAA,CAAA,UAAO;;8FACN,6LAAC,sIAAA,CAAA,eAAY;oFAAC,aAAY;;;;;;8FAC1B,6LAAC,sIAAA,CAAA,cAAW;;sGACV,6LAAC,sIAAA,CAAA,eAAY;sGAAC;;;;;;sGACd,6LAAC,sIAAA,CAAA,eAAY;sGACV,SAAS,GAAG,CAAC,CAAC,qBACb,6LAAC,sIAAA,CAAA,cAAW;oGACV,OAAO;oGAEP,UAAU;wGACR,KAAK,QAAQ,CAAC,WAAW;wGACzB,eAAe;oGACjB;;sHAEA,6LAAC,uMAAA,CAAA,QAAK;4GACJ,WAAW,CAAA,GAAA,sHAAA,CAAA,KAAE,AAAD,EACV,gBACA,SAAS,MAAM,KAAK,GAChB,gBACA;;;;;;wGAGP;;mGAdI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0EAsBnB,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;;oCAKnB,eAAe,6BACd,6LAAC;wCAAI,WAAU;;0DACb,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAY,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACnE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAY;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,UAAU,CAAC,IAAM,MAAM,QAAQ,CAAC,qBAAqB,EAAE,MAAM,CAAC,KAAK;oEAAI,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAE7O,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAa,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACpE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAa;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,UAAU,CAAC,IAAM,MAAM,QAAQ,CAAC,qBAAqB,EAAE,MAAM,CAAC,KAAK;oEAAI,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAE9O,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAW,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAClE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAW;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,UAAU,CAAC,IAAM,MAAM,QAAQ,CAAC,qBAAqB,EAAE,MAAM,CAAC,KAAK;oEAAI,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;6DAI9O,6LAAC,mIAAA,CAAA,YAAS;wCAAC,SAAS,KAAK,OAAO;wCAAE,MAAK;wCAAc,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACrE,6LAAC,mIAAA,CAAA,WAAQ;;kEAAC,6LAAC,mIAAA,CAAA,YAAS;wDAAC,WAAU;;4DAAa;4DAAc;;;;;;;kEAAyB,6LAAC,mIAAA,CAAA,cAAW;kEAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;4DAAE,GAAG,KAAK;4DAAE,UAAU,CAAC,IAAM,MAAM,QAAQ,CAAC,qBAAqB,EAAE,MAAM,CAAC,KAAK;4DAAI,WAAW;;;;;;;;;;;kEAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;kDAIjP,6LAAC,mIAAA,CAAA,YAAS;wCAAC,SAAS,KAAK,OAAO;wCAAE,MAAK;wCAAY,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACjE,6LAAC,mIAAA,CAAA,WAAQ;;kEAAC,6LAAC,mIAAA,CAAA,YAAS;wDAAC,WAAU;;4DAAa;4DAAY;;;;;;;kEAAyB,6LAAC,mIAAA,CAAA,cAAW;kEAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;4DAAE,GAAG,KAAK;4DAAE,UAAU,CAAC,IAAM,MAAM,QAAQ,CAAC,qBAAqB,EAAE,MAAM,CAAC,KAAK;4DAAI,WAAW;;;;;;;;;;;kEAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;kDAG/O,6LAAC;wCAAG,WAAU;kDAAsC;;;;;;kDACpD,6LAAC;wCAAI,WAAU;;0DACb,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAY,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACnE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;0EAAa;;;;;;0EAAgC,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAEjK,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAS,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAChE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAQ;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAElK,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAW,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAClE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAU;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;;kDAGtK,6LAAC;wCAAI,WAAU;;0DACb,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAmB,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAC1E,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAmB;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAE7K,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAW,QAAQ,CAAC,EAAE,KAAK,EAAE,iBAClE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAU;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAEpK,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAU,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACjE,6LAAC,mIAAA,CAAA,WAAQ;;0EAAC,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAU;;;;;;;0EAAyB,6LAAC,mIAAA,CAAA,cAAW;0EAAC,cAAA,6LAAC,oIAAA,CAAA,QAAK;oEAAE,GAAG,KAAK;oEAAE,WAAW;;;;;;;;;;;0EAA6B,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;;kDAItK,6LAAC;wCAAG,WAAU;kDAAsC;;;;;;kDACnD,6LAAC;wCAAI,WAAU;;0DACZ,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAY,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACnE,6LAAC,mIAAA,CAAA,WAAQ;;0EACP,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAY;;;;;;;0EAC5C,6LAAC,qIAAA,CAAA,SAAM;gEAAC,eAAe,MAAM,QAAQ;gEAAE,OAAO,MAAM,KAAK;;kFACvD,6LAAC,mIAAA,CAAA,cAAW;kFAAC,cAAA,6LAAC,qIAAA,CAAA,gBAAa;4EAAC,WAAW;sFAAa,cAAA,6LAAC,qIAAA,CAAA,cAAW;gFAAC,aAAY;;;;;;;;;;;;;;;;kFAC7E,6LAAC,qIAAA,CAAA,gBAAa;;0FACZ,6LAAC,qIAAA,CAAA,aAAU;gFAAC,OAAM;0FAAW;;;;;;0FAC7B,6LAAC,qIAAA,CAAA,aAAU;gFAAC,OAAM;0FAAS;;;;;;;;;;;;;;;;;;0EAGjC,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;0DAGhB,6LAAC,mIAAA,CAAA,YAAS;gDAAC,SAAS,KAAK,OAAO;gDAAE,MAAK;gDAAc,QAAQ,CAAC,EAAE,KAAK,EAAE,iBACrE,6LAAC,mIAAA,CAAA,WAAQ;;0EACP,6LAAC,mIAAA,CAAA,YAAS;gEAAC,WAAU;;oEAAa;oEAAuB;;;;;;;0EACvD,6LAAC,qIAAA,CAAA,SAAM;gEAAC,eAAe,MAAM,QAAQ;gEAAE,OAAO,MAAM,KAAK;gEAAE,UAAU,cAAc;;kFACjF,6LAAC,mIAAA,CAAA,cAAW;kFAAC,cAAA,6LAAC,qIAAA,CAAA,gBAAa;4EAAC,WAAW;sFAAa,cAAA,6LAAC,qIAAA,CAAA,cAAW;gFAAC,aAAY;;;;;;;;;;;;;;;;kFAC7E,6LAAC,qIAAA,CAAA,gBAAa;kFACX,OAAO,GAAG,CAAC,CAAA,sBAAS,6LAAC,qIAAA,CAAA,aAAU;gFAAkB,OAAO,MAAM,KAAK;0FAAG,MAAM,IAAI;+EAA3C,MAAM,IAAI;;;;;;;;;;;;;;;;0EAGtD,6LAAC,mIAAA,CAAA,cAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAMtB,6LAAC,qIAAA,CAAA,eAAY;gCAAC,WAAU;;kDACtB,6LAAC,qIAAA,CAAA,cAAW;wCAAC,OAAO;kDAClB,cAAA,6LAAC,qIAAA,CAAA,SAAM;4CAAC,MAAK;4CAAS,SAAQ;sDAAU;;;;;;;;;;;kDAE1C,6LAAC,qIAAA,CAAA,SAAM;wCAAC,MAAK;wCAAS,UAAU;;4CAC7B,2BAAa,6LAAC,oNAAA,CAAA,UAAO;gDAAC,WAAU;;;;;;4CAChC,UAAU,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQ5C;GAxQgB;;QACI,+HAAA,CAAA,WAAQ;QACW,6JAAA,CAAA,gBAAa;QAGrC,iKAAA,CAAA,UAAO;;;KALN","debugId":null}},
    {"offset": {"line": 6192, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/home/page.tsx"],"sourcesContent":["\n'use client';\n\nimport { useEffect, useCallback, useState } from 'react';\nimport { useToast } from '@/hooks/use-toast';\nimport type { TaxProfile } from '@/lib/schemas';\nimport { HomeContent } from '@/components/home-content';\nimport { useRefresh } from '@/hooks/use-refresh';\nimport { useTaxProfiles } from '@/hooks/use-tax-profiles';\nimport { ProfileForm } from '@/components/profile-form';\n\nexport default function HomePage() {\n  const { toast } = useToast();\n  const { \n    profiles, \n    isPending, \n    initialFetchComplete, \n    fetchProfiles, \n    addProfile, \n    updateProfile,\n    selectedProfile,\n    setSelectedProfile\n  } = useTaxProfiles();\n  const { setRefreshFunction } = useRefresh();\n  const [isFormOpen, setIsFormOpen] = useState(false);\n\n  const handleFetch = useCallback((isManualRefresh = false) => {\n    fetchProfiles(isManualRefresh);\n  }, [fetchProfiles]);\n\n  useEffect(() => {\n    // Set the refresh function for the header button to allow manual refresh\n    setRefreshFunction(() => () => handleFetch(true));\n  }, [handleFetch, setRefreshFunction]);\n\n\n  const handleProfileSuccess = (updatedProfile: TaxProfile, isNew: boolean) => {\n    if (isNew) {\n      addProfile(updatedProfile);\n    } else {\n      updateProfile(updatedProfile);\n    }\n  };\n\n  return (\n    <>\n      <HomeContent\n        profiles={profiles}\n        isPending={isPending}\n        initialFetchComplete={initialFetchComplete}\n        onNewProfile={() => setIsFormOpen(true)}\n        selectedProfile={selectedProfile}\n        onProfileSelect={setSelectedProfile}\n      />\n      <ProfileForm \n        isOpen={isFormOpen}\n        setIsOpen={setIsFormOpen}\n        profile={null}\n        onSuccess={handleProfileSuccess}\n      />\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AAEA;AACA;AACA;AACA;;;AARA;;;;;;;AAUe,SAAS;;IACtB,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,+HAAA,CAAA,WAAQ,AAAD;IACzB,MAAM,EACJ,QAAQ,EACR,SAAS,EACT,oBAAoB,EACpB,aAAa,EACb,UAAU,EACV,aAAa,EACb,eAAe,EACf,kBAAkB,EACnB,GAAG,CAAA,GAAA,0IAAA,CAAA,iBAAc,AAAD;IACjB,MAAM,EAAE,kBAAkB,EAAE,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD;IACxC,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAE7C,MAAM,cAAc,CAAA,GAAA,6JAAA,CAAA,cAAW,AAAD;6CAAE,CAAC,kBAAkB,KAAK;YACtD,cAAc;QAChB;4CAAG;QAAC;KAAc;IAElB,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;8BAAE;YACR,yEAAyE;YACzE;sCAAmB;8CAAM,IAAM,YAAY;;;QAC7C;6BAAG;QAAC;QAAa;KAAmB;IAGpC,MAAM,uBAAuB,CAAC,gBAA4B;QACxD,IAAI,OAAO;YACT,WAAW;QACb,OAAO;YACL,cAAc;QAChB;IACF;IAEA,qBACE;;0BACE,6LAAC,wIAAA,CAAA,cAAW;gBACV,UAAU;gBACV,WAAW;gBACX,sBAAsB;gBACtB,cAAc,IAAM,cAAc;gBAClC,iBAAiB;gBACjB,iBAAiB;;;;;;0BAEnB,6LAAC,wIAAA,CAAA,cAAW;gBACV,QAAQ;gBACR,WAAW;gBACX,SAAS;gBACT,WAAW;;;;;;;;AAInB;GAnDwB;;QACJ,+HAAA,CAAA,WAAQ;QAUtB,0IAAA,CAAA,iBAAc;QACa,kIAAA,CAAA,aAAU;;;KAZnB","debugId":null}}]
}