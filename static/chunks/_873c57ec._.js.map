{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { excelErrorDetection } from '@/ai/flows/excel-error-detection';\nimport type { ExcelErrorDetectionOutput } from '@/ai/schemas';\nimport { ExcelErrorDetectionOutputSchema } from '@/ai/schemas';\nimport { z } from 'zod';\nimport { appendUserToSheet, getAllUsers, getAllHeaderDataFromSheet, appendHeaderDataToSheet, updateHeaderDataInSheet, type SignupData, type LoginData, deleteHeaderDataRowInSheet, uploadTestFileToDrive } from './googlesheets';\nimport type { TaxProfile } from './schemas';\nimport { TaxProfileSchema, MutationResultSchema } from './schemas';\nimport * as xlsx from 'xlsx';\n\nconst AnalyzeFileResultSchema = z.object({\n  success: z.boolean(),\n  data: ExcelErrorDetectionOutputSchema.nullable(),\n  error: z.string().nullable(),\n});\n\ntype AnalyzeFileResult = z.infer<typeof AnalyzeFileResultSchema>;\n\nexport async function analyzeExcelFile(\n  formData: FormData\n): Promise<AnalyzeFileResult> {\n  const file = formData.get('file') as File | null;\n\n  if (!file) {\n    return { success: false, data: null, error: 'No file uploaded.' };\n  }\n\n  // Check file type\n  if (file.type !== 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' && file.type !== 'application/vnd.ms-excel') {\n    return { success: false, data: null, error: 'Invalid file type. Please upload an Excel file.' };\n  }\n  \n  try {\n    const bytes = await file.arrayBuffer();\n    const buffer = Buffer.from(bytes);\n    const dataUri = `data:${file.type};base64,${buffer.toString('base64')}`;\n\n    const result = await excelErrorDetection({ excelDataUri: dataUri });\n\n    return { success: true, data: result, error: null };\n  } catch (e) {\n    console.error(e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to analyze file: ${errorMessage}` };\n  }\n}\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        databaseId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<AuthResult> {\n  try {\n    await appendUserToSheet(userData);\n    return { success: true, error: null, user: null };\n  } catch (e) {\n    console.error('Error signing up user:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to sign up: ${errorMessage}`, user: null };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            return { success: true, error: null, user: { userName: user.userName, databaseId: user.databaseId } };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst TaxProfileResultSchema = z.object({\n  success: z.boolean(),\n  data: z.array(TaxProfileSchema).nullable(),\n  error: z.string().nullable(),\n});\ntype TaxProfileResult = z.infer<typeof TaxProfileResultSchema>;\n\nexport async function getUserHeaderData(databaseId: string): Promise<TaxProfileResult> {\n  try {\n    if (!databaseId) {\n      return { success: false, data: null, error: 'Database ID is required.' };\n    }\n    const headerData = await getAllHeaderDataFromSheet(databaseId);\n    return { success: true, data: headerData, error: null };\n  } catch (error) {\n    console.error('Error fetching header data:', error);\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    return { success: false, data: null, error: `Failed to fetch header data: ${errorMessage}` };\n  }\n}\n\n\ntype MutationResult = z.infer<typeof MutationResultSchema>;\n\nfunction transformToUppercase(data: TaxProfile): TaxProfile {\n  const uppercasedData: { [key: string]: any } = {};\n  for (const key in data) {\n    const value = data[key as keyof TaxProfile];\n    if (typeof value === 'string' && key !== 'entityType' && key !== 'cycleType' && key !== 'monthSelect' && key !== 'rdoCode') {\n      uppercasedData[key] = value.toUpperCase();\n    } else {\n      uppercasedData[key] = value;\n    }\n  }\n  return uppercasedData as TaxProfile;\n}\n\nexport async function addTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n\n    const existingProfiles = await getAllHeaderDataFromSheet(databaseId);\n    const tinExists = existingProfiles.some(p => p.tpTIN === validatedData.tpTIN);\n\n    if (tinExists) {\n        return { \n            success: false, \n            error: 'This TIN already has a profile. Please check your data or refresh the page.', \n            data: null \n        };\n    }\n\n    const uppercasedData = transformToUppercase(validatedData);\n    await appendHeaderDataToSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error adding tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to add profile: ${errorMessage}`, data: null };\n  }\n}\n\n\nexport async function updateTaxProfile(profileData: TaxProfile, databaseId: string): Promise<MutationResult> {\n  try {\n    const validatedData = TaxProfileSchema.parse(profileData);\n    const uppercasedData = transformToUppercase(validatedData);\n    await updateHeaderDataInSheet(uppercasedData, databaseId);\n    return { success: true, error: null, data: uppercasedData };\n  } catch (e) {\n    console.error('Error updating tax profile:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Failed to update profile: ${errorMessage}`, data: null };\n  }\n}\n\nconst SimpleResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n});\ntype SimpleResult = z.infer<typeof SimpleResultSchema>;\n\nexport async function deleteTaxProfile(tpTIN: string, databaseId: string): Promise<SimpleResult> {\n    try {\n        await deleteHeaderDataRowInSheet(tpTIN, databaseId);\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('Error deleting tax profile:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to delete profile: ${errorMessage}` };\n    }\n}\n\nconst DatFileResultSchema = z.object({\n    success: z.boolean(),\n    datContent: z.string().nullable(),\n    fileName: z.string().nullable(),\n    error: z.string().nullable(),\n    errors: z.array(z.string()).nullable(),\n    // Sales Totals\n    totalExempt: z.number().nullable(),\n    totalZeroRated: z.number().nullable(),\n    totalTaxableSales: z.number().nullable(),\n    totalOutputTax: z.number().nullable(),\n    // Purchase Totals\n    totalServices: z.number().nullable(),\n    totalCapitalGoods: z.number().nullable(),\n    totalOtherGoods: z.number().nullable(),\n    totalInputTax: z.number().nullable(),\n    processedData: z.any().nullable(),\n});\ntype DatFileResult = z.infer<typeof DatFileResultSchema>;\n\n\nfunction sanitizeAndValidateString(input: any, fieldName: string, maxLength: number, rowNumber: number, isRequired: boolean = false): { value: string, error: string | null } {\n    let value = (input === null || input === undefined) ? '' : String(input).trim();\n    \n    if (!value) {\n        if (isRequired) {\n            return { value: '', error: `Row ${rowNumber}: ${fieldName} is missing.` };\n        }\n        return { value: '', error: null };\n    }\n\n    let processedString = value\n        .toUpperCase()\n        .replace(/&/g, 'AND')\n        .replace(/Ã‘/g, 'N')\n        .replace(/\\s\\s+/g, ' ')\n        .trim()\n        .replace(/[^A-Z0-9\\s-]/g, '')\n        .replace(/\\s\\s+/g, ' ')\n        .trim();\n\n    if (processedString.length > maxLength) {\n        return { value: processedString, error: `Row ${rowNumber}: ${fieldName} must be ${maxLength} characters or less. It is currently ${processedString.length} characters.` };\n    }\n\n    return { value: processedString, error: null };\n}\n\nfunction sanitizeAndValidateNumber(input: any, fieldName: string, rowNumber: number): { value: string, error: string | null } {\n    if (input === null || input === undefined || String(input).trim() === '') {\n        return { value: '0', error: null };\n    }\n    \n    const valueAsString = String(input).replace(/,/g, '');\n    const num = parseFloat(valueAsString);\n\n    if (isNaN(num)) {\n        return { value: String(input), error: `Row ${rowNumber}: ${fieldName} contains an invalid number.` };\n    }\n    \n    const roundedNum = Math.round(num * 100) / 100;\n    \n    if (roundedNum === 0) {\n        return { value: '0', error: null };\n    }\n\n    return { value: roundedNum.toFixed(2), error: null };\n}\n\nfunction getFormattedLastDay(year: number, month: number): string {\n    // Get the last day of the month. This correctly handles leap years.\n    const day = new Date(year, month, 0).getDate();\n    \n    const date = new Date(year, month - 1, day);\n    const mm = String(date.getMonth() + 1).padStart(2, '0');\n    const dd = String(date.getDate()).padStart(2, '0');\n    const yyyy = date.getFullYear();\n\n    return `${mm}/${dd}/${yyyy}`;\n}\n\nconst quoteIfNotEmpty = (value: string | undefined | null) => {\n  const str = String(value || '').trim();\n  return str ? `\"${str}\"` : '';\n};\n\nasync function processExcelFile(file: File, sheetName: string): Promise<{ data: any[][], validationErrors: string[] }> {\n    const bytes = await file.arrayBuffer();\n    const workbook = xlsx.read(bytes, { type: 'array' });\n\n    if (!workbook.SheetNames.includes(sheetName)) {\n        return { data: [], validationErrors: [`Sheet \"${sheetName}\" not found in the uploaded file.`] };\n    }\n\n    const worksheet = workbook.Sheets[sheetName];\n    const data: any[][] = xlsx.utils.sheet_to_json(worksheet, {\n        header: 1,\n        defval: '',\n        raw: false,\n    });\n\n    if (data.length <= 1) {\n        return { data: [], validationErrors: [\"The sheet has no data to process.\"] };\n    }\n\n    return { data: data.slice(1), validationErrors: [] };\n}\n\n\nexport async function convertExcelToDat(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File | null;\n    const reportType = formData.get('reportType') as string | null;\n    const month = formData.get('month') as string | null;\n    const year = formData.get('year') as string | null;\n    const profileString = formData.get('profile') as string | null;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        processedData: null,\n    };\n\n    if (!file) return { ...defaultErrorResult, error: 'No file uploaded.' };\n    if (!reportType) return { ...defaultErrorResult, error: 'Report type not specified.' };\n    if (!month) return { ...defaultErrorResult, error: 'Month not specified.' };\n    if (!year) return { ...defaultErrorResult, error: 'Year not specified.' };\n    if (!profileString) return { ...defaultErrorResult, error: 'Profile not provided.' };\n\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    try {\n        if (reportType === \"Summary of Sales (SLS)\") {\n            const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_sales\");\n            if (fileErrors.length > 0) return { ...defaultErrorResult, error: fileErrors[0] };\n\n            const validationErrors: string[] = [];\n            \n            const processedData = dataRows.map((row, index) => {\n                const originalRowNumber = index + 2;\n                const processedRow = [...row];\n\n                if (processedRow.length > 0 && String(processedRow[0]).trim()) {\n                    const originalTin = String(processedRow[0]);\n                    const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n\n                    if (sanitizedTin.substring(0, 9) === tin) {\n                        validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot make a sale to itself.`);\n                    }\n\n                    if (sanitizedTin.length < 9) {\n                        validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n                    }\n                    processedRow[0] = sanitizedTin.substring(0, 9);\n                } else {\n                     validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n                }\n\n                const nameFieldsInfo = [\n                    { name: 'Registered Name', index: 1, maxLength: 150, required: true },\n                    { name: 'Last Name', index: 2, maxLength: 30, required: false },\n                    { name: 'First Name', index: 3, maxLength: 30, required: false },\n                    { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n                    { name: 'Address 1', index: 5, maxLength: 30, required: false },\n                    { name: 'Address 2', index: 6, maxLength: 30, required: false },\n                ];\n                nameFieldsInfo.forEach(field => {\n                    const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n                    if (result.error) validationErrors.push(result.error);\n                    processedRow[field.index] = result.value;\n                });\n                \n                const hasFirstName = String(processedRow[3]).trim().length > 0;\n                const hasLastName = String(processedRow[2]).trim().length > 0;\n                const hasMiddleName = String(processedRow[4]).trim().length > 0;\n                if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n                if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n                const numericFields = [\n                    { name: 'Exempt Sales', index: 7 }, { name: 'Zero-Rated Sales', index: 8 },\n                    { name: 'Taxable Sales', index: 9 }, { name: 'Output Tax', index: 10 },\n                ];\n                numericFields.forEach(field => {\n                    const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n                    if (result.error) validationErrors.push(result.error);\n                    processedRow[field.index] = result.value;\n                });\n                \n                if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0) {\n                    validationErrors.push(`Row ${originalRowNumber}: At least one sales amount (Exempt, Zero-Rated, or Taxable) must be greater than zero.`);\n                }\n\n                return processedRow;\n            });\n\n            if (validationErrors.length > 0) return { ...defaultErrorResult, success: false, error: \"Validation failed.\", errors: validationErrors };\n            \n            const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n            const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n            const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n            const detailRows = processedData.map(row => {\n                const finalRow = [\n                    'D', 'S',\n                    quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]),\n                    quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n                    quoteIfNotEmpty(row[6]),\n                    row[7], row[8], row[9], row[10],\n                    tin, lastDayDate,\n                ];\n                return finalRow.join(',');\n            }).join('\\n');\n            \n            const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n            const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n            const totalTaxableSales = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n            const totalOutputTax = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n            \n            const headerRow = [\n                'H', 'S', quoteIfNotEmpty(tin),\n                quoteIfNotEmpty(profile.companyName), quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName),\n                quoteIfNotEmpty(profile.middleName), quoteIfNotEmpty(profile.tradeName),\n                quoteIfNotEmpty(address1), quoteIfNotEmpty(address2),\n                totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalTaxableSales.toFixed(2), totalOutputTax.toFixed(2),\n                profile.rdoCode, lastDayDate, profile.monthSelect\n            ].join(',');\n            \n            const datContent = `${headerRow}\\n${detailRows}`;\n            const datFileName = `${tin}S${month}${year}.DAT`;\n                \n            return { \n                ...defaultErrorResult, success: true, datContent, fileName: datFileName,\n                totalExempt, totalZeroRated, totalTaxableSales, totalOutputTax\n            };\n        }\n        return { ...defaultErrorResult, error: `Report type \"${reportType}\" is not yet supported.` };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during conversion.';\n        console.error('[convertExcelToDat] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Conversion failed: ${errorMessage}` };\n    }\n}\n\nexport async function validateExcelForPurchases(formData: FormData): Promise<DatFileResult> {\n    const file = formData.get('file') as File;\n    const profileString = formData.get('profile') as string;\n    const profile: TaxProfile = JSON.parse(profileString);\n    const { tpTIN: tin } = profile;\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        processedData: null\n    };\n\n    const { data: dataRows, validationErrors: fileErrors } = await processExcelFile(file, \"vat_purchases\");\n    if (fileErrors.length > 0) return { ...defaultErrorResult, error: fileErrors[0] };\n\n    const validationErrors: string[] = [];\n    const processedData = dataRows.map((row, index) => {\n        const originalRowNumber = index + 2;\n        const processedRow = [...row];\n\n        if (String(processedRow[0] || '').trim()) {\n            const originalTin = String(processedRow[0]);\n            const sanitizedTin = originalTin.replace(/[^0-9]/g, '');\n            if (sanitizedTin.substring(0, 9) === tin) validationErrors.push(`Row ${originalRowNumber}: The TIN matches the selected profile's TIN. A company cannot have a purchase from itself.`);\n            if (sanitizedTin.length < 9) validationErrors.push(`Row ${originalRowNumber}: TIN '${originalTin}' is too short. It must be at least 9 digits.`);\n            processedRow[0] = sanitizedTin.substring(0, 9);\n        } else {\n            validationErrors.push(`Row ${originalRowNumber}: TIN is missing.`);\n        }\n\n        const nameFieldsInfo = [\n            { name: 'Registered Name', index: 1, maxLength: 150, required: true }, { name: 'Last Name', index: 2, maxLength: 30, required: false },\n            { name: 'First Name', index: 3, maxLength: 30, required: false }, { name: 'Middle Name', index: 4, maxLength: 30, required: false },\n            { name: 'Address 1', index: 5, maxLength: 30, required: false }, { name: 'Address 2', index: 6, maxLength: 30, required: false },\n        ];\n        nameFieldsInfo.forEach(field => {\n            const result = sanitizeAndValidateString(processedRow[field.index], field.name, field.maxLength, originalRowNumber, field.required);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        const hasFirstName = String(processedRow[3]).trim().length > 0;\n        const hasLastName = String(processedRow[2]).trim().length > 0;\n        const hasMiddleName = String(processedRow[4]).trim().length > 0;\n        if ((hasFirstName && !hasLastName) || (!hasFirstName && hasLastName)) validationErrors.push(`Row ${originalRowNumber}: First Name and Last Name must be provided together.`);\n        if (hasMiddleName && (!hasFirstName || !hasLastName)) validationErrors.push(`Row ${originalRowNumber}: If Middle Name is provided, First Name and Last Name are also required.`);\n\n        const numericFields = [\n            { name: 'Exempt Purchases', index: 7 }, { name: 'Zero-Rated Purchases', index: 8 },\n            { name: 'Purchases of Services', index: 9 }, { name: 'Purchases of Capital Goods', index: 10 },\n            { name: 'Purchases of Other Goods', index: 11 }, { name: 'Input Tax', index: 12 },\n        ];\n        numericFields.forEach(field => {\n            const result = sanitizeAndValidateNumber(processedRow[field.index], field.name, originalRowNumber);\n            if (result.error) validationErrors.push(result.error);\n            processedRow[field.index] = result.value;\n        });\n\n        if (parseFloat(processedRow[7]) === 0 && parseFloat(processedRow[8]) === 0 && parseFloat(processedRow[9]) === 0 && parseFloat(processedRow[10]) === 0 && parseFloat(processedRow[11]) === 0) {\n            validationErrors.push(`Row ${originalRowNumber}: At least one purchase amount must be greater than zero.`);\n        }\n\n        return processedRow;\n    });\n\n    if (validationErrors.length > 0) {\n        return { ...defaultErrorResult, success: false, errors: validationErrors };\n    }\n\n    const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n\n    return { ...defaultErrorResult, success: true, totalInputTax, processedData };\n}\n\ninterface CreatePurchasesDatFileArgs {\n    processedData: any[][];\n    profile: TaxProfile;\n    month: string;\n    year: string;\n    nonCreditableInputTax: number;\n}\n\nexport async function createPurchasesDatFile({\n    processedData,\n    profile,\n    month,\n    year,\n    nonCreditableInputTax\n}: CreatePurchasesDatFileArgs): Promise<DatFileResult> {\n\n    const defaultErrorResult = {\n        success: false, datContent: null, fileName: null, errors: null,\n        totalExempt: null, totalZeroRated: null, totalTaxableSales: null, totalOutputTax: null,\n        totalServices: null, totalCapitalGoods: null, totalOtherGoods: null, totalInputTax: null,\n        processedData: null\n    };\n    \n    try {\n        const { tpTIN: tin } = profile;\n        const lastDayDate = getFormattedLastDay(parseInt(year), parseInt(month));\n        const address1 = [profile.subStreet, profile.street, profile.barangay].filter(Boolean).join(' ');\n        const address2 = [profile.cityMunicipality, profile.province, profile.zipCode].filter(Boolean).join(' ');\n\n        const detailRows = processedData.map(row => {\n            const finalRow = [\n                'D', 'P',\n                quoteIfNotEmpty(row[0]), quoteIfNotEmpty(row[1]), quoteIfNotEmpty(row[2]),\n                quoteIfNotEmpty(row[3]), quoteIfNotEmpty(row[4]), quoteIfNotEmpty(row[5]),\n                quoteIfNotEmpty(row[6]),\n                row[7], row[8], row[9], row[10], row[11], row[12],\n                tin, lastDayDate,\n            ];\n            return finalRow.join(',');\n        }).join('\\n');\n\n        const totalExempt = processedData.reduce((acc, row) => acc + parseFloat(row[7]), 0);\n        const totalZeroRated = processedData.reduce((acc, row) => acc + parseFloat(row[8]), 0);\n        const totalServices = processedData.reduce((acc, row) => acc + parseFloat(row[9]), 0);\n        const totalCapitalGoods = processedData.reduce((acc, row) => acc + parseFloat(row[10]), 0);\n        const totalOtherGoods = processedData.reduce((acc, row) => acc + parseFloat(row[11]), 0);\n        const totalInputTax = processedData.reduce((acc, row) => acc + parseFloat(row[12]), 0);\n        const creditableInputTax = totalInputTax - nonCreditableInputTax;\n\n        const headerRow = [\n            'H', 'P', quoteIfNotEmpty(tin), quoteIfNotEmpty(profile.companyName),\n            quoteIfNotEmpty(profile.lastName), quoteIfNotEmpty(profile.firstName), quoteIfNotEmpty(profile.middleName),\n            quoteIfNotEmpty(profile.tradeName), quoteIfNotEmpty(address1), quoteIfNotEmpty(address2),\n            totalExempt.toFixed(2), totalZeroRated.toFixed(2), totalServices.toFixed(2), totalCapitalGoods.toFixed(2), totalOtherGoods.toFixed(2), \n            totalInputTax.toFixed(2), creditableInputTax.toFixed(2), nonCreditableInputTax.toFixed(2),\n            profile.rdoCode, lastDayDate, profile.monthSelect\n        ].join(',');\n\n        const datContent = `${headerRow}\\n${detailRows}`;\n        const datFileName = `${tin}P${month}${year}.DAT`;\n\n        return { \n            ...defaultErrorResult,\n            success: true, datContent, fileName: datFileName,\n            totalExempt, totalZeroRated,\n            totalServices, totalCapitalGoods, totalOtherGoods, totalInputTax\n        };\n    } catch (e) {\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred during DAT file creation.';\n        console.error('[createPurchasesDatFile] CRITICAL ERROR:', e);\n        return { ...defaultErrorResult, error: `Creation failed: ${errorMessage}` };\n    }\n}\n\nexport async function testDriveUploadAction(): Promise<SimpleResult> {\n    try {\n        await uploadTestFileToDrive();\n        return { success: true, error: null };\n    } catch (e) {\n        console.error('[testDriveUploadAction] Error:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: errorMessage };\n    }\n}\n"],"names":[],"mappings":";;;;;;IA8jBsB,wBAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/dat-files/page.tsx"],"sourcesContent":["\n'use client';\n\nimport React, { useEffect, useTransition } from 'react';\nimport { useRefresh } from '@/hooks/use-refresh';\nimport { Button } from '@/components/ui/button';\nimport { testDriveUploadAction } from '@/lib/actions';\nimport { useToast } from '@/hooks/use-toast';\nimport { Loader2, Upload } from 'lucide-react';\n\nconst DatFilesContent = () => {\n    const { setRefreshFunction } = useRefresh();\n    const { toast } = useToast();\n    const [isPending, startTransition] = useTransition();\n\n    useEffect(() => {\n        setRefreshFunction(null);\n    }, [setRefreshFunction]);\n\n    const handleTestUpload = () => {\n        startTransition(async () => {\n            const result = await testDriveUploadAction();\n            if (result.success) {\n                toast({\n                    title: 'Upload Successful!',\n                    description: 'The test file was uploaded to Google Drive.',\n                    className: 'bg-accent text-accent-foreground',\n                });\n            } else {\n                toast({\n                    title: 'Upload Failed',\n                    description: result.error,\n                    variant: 'destructive',\n                });\n            }\n        });\n    };\n\n    return (\n        <div className=\"p-4 space-y-4\">\n            <h1 className=\"text-2xl font-bold\">DAT Files & Testing</h1>\n            <p className=\"text-muted-foreground\">This page is for managing generated DAT files and for testing integrations.</p>\n            <div className=\"p-6 border rounded-lg\">\n                <h2 className=\"text-lg font-semibold mb-2\">Google Drive Upload Test</h2>\n                <p className=\"text-sm text-muted-foreground mb-4\">\n                    Click the button below to test uploading a simple \"Hello World!\" text file to the designated Google Drive folder.\n                </p>\n                <Button onClick={handleTestUpload} disabled={isPending}>\n                    {isPending ? (\n                        <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                    ) : (\n                        <Upload className=\"mr-2 h-4 w-4\" />\n                    )}\n                    Test Drive Upload\n                </Button>\n            </div>\n        </div>\n    );\n}\n\nexport default function DatFilesPage() {\n    return <DatFilesContent />;\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AAPA;;;;;;;AASA,MAAM,kBAAkB;;IACpB,MAAM,EAAE,kBAAkB,EAAE,GAAG,CAAA,GAAA,kIAAA,CAAA,aAAU,AAAD;IACxC,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,+HAAA,CAAA,WAAQ,AAAD;IACzB,MAAM,CAAC,WAAW,gBAAgB,GAAG,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD;IAEjD,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD;qCAAE;YACN,mBAAmB;QACvB;oCAAG;QAAC;KAAmB;IAEvB,MAAM,mBAAmB;QACrB,gBAAgB;YACZ,MAAM,SAAS,MAAM,CAAA,GAAA,qJAAA,CAAA,wBAAqB,AAAD;YACzC,IAAI,OAAO,OAAO,EAAE;gBAChB,MAAM;oBACF,OAAO;oBACP,aAAa;oBACb,WAAW;gBACf;YACJ,OAAO;gBACH,MAAM;oBACF,OAAO;oBACP,aAAa,OAAO,KAAK;oBACzB,SAAS;gBACb;YACJ;QACJ;IACJ;IAEA,qBACI,6LAAC;QAAI,WAAU;;0BACX,6LAAC;gBAAG,WAAU;0BAAqB;;;;;;0BACnC,6LAAC;gBAAE,WAAU;0BAAwB;;;;;;0BACrC,6LAAC;gBAAI,WAAU;;kCACX,6LAAC;wBAAG,WAAU;kCAA6B;;;;;;kCAC3C,6LAAC;wBAAE,WAAU;kCAAqC;;;;;;kCAGlD,6LAAC,qIAAA,CAAA,SAAM;wBAAC,SAAS;wBAAkB,UAAU;;4BACxC,0BACG,6LAAC,oNAAA,CAAA,UAAO;gCAAC,WAAU;;;;;qDAEnB,6LAAC,yMAAA,CAAA,SAAM;gCAAC,WAAU;;;;;;4BACpB;;;;;;;;;;;;;;;;;;;AAMtB;GAhDM;;QAC6B,kIAAA,CAAA,aAAU;QACvB,+HAAA,CAAA,WAAQ;QACW,6JAAA,CAAA,gBAAa;;;KAHhD;AAkDS,SAAS;IACpB,qBAAO,6LAAC;;;;;AACZ;MAFwB","debugId":null}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"file":"loader-circle.js","sources":["file:///home/user/studio/node_modules/lucide-react/src/icons/loader-circle.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'M21 12a9 9 0 1 1-6.219-8.56', key: '13zald' }]];\n\n/**\n * @component @name LoaderCircle\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/loader-circle\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LoaderCircle = createLucideIcon('LoaderCircle', __iconNode);\n\nexport default LoaderCircle;\n"],"names":[],"mappings":";;;;;;;;;;;AAGa,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,UAAA,CAAuB,CAAA,CAAA;IAAC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ;QAAA,CAAE;YAAA,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAA+B;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK,CAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAC;KAAC;CAAA,CAAA;AAa5F,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,YAAA,CAAe,CAAA,2KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AAAiB,CAAjB,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAgB,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"file":"upload.js","sources":["file:///home/user/studio/node_modules/lucide-react/src/icons/upload.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4', key: 'ih7n3h' }],\n  ['polyline', { points: '17 8 12 3 7 8', key: 't8dd8p' }],\n  ['line', { x1: '12', x2: '12', y1: '3', y2: '15', key: 'widbto' }],\n];\n\n/**\n * @component @name Upload\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNCIgLz4KICA8cG9seWxpbmUgcG9pbnRzPSIxNyA4IDEyIDMgNyA4IiAvPgogIDxsaW5lIHgxPSIxMiIgeDI9IjEyIiB5MT0iMyIgeTI9IjE1IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/upload\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Upload = createLucideIcon('Upload', __iconNode);\n\nexport default Upload;\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAuB,CAAA,CAAA,CAAA,CAAA;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAA6C,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IAC1E;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAY,CAAA;QAAA,CAAA;YAAE,QAAQ,CAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA,CAAA;IACvD;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAE;YAAA,CAAA,CAAA,EAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAI,CAAM,CAAA,CAAA,CAAA,CAAA;YAAA,EAAA,CAAI,CAAA,CAAA,CAAA,CAAK,CAAA;YAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,CAAM;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CACnE,CAAA;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MAAA,CAAS,CAAA,2KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AAAiB,CAAjB,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAU,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}}]
}