{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/drive-oauth.ts"],"sourcesContent":["\nimport { google } from 'googleapis';\n\nconst {\n  GOOGLE_OAUTH_CLIENT_ID,\n  GOOGLE_OAUTH_CLIENT_SECRET,\n  GOOGLE_OAUTH_REFRESH_TOKEN,\n} = process.env;\n\nif (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n  // This check is important but shouldn't throw an error that crashes the server on startup,\n  // as the credentials might not be used on every page load.\n  // We will let the functions that use it handle the error.\n  console.warn('Google OAuth credentials are not fully configured in .env. Some Drive/Sheets features may not work.');\n}\n\n// This is a fixed value for web applications\nconst GOOGLE_OAUTH_REDIRECT_URI = 'https://developers.google.com/oauthplayground';\n\nlet oauth2Client: import('google-auth-library').OAuth2Client | null = null;\n\nexport async function getOAuth2Client() {\n  // Add the check here to provide a clear error when the credentials are used.\n  if (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n    throw new Error('Google OAuth credentials (CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN) must be configured in your .env file.');\n  }\n  \n  if (oauth2Client) {\n    // Check if the token is about to expire (within 60 seconds) and refresh if needed\n    if (oauth2Client.credentials.expiry_date && oauth2Client.credentials.expiry_date < (Date.now() + 60 * 1000)) {\n        console.log('[OAuth] Access token expiring soon, refreshing...');\n        await oauth2Client.refreshAccessToken();\n        console.log('[OAuth] Access token refreshed.');\n    }\n    return oauth2Client;\n  }\n\n  const client = new google.auth.OAuth2(\n    GOOGLE_OAUTH_CLIENT_ID,\n    GOOGLE_OAUTH_CLIENT_SECRET,\n    GOOGLE_OAUTH_REDIRECT_URI\n  );\n\n  client.setCredentials({\n    refresh_token: GOOGLE_OAUTH_REFRESH_TOKEN,\n  });\n\n  // Do an initial token refresh to get the access token\n  try {\n    console.log('[OAuth] Initializing and refreshing access token...');\n    await client.refreshAccessToken();\n    console.log('[OAuth] Initial token refreshed successfully.');\n  } catch (error) {\n    console.error('[OAuth] Failed to refresh access token:', error);\n    throw new Error('Failed to refresh access token. Check your refresh token and credentials.');\n  }\n\n  oauth2Client = client;\n  return oauth2Client;\n}\n\nexport async function getSheetsClient() {\n    const oauth2Client = await getOAuth2Client();\n    return google.sheets({ version: 'v4', auth: oauth2Client });\n}\n"],"names":[],"mappings":";;;;AACA;;AAEA,MAAM,EACJ,sBAAsB,EACtB,0BAA0B,EAC1B,0BAA0B,EAC3B,GAAG,QAAQ,GAAG;AAEf,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;IACzF,2FAA2F;IAC3F,2DAA2D;IAC3D,0DAA0D;IAC1D,QAAQ,IAAI,CAAC;AACf;AAEA,6CAA6C;AAC7C,MAAM,4BAA4B;AAElC,IAAI,eAAkE;AAE/D,eAAe;IACpB,6EAA6E;IAC7E,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;QACzF,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,cAAc;QAChB,kFAAkF;QAClF,IAAI,aAAa,WAAW,CAAC,WAAW,IAAI,aAAa,WAAW,CAAC,WAAW,GAAI,KAAK,GAAG,KAAK,KAAK,MAAO;YACzG,QAAQ,GAAG,CAAC;YACZ,MAAM,aAAa,kBAAkB;YACrC,QAAQ,GAAG,CAAC;QAChB;QACA,OAAO;IACT;IAEA,MAAM,SAAS,IAAI,mJAAA,CAAA,SAAM,CAAC,IAAI,CAAC,MAAM,CACnC,wBACA,4BACA;IAGF,OAAO,cAAc,CAAC;QACpB,eAAe;IACjB;IAEA,sDAAsD;IACtD,IAAI;QACF,QAAQ,GAAG,CAAC;QACZ,MAAM,OAAO,kBAAkB;QAC/B,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,eAAe;IACf,OAAO;AACT;AAEO,eAAe;IAClB,MAAM,eAAe,MAAM;IAC3B,OAAO,mJAAA,CAAA,SAAM,CAAC,MAAM,CAAC;QAAE,SAAS;QAAM,MAAM;IAAa;AAC7D","debugId":null}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/googlesheets.ts"],"sourcesContent":["\nimport { z } from 'zod';\nimport type { TaxProfile, UserUpdateData, SessionInfo } from './schemas';\nimport { getSheetsClient } from './drive-oauth';\nimport { headers } from 'next/headers';\n\nconst signupSchema = z.object({\n  userName: z.string(),\n  email: z.string().email(),\n  password: z.string(),\n  folderId: z.string(),\n});\n\nconst loginSchema = z.object({\n  userName: z.string(),\n  password: z.string(),\n});\n\nexport type SignupData = z.infer<typeof signupSchema>;\nexport type LoginData = z.infer<typeof loginSchema>;\n\n\nconst {\n  GOOGLE_SHEETS_SHEET_ID,\n} = process.env;\n\nif (!GOOGLE_SHEETS_SHEET_ID) {\n  throw new Error('GOOGLE_SHEETS_SHEET_ID is not configured in .env');\n}\n\nconst SPREADSHEET_ID = GOOGLE_SHEETS_SHEET_ID;\nconst CREDENTIALS_SHEET_NAME = 'credentials';\nconst SESSIONS_SHEET_NAME = 'ActiveSessions';\n\nexport async function appendUserToSheet(userData: SignupData) {\n  const { email, userName, password, folderId } = userData;\n  const timestamp = new Date().toISOString();\n  const sheets = await getSheetsClient();\n\n  const values = [[email, userName, password, '', folderId, 'active', timestamp, '']];\n\n  const request = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${CREDENTIALS_SHEET_NAME}!A1`, \n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function getAllUsers() {\n    try {\n        const sheets = await getSheetsClient();\n        const response = await sheets.spreadsheets.values.get({\n            spreadsheetId: SPREADSHEET_ID,\n            range: CREDENTIALS_SHEET_NAME,\n        });\n\n        const rows = response.data.values;\n        if (!rows || rows.length === 0) {\n            return [];\n        }\n\n        const header = rows[0];\n        const emailIndex = header.indexOf('emailAddress');\n        const userNameIndex = header.indexOf('userName');\n        const pwdIndex = header.indexOf('pwd');\n        const databaseIdIndex = header.indexOf('databaseID');\n        const folderIdIndex = header.indexOf('folderID');\n\n        if (userNameIndex === -1 || pwdIndex === -1 || emailIndex === -1 || databaseIdIndex === -1 || folderIdIndex === -1) {\n            throw new Error('Could not find required columns in the credentials sheet.');\n        }\n\n        return rows.slice(1).map(row => ({\n            emailAddress: row[emailIndex] || '',\n            userName: row[userNameIndex] || '',\n            pwd: row[pwdIndex] || '',\n            databaseId: row[databaseIdIndex] || '',\n            folderId: row[folderIdIndex] || '',\n        }));\n\n    } catch (err) {\n        console.error('The API returned an error: ' + err);\n        throw new Error('Failed to retrieve data from Google Sheet.');\n    }\n}\n\nexport async function updateUserFolderId(userName: string, folderId: string) {\n    const sheets = await getSheetsClient();\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`; \n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const folderIdIndex = header.indexOf('folderID');\n\n    if (userNameIndex === -1 || folderIdIndex === -1) {\n        throw new Error('userName or folderID column not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === userName);\n    if (userRowIndex === -1) {\n        throw new Error(`User ${userName} not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + folderIdIndex);\n\n    await sheets.spreadsheets.values.update({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [[folderId]],\n        },\n    });\n}\n\n\nexport async function getAllHeaderDataFromSheet(databaseId: string): Promise<TaxProfile[]> {\n  try {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.values.get({\n      spreadsheetId: databaseId,\n      range: 'tpList!A:Q',\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    const header = rows[0];\n    const dataRows = rows.slice(1);\n    \n    const objects = dataRows\n        .map(row => {\n            const rowData: { [key: string]: any } = {};\n            header.forEach((key, headerIndex) => {\n                rowData[key] = row[headerIndex] || '';\n            });\n            return rowData as TaxProfile;\n        })\n        .filter(profile => profile.tpTIN && typeof profile.tpTIN === 'string' && profile.tpTIN.trim() !== '');\n\n    return objects;\n\n  } catch (err) {\n    console.error(`The API returned an error for spreadsheet ${databaseId}: ` + err);\n    throw new Error('Failed to retrieve header data from Google Sheet.');\n  }\n}\n\nexport async function appendHeaderDataToSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const headerResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range: 'tpList!A1:Q1',\n  });\n  \n  const headers = headerResponse.data.values?.[0];\n  if (!headers) {\n    throw new Error('Could not retrieve headers from tpList sheet.');\n  }\n\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function updateHeaderDataInSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const range = 'tpList!A:Q';\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    throw new Error('No data found in the sheet.');\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n  \n  const rowIndex = rows.findIndex(row => row[tinIndex] === profileData.tpTIN);\n\n  if (rowIndex === -1) {\n    throw new Error('Profile with the specified TIN not found.');\n  }\n  \n  const rowToUpdate = rowIndex + 1;\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A${rowToUpdate}`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.update(request);\n    console.log('Updated sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to update data in Google Sheet.');\n  }\n}\n\nasync function getSheetId(spreadsheetId: string, sheetName: string): Promise<number | null> {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.get({\n        spreadsheetId,\n    });\n    const sheet = response.data.sheets?.find(s => s.properties?.title === sheetName);\n    return sheet?.properties?.sheetId ?? null;\n}\n\nexport async function deleteHeaderDataRowInSheet(tpTIN: string, databaseId: string) {\n  const sheets = await getSheetsClient();\n  const sheetName = 'tpList';\n  const range = `${sheetName}!A:Q`;\n\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    console.log('No data found in the sheet to delete.');\n    return;\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n\n  const rowIndex = rows.findIndex(row => row[tinIndex] === tpTIN);\n\n  if (rowIndex === -1) {\n    console.log(`Profile with TIN ${tpTIN} not found for deletion.`);\n    return;\n  }\n\n  const sheetId = await getSheetId(databaseId, sheetName);\n  if (sheetId === null) {\n      throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n  }\n\n  const batchUpdateRequest = {\n    spreadsheetId: databaseId,\n    resource: {\n      requests: [\n        {\n          deleteDimension: {\n            range: {\n              sheetId: sheetId,\n              dimension: 'ROWS',\n              startIndex: rowIndex, \n              endIndex: rowIndex + 1\n            }\n          }\n        },\n        {\n          appendDimension: {\n            sheetId: sheetId,\n            dimension: \"ROWS\",\n            length: 1\n          }\n        }\n      ]\n    }\n  };\n\n  try {\n    await sheets.spreadsheets.batchUpdate(batchUpdateRequest);\n    console.log(`Successfully deleted row at index ${rowIndex} and added a new one.`);\n  } catch (err) {\n    console.error('The API returned an error during batch update: ' + err);\n    throw new Error('Failed to delete row from Google Sheet.');\n  }\n}\n\n\nexport async function updateUserDataInSheet(currentUserName: string, updates: UserUpdateData) {\n    const sheets = await getSheetsClient();\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`; \n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const pwdIndex = header.indexOf('pwd');\n\n    if (userNameIndex === -1 || pwdIndex === -1) {\n        throw new Error('Required columns (userName, pwd) not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === currentUserName);\n    if (userRowIndex === -1) {\n        throw new Error(`User '${currentUserName}' not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const userRow = [...rows[userRowIndex]];\n\n    if (updates.newPassword) {\n        if (!updates.currentPassword) {\n            throw new Error(\"Current password is required to change password.\");\n        }\n        if (userRow[pwdIndex] !== updates.currentPassword) {\n            throw new Error(\"Incorrect current password.\");\n        }\n        userRow[pwdIndex] = updates.newPassword;\n    }\n\n    if (updates.newUserName) {\n         const isUserNameTaken = rows.slice(1).some((row, index) => index !== userRowIndex -1 && row[userNameIndex] === updates.newUserName);\n         if (isUserNameTaken) {\n            throw new Error(`Username '${updates.newUserName}' is already taken.`);\n         }\n        userRow[userNameIndex] = updates.newUserName;\n    }\n\n    const updateRequest = {\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!A${rowToUpdate}:H${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [userRow],\n        },\n    };\n\n    await sheets.spreadsheets.values.update(updateRequest);\n    console.log(`Successfully updated user data for '${currentUserName}'. New username: '${updates.newUserName || currentUserName}'`);\n}\n\n// ============== ActiveSessions Sheet Functions ==============\n\nexport async function addSessionToSheet(sessionData: {\n  userName: string;\n  sessionToken: string;\n  ipAddress: string;\n  deviceInfo: string;\n}) {\n  const { userName, sessionToken, ipAddress, deviceInfo } = sessionData;\n  const loginTime = new Date().toISOString();\n  const sheets = await getSheetsClient();\n  const sheetName = SESSIONS_SHEET_NAME;\n\n  // First, find and delete any existing session for the same user on the same device\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${sheetName}!A:E`,\n  });\n\n  const rows = getResponse.data.values;\n  if (rows && rows.length > 1) { // Check if there's more than a header\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const deviceInfoIndex = header.indexOf('deviceInfo');\n\n    const existingSessionRowIndex = rows.findIndex(\n      (row, index) => index > 0 && row[userNameIndex] === userName && row[deviceInfoIndex] === deviceInfo\n    );\n\n    if (existingSessionRowIndex !== -1) {\n      console.log(`[Sessions] Found existing session for ${userName} on device. Removing before adding new one.`);\n      const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);\n      if (sheetId === null) {\n        throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n      }\n\n      await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n          requests: [{\n            deleteDimension: {\n              range: {\n                sheetId,\n                dimension: 'ROWS',\n                startIndex: existingSessionRowIndex,\n                endIndex: existingSessionRowIndex + 1,\n              },\n            },\n          }],\n        },\n      });\n    }\n  }\n\n  // Now, append the new session\n  const values = [[userName, sessionToken, loginTime, ipAddress, deviceInfo]];\n  const appendRequest = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${sheetName}!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    await sheets.spreadsheets.values.append(appendRequest);\n    console.log(`[Sessions] Added new session for user ${userName}`);\n  } catch (err) {\n    console.error('The API returned an error while adding a session: ' + err);\n    throw new Error('Failed to add session to Google Sheet.');\n  }\n}\n\nexport async function getSessionsByUserName(userName: string): Promise<SessionInfo[]> {\n    const sheets = await getSheetsClient();\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: SESSIONS_SHEET_NAME,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return [];\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const tokenIndex = header.indexOf('sessionToken');\n    const timeIndex = header.indexOf('loginTime');\n    const ipIndex = header.indexOf('ipAddress');\n    const deviceIndex = header.indexOf('deviceInfo');\n\n    return rows.slice(1)\n        .filter(row => row[userNameIndex] === userName)\n        .map(row => ({\n            token: row[tokenIndex],\n            loginTime: row[timeIndex],\n            ipAddress: row[ipIndex],\n            deviceInfo: row[deviceIndex],\n        }));\n}\n\nasync function findRowIndexByToken(token: string): Promise<{ sheetId: number, rowIndex: number }> {\n    const sheets = await getSheetsClient();\n    const sheetName = SESSIONS_SHEET_NAME;\n\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${sheetName}!B:B`, // Only need to check the token column\n    });\n\n    const rows = response.data.values;\n    if (!rows) throw new Error('Could not find session.');\n\n    const rowIndex = rows.findIndex(row => row[0] === token);\n    if (rowIndex === -1) throw new Error('Session token not found.');\n\n    const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);\n    if (sheetId === null) throw new Error('Could not find sheet ID for sessions.');\n    \n    return { sheetId, rowIndex };\n}\n\nexport async function findUserByTokenFromSheet(token: string): Promise<{ userName: string } | null> {\n    const sheets = await getSheetsClient();\n    const range = `${SESSIONS_SHEET_NAME}!A:B`; // userName and sessionToken columns\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return null;\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const tokenIndex = header.indexOf('sessionToken');\n\n    const sessionRow = rows.slice(1).find(row => row[tokenIndex] === token);\n\n    if (sessionRow) {\n        return { userName: sessionRow[userNameIndex] };\n    }\n    return null;\n}\n\n\nexport async function deleteSessionByToken(token: string) {\n    const { sheetId, rowIndex } = await findRowIndexByToken(token);\n    \n    const sheets = await getSheetsClient();\n    await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n            requests: [{\n                deleteDimension: {\n                    range: {\n                        sheetId,\n                        dimension: 'ROWS',\n                        startIndex: rowIndex,\n                        endIndex: rowIndex + 1,\n                    },\n                },\n            }],\n        },\n    });\n    console.log(`[Sessions] Deleted session with token ending in ...${token.slice(-4)}`);\n}\n\nexport async function deleteAllOtherSessionsByToken(currentToken: string) {\n    const sheets = await getSheetsClient();\n    const range = `${SESSIONS_SHEET_NAME}!A:E`;\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return;\n\n    const header = rows[0];\n    const tokenIndex = header.indexOf('sessionToken');\n    const userNameIndex = header.indexOf('userName');\n    \n    const currentUserRow = rows.find(row => row[tokenIndex] === currentToken);\n    if (!currentUserRow) return; // Current session not found, do nothing.\n\n    const currentUserName = currentUserRow[userNameIndex];\n\n    const sheetId = await getSheetId(SPREADSHEET_ID, SESSIONS_SHEET_NAME);\n    if (sheetId === null) throw new Error('Could not find sheet ID.');\n\n    const deleteRequests = rows\n        .map((row, index) => ({ row, index }))\n        .filter(({ row }) => row[userNameIndex] === currentUserName && row[tokenIndex] !== currentToken)\n        .map(({ index }) => ({\n            deleteDimension: {\n                range: {\n                    sheetId,\n                    dimension: 'ROWS',\n                    startIndex: index,\n                    endIndex: index + 1,\n                },\n            },\n        }))\n        // We need to process deletions from bottom to top to avoid shifting indices.\n        .reverse(); \n\n    if (deleteRequests.length > 0) {\n        await sheets.spreadsheets.batchUpdate({\n            spreadsheetId: SPREADSHEET_ID,\n            resource: { requests: deleteRequests },\n        });\n        console.log(`[Sessions] Deleted ${deleteRequests.length} other session(s) for user ${currentUserName}`);\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/drive.ts"],"sourcesContent":["\n'use server';\n\nimport { google } from 'googleapis';\nimport type { drive_v3 } from 'googleapis';\nimport { getOAuth2Client } from './drive-oauth';\nimport type { DatFile } from './schemas';\n\n\nasync function getDriveClient(): Promise<drive_v3.Drive> {\n    const oauth2Client = await getOAuth2Client();\n    return google.drive({ version: 'v3', auth: oauth2Client });\n}\n\n/**\n * Creates a root folder for a user.\n * @param name The name of the folder to create.\n * @returns The ID of the created folder.\n */\nexport async function createFolderInDrive(name: string): Promise<string> {\n    const drive = await getDriveClient();\n    const fileMetadata = {\n        name,\n        mimeType: 'application/vnd.google-apps.folder',\n    };\n    try {\n        const file = await drive.files.create({\n            resource: fileMetadata,\n            fields: 'id',\n        });\n        console.log(`[Drive] Created root folder \"${name}\" with ID: ${file.data.id}`);\n        return file.data.id!;\n    } catch (error) {\n        console.error(`[Drive] Error creating root folder \"${name}\":`, error);\n        throw error;\n    }\n}\n\nasync function findFolder(drive: drive_v3.Drive, name: string, parentId: string): Promise<string | null> {\n    const query = `mimeType='application/vnd.google-apps.folder' and name='${name.replace(/'/g, \"\\\\'\")}' and '${parentId}' in parents and trashed=false`;\n    try {\n        const res = await drive.files.list({\n            q: query,\n            fields: 'files(id)',\n            spaces: 'drive',\n            pageSize: 1,\n        });\n        if (res.data.files && res.data.files.length > 0 && res.data.files[0].id) {\n            return res.data.files[0].id;\n        }\n        return null;\n    } catch (error) {\n        console.error(`[Drive] Error finding folder \"${name}\" in parent \"${parentId}\":`, error);\n        return null;\n    }\n}\n\nasync function createFolder(drive: drive_v3.Drive, name: string, parentId: string): Promise<string> {\n    const fileMetadata = {\n        name: name,\n        mimeType: 'application/vnd.google-apps.folder',\n        parents: [parentId],\n    };\n    const folder = await drive.files.create({\n        resource: fileMetadata,\n        fields: 'id',\n    });\n    if (!folder.data.id) throw new Error(`Failed to create folder \"${name}\"`);\n    console.log(`[Drive] Created folder \"${name}\" with ID: ${folder.data.id}.`);\n    return folder.data.id;\n}\n\n\nasync function getOrCreateFolderByPath(drive: drive_v3.Drive, rootFolderId: string, path: string[]): Promise<string> {\n    let currentParentId = rootFolderId;\n    \n    const datFilesFolderName = 'DATFiles';\n    let datFilesFolderId = await findFolder(drive, datFilesFolderName, currentParentId);\n    if (!datFilesFolderId) {\n        datFilesFolderId = await createFolder(drive, datFilesFolderName, currentParentId);\n    }\n    currentParentId = datFilesFolderId;\n\n    for (const folderName of path) {\n        let nextFolderId = await findFolder(drive, folderName, currentParentId);\n        if (!nextFolderId) {\n            nextFolderId = await createFolder(drive, folderName, currentParentId);\n        }\n        currentParentId = nextFolderId;\n    }\n    return currentParentId;\n}\n\nexport async function checkFileExists(fileName: string, rootFolderId: string, path: string[]): Promise<boolean> {\n    try {\n        const drive = await getDriveClient();\n        const finalFolderId = await getOrCreateFolderByPath(drive, rootFolderId, path);\n        const query = `name='${fileName.replace(/'/g, \"\\\\'\")}' and '${finalFolderId}' in parents and trashed=false`;\n        \n        const res = await drive.files.list({\n            q: query,\n            fields: 'files(id)',\n            pageSize: 1,\n        });\n\n        return !!(res.data.files && res.data.files.length > 0);\n    } catch (error) {\n        console.error(`[Drive] Error checking if file '${fileName}' exists:`, error);\n        return false;\n    }\n}\n\n/**\n * Uploads or updates a file in a specific Google Drive folder path.\n * @param fileName The name of the file.\n * @param fileContent The content of the file.\n * @param rootFolderId The ID of the user's root folder in Drive.\n * @param path An array representing the folder path inside \"DATFiles\".\n * @param overwrite If true, will update the existing file. If false, will not upload if file exists.\n * @returns The DatFile object for the created/updated file.\n */\nexport async function uploadFileToDrive(fileName: string, fileContent: string, rootFolderId: string, path: string[], overwrite: boolean = false): Promise<DatFile> {\n  try {\n    const drive = await getDriveClient();\n    const finalFolderId = await getOrCreateFolderByPath(drive, rootFolderId, path);\n    console.log(`[Drive] Final folder for upload is '${finalFolderId}'.`);\n\n    const media = {\n        mimeType: 'text/plain',\n        body: fileContent,\n    };\n    \n    const fileFields = 'id, name, modifiedTime';\n\n    if (overwrite) {\n        const query = `name='${fileName.replace(/'/g, \"\\\\'\")}' and '${finalFolderId}' in parents and trashed=false`;\n        const res = await drive.files.list({ q: query, fields: 'files(id)', pageSize: 1 });\n\n        if (res.data.files && res.data.files.length > 0 && res.data.files[0].id) {\n            const fileId = res.data.files[0].id;\n            console.log(`[Drive] Overwriting existing file '${fileName}' with ID: ${fileId}`);\n            const updatedFile = await drive.files.update({\n                fileId: fileId,\n                media: media,\n                fields: fileFields,\n            });\n            if (!updatedFile.data.id || !updatedFile.data.name || !updatedFile.data.modifiedTime) {\n                throw new Error('File update did not return complete data.');\n            }\n             return { id: updatedFile.data.id, name: updatedFile.data.name, path: path.join(' / '), modifiedTime: updatedFile.data.modifiedTime };\n        }\n    }\n    \n    // If not overwriting or file doesn't exist, create a new one.\n    const fileMetadata = {\n      name: fileName,\n      parents: [finalFolderId],\n    };\n\n    const file = await drive.files.create({\n      requestBody: fileMetadata,\n      media: media,\n      fields: fileFields,\n    });\n\n    if (!file.data.id || !file.data.name || !file.data.modifiedTime) {\n        throw new Error('File creation did not return complete data.');\n    }\n    console.log(`[Drive] Successfully uploaded new file '${fileName}', File ID: ${file.data.id}`);\n    return { id: file.data.id, name: file.data.name, path: path.join(' / '), modifiedTime: file.data.modifiedTime };\n\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';\n    console.error(`[Drive] Failed to upload file '${fileName}':`, errorMessage);\n    throw new Error(`Failed to upload file to Google Drive: ${errorMessage}`);\n  }\n}\n\n/**\n * Lists all .DAT files within a user's DATFiles directory structure and all subfolder IDs.\n * @param rootFolderId The root folder ID for the user.\n * @returns A list of file details and a list of all folder IDs within the DATFiles structure.\n */\nexport async function listDatFiles(rootFolderId: string): Promise<{ files: DatFile[]; folderIds: string[] }> {\n    const drive = await getDriveClient();\n\n    const datFilesFolderId = await findFolder(drive, \"DATFiles\", rootFolderId);\n    if (!datFilesFolderId) {\n        console.log('[Drive] \"DATFiles\" folder not found, returning empty list.');\n        return { files: [], folderIds: [] };\n    }\n\n    const folderMap = new Map<string, { name: string; parentId: string }>();\n    const allFiles: DatFile[] = [];\n    const allFolderIds = new Set<string>([datFilesFolderId]);\n\n    async function walkFolders(folderId: string): Promise<void> {\n        let pageToken: string | undefined = undefined;\n        do {\n            const res = await drive.files.list({\n                q: `'${folderId}' in parents and trashed=false`,\n                fields: \"nextPageToken, files(id, name, mimeType, modifiedTime, parents)\",\n                spaces: \"drive\",\n                pageToken,\n                pageSize: 1000,\n            });\n\n            const folderPromises: Promise<void>[] = [];\n\n            if (res.data.files) {\n                for (const file of res.data.files) {\n                    if (file.mimeType === \"application/vnd.google-apps.folder\") {\n                        if (file.id) {\n                            allFolderIds.add(file.id);\n                            if (file.parents && file.parents.length > 0) {\n                                folderMap.set(file.id, { name: file.name!, parentId: file.parents[0] });\n                            }\n                            folderPromises.push(walkFolders(file.id));\n                        }\n                    } else if (file.name?.endsWith(\".DAT\")) {\n                        let pathParts: string[] = [];\n                        let currentParentId = file.parents?.[0];\n\n                        while (currentParentId && currentParentId !== datFilesFolderId) {\n                            const parentFolder = folderMap.get(currentParentId);\n                            if (parentFolder) {\n                                pathParts.unshift(parentFolder.name);\n                                currentParentId = parentFolder.parentId;\n                            } else {\n                                break;\n                            }\n                        }\n\n                        allFiles.push({\n                            id: file.id!,\n                            name: file.name!,\n                            path: pathParts.join(\" / \"),\n                            modifiedTime: file.modifiedTime!,\n                        });\n                    }\n                }\n            }\n            await Promise.all(folderPromises);\n            pageToken = res.data.nextPageToken;\n        } while (pageToken);\n    }\n\n    folderMap.set(datFilesFolderId, { name: \"DATFiles\", parentId: rootFolderId });\n    await walkFolders(datFilesFolderId);\n\n    return { files: allFiles, folderIds: Array.from(allFolderIds) };\n}\n\n\n\n/**\n * Downloads the content of a file from Google Drive.\n * @param fileId The ID of the file to download.\n * @returns The content of the file as a string.\n */\nexport async function downloadFileFromDrive(fileId: string): Promise<string> {\n    const drive = await getDriveClient();\n    try {\n        const response = await drive.files.get(\n            { fileId: fileId, alt: 'media' },\n            { responseType: 'stream' }\n        );\n\n        return new Promise((resolve, reject) => {\n            let buf: any[] = [];\n            response.data\n                .on('data', (chunk) => buf.push(chunk))\n                .on('end', () => {\n                    const content = Buffer.concat(buf).toString();\n                    resolve(content);\n                })\n                .on('error', (err) => {\n                    console.error(`[Drive] Error downloading file ${fileId}:`, err);\n                    reject(err);\n                });\n        });\n\n    } catch (error: any) {\n        if (error.code === 404) {\n            throw new Error('File not found.');\n        }\n        console.error(`[Drive] API error on download for file ${fileId}:`, error);\n        throw error;\n    }\n}\n\n\n/**\n * Deletes a file from Google Drive permanently.\n * @param fileId The ID of the file to delete.\n */\nexport async function deleteFileFromDrive(fileId: string): Promise<void> {\n    const drive = await getDriveClient();\n    try {\n        await drive.files.delete({\n            fileId: fileId,\n        });\n        console.log(`[Drive] Successfully deleted file with ID: ${fileId}`);\n    } catch (error: any) {\n        if (error.code === 404) {\n            throw new Error('File not found.');\n        }\n        console.error(`[Drive] Error deleting file ${fileId}:`, error);\n        throw error;\n    }\n}\n\n/**\n * Gets the starting page token for the changes feed for the entire user's Drive.\n * @returns The starting page token.\n */\nexport async function getInitialPageTokenForDrive(): Promise<string> {\n    const drive = await getDriveClient();\n    try {\n        const response = await drive.changes.getStartPageToken({\n             supportsAllDrives: true,\n        });\n        if (!response.data.startPageToken) {\n            throw new Error('Failed to get a start page token.');\n        }\n        return response.data.startPageToken;\n    } catch (error) {\n        console.error('[Drive] Error getting initial page token:', error);\n        throw error;\n    }\n}\n\n/**\n * Lists changes for a user's account and checks if they are relevant to the user's folder structure.\n * @param allFolderIds An array of all folder IDs that belong to the user's DAT file structure.\n * @param pageToken The page token from which to retrieve changes.\n * @returns An object with hasChanges boolean and the new page token.\n */\nexport async function listChangesSincePageToken(\n    allFolderIds: string[],\n    pageToken: string\n): Promise<{ hasChanges: boolean; newPageToken: string }> {\n    const drive = await getDriveClient();\n    let newPageToken = pageToken;\n    let hasRelevantChanges = false;\n    let lastResponse: any;\n\n    try {\n        const folderIdSet = new Set(allFolderIds);\n\n        do {\n            lastResponse = await drive.changes.list({\n                pageToken: newPageToken,\n                spaces: \"drive\",\n                fields: \"nextPageToken, newStartPageToken, changes(fileId, removed, file(name, parents, mimeType))\",\n                includeItemsFromAllDrives: true,\n                supportsAllDrives: true,\n            });\n\n            const changes = lastResponse.data.changes || [];\n\n            if (changes.length > 0) {\n                const relevantChange = changes.some((c: any) => {\n                    // A file was deleted. We can't know its parent, so we must refresh.\n                    if (c.removed) return true; \n\n                    if (c.file && c.file.parents) {\n                        // Check if the file's parent is one of our tracked folders.\n                        const parentIsTracked = c.file.parents.some((p: string) => folderIdSet.has(p));\n                        if (parentIsTracked) {\n                            // It's a folder or a .DAT file within our structure\n                            if (c.file.mimeType === 'application/vnd.google-apps.folder' || c.file.name?.toUpperCase().endsWith(\".DAT\")) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                });\n\n                if (relevantChange) {\n                    hasRelevantChanges = true;\n                    break; \n                }\n            }\n\n            if (lastResponse.data.nextPageToken) {\n                newPageToken = lastResponse.data.nextPageToken;\n            } else {\n                break;\n            }\n        } while (lastResponse.data.nextPageToken);\n\n        const finalToken = lastResponse.data.newStartPageToken || newPageToken;\n\n        return { hasChanges: hasRelevantChanges, newPageToken: finalToken };\n    } catch (error) {\n        console.error(\"[Drive] Error listing changes:\", error);\n        return { hasChanges: false, newPageToken: pageToken };\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1179, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions/auth.ts"],"sourcesContent":["\n'use server';\n\nimport { \n    appendUserToSheet, \n    getAllUsers, \n    type SignupData, \n    type LoginData, \n    updateUserFolderId, \n    getAllHeaderDataFromSheet,\n    addSessionToSheet,\n    deleteSessionByToken,\n} from '../googlesheets';\nimport { createFolderInDrive } from '../drive';\nimport { z } from 'zod';\nimport { headers, cookies } from 'next/headers';\nimport { randomUUID } from 'crypto';\n\n\nconst AuthResultSchema = z.object({\n    success: z.boolean(),\n    error: z.string().nullable(),\n    user: z.object({\n        userName: z.string(),\n        email: z.string().optional(),\n        databaseId: z.string().optional(),\n        folderId: z.string().optional(),\n    }).nullable(),\n});\n\ntype AuthResult = z.infer<typeof AuthResultSchema>;\n\nexport async function signUpUser(userData: SignupData): Promise<Pick<AuthResult, 'success' | 'error'>> {\n  try {\n    const users = await getAllUsers();\n    \n    const userNameExists = users.some(user => user.userName.toLowerCase() === userData.userName.toLowerCase());\n    if (userNameExists) {\n        return { success: false, error: 'This username is already taken. Please choose another one.' };\n    }\n\n    const emailExists = users.some(user => user.emailAddress.toLowerCase() === userData.email.toLowerCase());\n    if (emailExists) {\n        return { success: false, error: 'An account with this email address already exists.' };\n    }\n\n    // For this step, we just return success if the user is unique.\n    // The rest of the signup logic (email verification, etc.) will be added next.\n    return { success: true, error: null };\n\n  } catch (e) {\n    console.error('Error during sign up validation:', e);\n    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n    return { success: false, error: `Sign up failed: ${errorMessage}` };\n  }\n}\n\nexport async function loginUser(credentials: LoginData): Promise<AuthResult> {\n    try {\n        const users = await getAllUsers();\n        const user = users.find(u => u.userName === credentials.userName && u.pwd === credentials.password);\n\n        if (user) {\n            let folderId = user.folderId;\n            if (!folderId) {\n                console.log(`User ${user.userName} does not have a folderId. Creating one now.`);\n                folderId = await createFolderInDrive(`DATGenie_${user.userName}`);\n                await updateUserFolderId(user.userName, folderId);\n                console.log(`Successfully created and assigned folderId ${folderId} to user ${user.userName}.`);\n            }\n            const sheetId = process.env.GOOGLE_SHEETS_SHEET_ID;\n            if (!sheetId) {\n                 return { success: false, error: 'Google Sheet ID is not configured in the environment.', user: null };\n            }\n\n            if (user.databaseId) {\n                 try {\n                    await getAllHeaderDataFromSheet(user.databaseId);\n                } catch(sheetError) {\n                    console.error(`Failed to access sheet with ID ${user.databaseId}`, sheetError);\n                    return { success: false, error: 'Failed to retrieve data from Google Sheet. Check Sheet ID and permissions.', user: null };\n                }\n            }\n            \n            const sessionToken = randomUUID();\n            const headersList = headers();\n            const ipAddress = headersList.get('x-forwarded-for') || 'Unknown';\n            const deviceInfo = headersList.get('user-agent') || 'Unknown';\n\n            await addSessionToSheet({\n                userName: user.userName,\n                sessionToken,\n                ipAddress,\n                deviceInfo,\n            });\n            \n            cookies().set('sessionToken', sessionToken, {\n                httpOnly: true,\n                secure: process.env.NODE_ENV === 'production',\n                maxAge: 60 * 60 * 24 * 7, // One week\n                path: '/',\n            });\n\n            return { \n                success: true, \n                error: null, \n                user: { \n                    userName: user.userName, \n                    email: user.emailAddress, \n                    databaseId: user.databaseId, \n                    folderId: folderId,\n                } \n            };\n        } else {\n            return { success: false, error: 'Invalid username or password.', user: null };\n        }\n    } catch (e) {\n        console.error('Error logging in user:', e);\n        const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';\n        return { success: false, error: `Failed to login: ${errorMessage}`, user: null };\n    }\n}\n\nconst LogoutResultSchema = z.object({ success: z.boolean() });\ntype LogoutResult = z.infer<typeof LogoutResultSchema>;\n\nexport async function logoutUser(): Promise<LogoutResult> {\n    const sessionToken = cookies().get('sessionToken')?.value;\n    if (sessionToken) {\n        await deleteSessionByToken(sessionToken);\n        cookies().delete('sessionToken');\n    }\n    return { success: true };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1344, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/signup/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {signUpUser as '40c6312d939e0f94e11390cab80586edc945c86980'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 1396, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/signup/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/signup/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/signup/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA2R,GACxT,yDACA","debugId":null}},
    {"offset": {"line": 1410, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/signup/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/signup/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/signup/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAuQ,GACpS,qCACA","debugId":null}},
    {"offset": {"line": 1424, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}