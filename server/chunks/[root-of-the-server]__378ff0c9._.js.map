{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/drive-oauth.ts"],"sourcesContent":["\nimport { google } from 'googleapis';\n\nconst {\n  GOOGLE_OAUTH_CLIENT_ID,\n  GOOGLE_OAUTH_CLIENT_SECRET,\n  GOOGLE_OAUTH_REFRESH_TOKEN,\n} = process.env;\n\nif (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n  // This check is important but shouldn't throw an error that crashes the server on startup,\n  // as the credentials might not be used on every page load.\n  // We will let the functions that use it handle the error.\n  console.warn('Google OAuth credentials are not fully configured in .env. Some Drive/Sheets features may not work.');\n}\n\n// This is a fixed value for web applications\nconst GOOGLE_OAUTH_REDIRECT_URI = 'https://developers.google.com/oauthplayground';\n\nlet oauth2Client: import('google-auth-library').OAuth2Client | null = null;\n\nexport async function getOAuth2Client() {\n  // Add the check here to provide a clear error when the credentials are used.\n  if (!GOOGLE_OAUTH_CLIENT_ID || !GOOGLE_OAUTH_CLIENT_SECRET || !GOOGLE_OAUTH_REFRESH_TOKEN) {\n    throw new Error('Google OAuth credentials (CLIENT_ID, CLIENT_SECRET, REFRESH_TOKEN) must be configured in your .env file.');\n  }\n  \n  if (oauth2Client) {\n    // Check if the token is about to expire (within 60 seconds) and refresh if needed\n    if (oauth2Client.credentials.expiry_date && oauth2Client.credentials.expiry_date < (Date.now() + 60 * 1000)) {\n        console.log('[OAuth] Access token expiring soon, refreshing...');\n        await oauth2Client.refreshAccessToken();\n        console.log('[OAuth] Access token refreshed.');\n    }\n    return oauth2Client;\n  }\n\n  const client = new google.auth.OAuth2(\n    GOOGLE_OAUTH_CLIENT_ID,\n    GOOGLE_OAUTH_CLIENT_SECRET,\n    GOOGLE_OAUTH_REDIRECT_URI\n  );\n\n  client.setCredentials({\n    refresh_token: GOOGLE_OAUTH_REFRESH_TOKEN,\n  });\n\n  // Do an initial token refresh to get the access token\n  try {\n    console.log('[OAuth] Initializing and refreshing access token...');\n    await client.refreshAccessToken();\n    console.log('[OAuth] Initial token refreshed successfully.');\n  } catch (error) {\n    console.error('[OAuth] Failed to refresh access token:', error);\n    throw new Error('Failed to refresh access token. Check your refresh token and credentials.');\n  }\n\n  oauth2Client = client;\n  return oauth2Client;\n}\n\nexport async function getSheetsClient() {\n    const oauth2Client = await getOAuth2Client();\n    return google.sheets({ version: 'v4', auth: oauth2Client });\n}\n"],"names":[],"mappings":";;;;AACA;;AAEA,MAAM,EACJ,sBAAsB,EACtB,0BAA0B,EAC1B,0BAA0B,EAC3B,GAAG,QAAQ,GAAG;AAEf,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;IACzF,2FAA2F;IAC3F,2DAA2D;IAC3D,0DAA0D;IAC1D,QAAQ,IAAI,CAAC;AACf;AAEA,6CAA6C;AAC7C,MAAM,4BAA4B;AAElC,IAAI,eAAkE;AAE/D,eAAe;IACpB,6EAA6E;IAC7E,IAAI,CAAC,0BAA0B,CAAC,8BAA8B,CAAC,4BAA4B;QACzF,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,cAAc;QAChB,kFAAkF;QAClF,IAAI,aAAa,WAAW,CAAC,WAAW,IAAI,aAAa,WAAW,CAAC,WAAW,GAAI,KAAK,GAAG,KAAK,KAAK,MAAO;YACzG,QAAQ,GAAG,CAAC;YACZ,MAAM,aAAa,kBAAkB;YACrC,QAAQ,GAAG,CAAC;QAChB;QACA,OAAO;IACT;IAEA,MAAM,SAAS,IAAI,qJAAA,CAAA,SAAM,CAAC,IAAI,CAAC,MAAM,CACnC,wBACA,4BACA;IAGF,OAAO,cAAc,CAAC;QACpB,eAAe;IACjB;IAEA,sDAAsD;IACtD,IAAI;QACF,QAAQ,GAAG,CAAC;QACZ,MAAM,OAAO,kBAAkB;QAC/B,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,MAAM,IAAI,MAAM;IAClB;IAEA,eAAe;IACf,OAAO;AACT;AAEO,eAAe;IAClB,MAAM,eAAe,MAAM;IAC3B,OAAO,qJAAA,CAAA,SAAM,CAAC,MAAM,CAAC;QAAE,SAAS;QAAM,MAAM;IAAa;AAC7D","debugId":null}},
    {"offset": {"line": 311, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/googlesheets.ts"],"sourcesContent":["\nimport { z } from 'zod';\nimport type { TaxProfile, UserUpdateData, SessionInfo } from './schemas';\nimport { getOAuth2Client } from './drive-oauth';\nimport { google } from 'googleapis';\n\nconst signupSchema = z.object({\n  userName: z.string(),\n  email: z.string().email(),\n  password: z.string(),\n});\n\nconst loginSchema = z.object({\n  userName: z.string(),\n  password: z.string(),\n});\n\nexport type SignupData = z.infer<typeof signupSchema>;\nexport type LoginData = z.infer<typeof loginSchema>;\n\n\nconst {\n  GOOGLE_SHEETS_SHEET_ID,\n  GOOGLE_SHEETS_DB_TEMPLATE_ID,\n  GOOGLE_DRIVE_ACCOUNTS_FOLDER_ID\n} = process.env;\n\nif (!GOOGLE_SHEETS_SHEET_ID) {\n  throw new Error('GOOGLE_SHEETS_SHEET_ID is not configured in .env');\n}\nif (!GOOGLE_SHEETS_DB_TEMPLATE_ID) {\n    throw new Error('GOOGLE_SHEETS_DB_TEMPLATE_ID is not configured in .env')\n}\nif (!GOOGLE_DRIVE_ACCOUNTS_FOLDER_ID) {\n  throw new Error('GOOGLE_DRIVE_ACCOUNTS_FOLDER_ID is not configured in .env');\n}\n\nconst SPREADSHEET_ID = GOOGLE_SHEETS_SHEET_ID;\nconst TEMPLATE_SPREADSHEET_ID = GOOGLE_SHEETS_DB_TEMPLATE_ID;\nconst CREDENTIALS_SHEET_NAME = 'credentials';\nconst PENDING_VERIFICATIONS_SHEET_NAME = 'PendingVerifications';\nconst SESSIONS_SHEET_NAME = 'ActiveSessions';\n\nexport async function createDatabaseSheet(userEmail: string, parentFolderId: string): Promise<string> {\n    const oauth2Client = await getOAuth2Client();\n    const drive = google.drive({ version: 'v3', auth: oauth2Client });\n    const newSheetName = `Database - ${userEmail}`;\n    \n    try {\n        const copiedFile = await drive.files.copy({\n            fileId: TEMPLATE_SPREADSHEET_ID,\n            requestBody: {\n                name: newSheetName,\n                parents: [parentFolderId]\n            }\n        });\n\n        const newSpreadsheetId = copiedFile.data.id;\n        if (!newSpreadsheetId) {\n            throw new Error('Failed to get ID of the new spreadsheet.');\n        }\n\n        console.log(`[Sheets] Cloned template sheet for \"${newSheetName}\" with ID: ${newSpreadsheetId}`);\n        return newSpreadsheetId;\n\n    } catch(err) {\n        console.error('The API returned an error: ' + err);\n        throw new Error('Failed to create database sheet.');\n    }\n}\n\n\nexport async function getAllUsers() {\n    try {\n        const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n        const response = await sheets.spreadsheets.values.get({\n            spreadsheetId: SPREADSHEET_ID,\n            range: CREDENTIALS_SHEET_NAME,\n        });\n\n        const rows = response.data.values;\n        if (!rows || rows.length < 2) {\n            return [];\n        }\n\n        const header = rows[0];\n        const emailIndex = header.indexOf('emailAddress');\n        const userNameIndex = header.indexOf('userName');\n        const pwdIndex = header.indexOf('pwd');\n        const databaseIdIndex = header.indexOf('databaseID');\n        const folderIdIndex = header.indexOf('folderID');\n\n        if (userNameIndex === -1 || pwdIndex === -1 || emailIndex === -1 || databaseIdIndex === -1 || folderIdIndex === -1) {\n            console.error('One or more required columns are missing from the credentials sheet:', header);\n            throw new Error('Could not find required columns in the credentials sheet. Please check sheet headers.');\n        }\n        \n        return rows.slice(1).map(row => ({\n            emailAddress: row[emailIndex] || '',\n            userName: row[userNameIndex] || '',\n            pwd: row[pwdIndex] || '',\n            databaseId: row[databaseIdIndex] || '',\n            folderId: row[folderIdIndex] || '',\n        })).filter(u => u.userName); // Filter out empty rows\n\n    } catch (err) {\n        console.error('The API returned an error when getting all users: ' + err);\n        throw new Error('Failed to retrieve data from Google Sheet.');\n    }\n}\n\nexport async function updateUserFolderId(userName: string, folderId: string) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`; \n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const folderIdIndex = header.indexOf('folderID');\n\n    if (userNameIndex === -1 || folderIdIndex === -1) {\n        throw new Error('userName or folderID column not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === userName);\n    if (userRowIndex === -1) {\n        throw new Error(`User ${userName} not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + folderIdIndex);\n\n    await sheets.spreadsheets.values.update({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [[folderId]],\n        },\n    });\n}\n\nexport async function updateUserDatabaseId(userName: string, databaseId: string) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`;\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const databaseIdIndex = header.indexOf('databaseID');\n\n    if (userNameIndex === -1 || databaseIdIndex === -1) {\n        throw new Error('userName or databaseID column not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === userName);\n    if (userRowIndex === -1) {\n        throw new Error(`User ${userName} not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + databaseIdIndex);\n\n    await sheets.spreadsheets.values.update({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [[databaseId]],\n        },\n    });\n}\n\n\nexport async function getAllHeaderDataFromSheet(databaseId: string): Promise<TaxProfile[]> {\n  try {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const response = await sheets.spreadsheets.values.get({\n      spreadsheetId: databaseId,\n      range: 'tpList!A:Q',\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n      return [];\n    }\n\n    const header = rows[0];\n    const dataRows = rows.slice(1);\n    \n    const objects = dataRows\n        .map(row => {\n            const rowData: { [key: string]: any } = {};\n            header.forEach((key, headerIndex) => {\n                rowData[key] = row[headerIndex] || '';\n            });\n            return rowData as TaxProfile;\n        })\n        .filter(profile => profile.tpTIN && typeof profile.tpTIN === 'string' && profile.tpTIN.trim() !== '');\n\n    return objects;\n\n  } catch (err) {\n    console.error(`The API returned an error for spreadsheet ${databaseId}: ` + err);\n    throw new Error('Failed to retrieve header data from Google Sheet.');\n  }\n}\n\nexport async function appendHeaderDataToSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n  const headerResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range: 'tpList!A1:Q1',\n  });\n  \n  const headers = headerResponse.data.values?.[0];\n  if (!headers) {\n    throw new Error('Could not retrieve headers from tpList sheet.');\n  }\n\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.append(request);\n    console.log('Appended to sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to append data to Google Sheet.');\n  }\n}\n\nexport async function updateHeaderDataInSheet(profileData: TaxProfile, databaseId: string) {\n  const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n  const range = 'tpList!A:Q';\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    throw new Error('No data found in the sheet.');\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n  \n  const rowIndex = rows.findIndex(row => row[tinIndex] === profileData.tpTIN);\n\n  if (rowIndex === -1) {\n    throw new Error('Profile with the specified TIN not found.');\n  }\n  \n  const rowToUpdate = rowIndex + 1;\n  const values = [headers.map(header => profileData[header as keyof TaxProfile] || '')];\n\n  const request = {\n    spreadsheetId: databaseId,\n    range: `tpList!A${rowToUpdate}`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    const response = await sheets.spreadsheets.values.update(request);\n    console.log('Updated sheet:', response.data);\n    return response.data;\n  } catch (err) {\n    console.error('The API returned an error: ' + err);\n    throw new Error('Failed to update data in Google Sheet.');\n  }\n}\n\nasync function getSheetId(spreadsheetId: string, sheetName: string): Promise<number | null> {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const response = await sheets.spreadsheets.get({\n        spreadsheetId,\n    });\n    const sheet = response.data.sheets?.find(s => s.properties?.title === sheetName);\n    return sheet?.properties?.sheetId ?? null;\n}\n\nexport async function deleteHeaderDataRowInSheet(tpTIN: string, databaseId: string) {\n  const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n  const sheetName = 'tpList';\n  const range = `${sheetName}!A:Q`;\n\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: databaseId,\n    range,\n  });\n\n  const rows = getResponse.data.values;\n  if (!rows || rows.length === 0) {\n    console.log('No data found in the sheet to delete.');\n    return;\n  }\n\n  const headers = rows[0];\n  const tinIndex = headers.indexOf('tpTIN');\n  if (tinIndex === -1) {\n    throw new Error('TIN column not found in the sheet.');\n  }\n\n  const rowIndex = rows.findIndex(row => row[tinIndex] === tpTIN);\n\n  if (rowIndex === -1) {\n    console.log(`Profile with TIN ${tpTIN} not found for deletion.`);\n    return;\n  }\n\n  const sheetId = await getSheetId(databaseId, sheetName);\n  if (sheetId === null) {\n      throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n  }\n\n  const batchUpdateRequest = {\n    spreadsheetId: databaseId,\n    resource: {\n      requests: [\n        {\n          deleteDimension: {\n            range: {\n              sheetId: sheetId,\n              dimension: 'ROWS',\n              startIndex: rowIndex, \n              endIndex: rowIndex + 1\n            }\n          }\n        },\n        {\n          appendDimension: {\n            sheetId: sheetId,\n            dimension: \"ROWS\",\n            length: 1\n          }\n        }\n      ]\n    }\n  };\n\n  try {\n    await sheets.spreadsheets.batchUpdate(batchUpdateRequest);\n    console.log(`Successfully deleted row at index ${rowIndex} and added a new one.`);\n  } catch (err) {\n    console.error('The API returned an error during batch update: ' + err);\n    throw new Error('Failed to delete row from Google Sheet.');\n  }\n}\n\n\nexport async function updateUserDataInSheet(currentUserName: string, updates: UserUpdateData) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${CREDENTIALS_SHEET_NAME}!A:H`; \n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length === 0) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const userNameIndex = header.indexOf('userName');\n    const pwdIndex = header.indexOf('pwd');\n\n    if (userNameIndex === -1 || pwdIndex === -1) {\n        throw new Error('Required columns (userName, pwd) not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[userNameIndex] === currentUserName);\n    if (userRowIndex === -1) {\n        throw new Error(`User '${currentUserName}' not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const userRow = [...rows[userRowIndex]];\n\n    if (updates.newPassword) {\n        if (!updates.currentPassword) {\n            throw new Error(\"Current password is required to change password.\");\n        }\n        if (userRow[pwdIndex] !== updates.currentPassword) {\n            throw new Error(\"Incorrect current password.\");\n        }\n        userRow[pwdIndex] = updates.newPassword;\n    }\n\n    if (updates.newUserName) {\n         const isUserNameTaken = rows.slice(1).some((row, index) => index !== userRowIndex -1 && row[userNameIndex] === updates.newUserName);\n         if (isUserNameTaken) {\n            throw new Error(`Username '${updates.newUserName}' is already taken.`);\n         }\n        userRow[userNameIndex] = updates.newUserName;\n    }\n\n    const updateRequest = {\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!A${rowToUpdate}:H${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [userRow],\n        },\n    };\n\n    await sheets.spreadsheets.values.update(updateRequest);\n    console.log(`Successfully updated user data for '${currentUserName}'. New username: '${updates.newUserName || currentUserName}'`);\n}\n\nexport async function updateUserPasswordByEmail(email: string, newPassword: string): Promise<void> {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${CREDENTIALS_SHEET_NAME}!A:E`;\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) {\n        throw new Error('No users found in credentials sheet.');\n    }\n\n    const header = rows[0];\n    const emailIndex = header.indexOf('emailAddress');\n    const pwdIndex = header.indexOf('pwd');\n\n    if (emailIndex === -1 || pwdIndex === -1) {\n        throw new Error('Required columns (emailAddress, pwd) not found.');\n    }\n\n    const userRowIndex = rows.findIndex(row => row[emailIndex] === email);\n    if (userRowIndex === -1) {\n        throw new Error(`User with email ${email} not found.`);\n    }\n\n    const rowToUpdate = userRowIndex + 1;\n    const columnToUpdate = String.fromCharCode('A'.charCodeAt(0) + pwdIndex);\n\n    await sheets.spreadsheets.values.update({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${CREDENTIALS_SHEET_NAME}!${columnToUpdate}${rowToUpdate}`,\n        valueInputOption: 'RAW',\n        resource: {\n            values: [[newPassword]],\n        },\n    });\n\n    console.log(`Successfully updated password for user ${email}.`);\n}\n\n\n// Verification Flow Functions\n\ninterface PendingUser {\n    email: string;\n    userName?: string;\n    password?: string;\n    token: string;\n    type: string;\n    expires: string;\n}\n\n\nexport async function addPendingUser(user: PendingUser) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const sheetName = PENDING_VERIFICATIONS_SHEET_NAME;\n\n    const getResponse = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${sheetName}!A:A`, \n    });\n\n    const rows = getResponse.data.values || [];\n    const existingRowIndex = rows.findIndex(row => row[0] === user.email);\n\n    const values = [[user.email, user.userName || '', user.password || '', user.token, user.type, user.expires]];\n\n    if (existingRowIndex !== -1) {\n        const rowToUpdate = existingRowIndex + 1;\n        console.log(`[Sheets] Found existing pending verification for ${user.email} at row ${rowToUpdate}. Updating.`);\n        \n        await sheets.spreadsheets.values.update({\n            spreadsheetId: SPREADSHEET_ID,\n            range: `${sheetName}!A${rowToUpdate}:F${rowToUpdate}`,\n            valueInputOption: 'USER_ENTERED',\n            resource: { values },\n        });\n    } else {\n        console.log(`[Sheets] No existing pending verification for ${user.email}. Appending new row.`);\n        await sheets.spreadsheets.values.append({\n            spreadsheetId: SPREADSHEET_ID,\n            range: `${sheetName}!A1`,\n            valueInputOption: 'USER_ENTERED',\n            resource: { values },\n        });\n    }\n}\n\nexport async function getPendingUserByToken(token: string): Promise<{ user: PendingUser; rowIndex: number } | null> {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: PENDING_VERIFICATIONS_SHEET_NAME,\n    });\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return null;\n\n    const header = rows[0];\n    const tokenIndex = header.indexOf('token');\n    \n    const rowIndex = rows.findIndex((row, index) => index > 0 && row[tokenIndex] === token);\n\n    if (rowIndex === -1) return null;\n    \n    const userRow = rows[rowIndex];\n\n    const user: PendingUser = {\n        email: userRow[header.indexOf('emailAddress')],\n        userName: userRow[header.indexOf('userName')],\n        password: userRow[header.indexOf('password')],\n        token: userRow[tokenIndex],\n        type: userRow[header.indexOf('type')],\n        expires: userRow[header.indexOf('expiration')],\n    };\n\n    return { user, rowIndex };\n}\n\n\nexport async function deletePendingUserByRow(rowIndex: number) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const sheetId = await getSheetId(SPREADSHEET_ID, PENDING_VERIFICATIONS_SHEET_NAME);\n    if (sheetId === null) throw new Error('Sheet not found');\n\n    await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n            requests: [{\n                deleteDimension: {\n                    range: { sheetId, dimension: 'ROWS', startIndex: rowIndex, endIndex: rowIndex + 1 },\n                },\n            }],\n        },\n    });\n}\n\n\nexport async function addUser(userData: SignupData & { folderId: string, databaseId: string, password?: string }) {\n  const { email, userName, password, folderId, databaseId } = userData;\n  const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n  \n  const headerResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${CREDENTIALS_SHEET_NAME}!A1:E1`,\n  });\n\n  const headers = headerResponse.data.values?.[0];\n  if (!headers) {\n    throw new Error('Could not retrieve headers from credentials sheet.');\n  }\n\n  const userObject: {[key: string]: string} = {\n    emailAddress: email,\n    userName: userName,\n    pwd: password || '',\n    databaseID: databaseId,\n    folderID: folderId\n  }\n\n  const values = [headers.map(header => userObject[header] || '')];\n\n  const request = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${CREDENTIALS_SHEET_NAME}!A1`, \n    valueInputOption: 'USER_ENTERED',\n    resource: { values },\n  };\n  await sheets.spreadsheets.values.append(request);\n}\n\n\n// ============== ActiveSessions Sheet Functions ==============\n\nexport async function addSessionToSheet(sessionData: {\n  emailAddress: string;\n  sessionToken: string;\n  ipAddress: string;\n  deviceInfo: string;\n}) {\n  const { emailAddress, sessionToken, ipAddress, deviceInfo } = sessionData;\n  const loginTime = new Date().toISOString();\n  const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n  const sheetName = SESSIONS_SHEET_NAME;\n\n  const getResponse = await sheets.spreadsheets.values.get({\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${sheetName}!A:E`,\n  });\n\n  const rows = getResponse.data.values;\n  if (rows && rows.length > 1) { \n    const header = rows[0];\n    const emailIndex = header.indexOf('emailAddress');\n    const deviceInfoIndex = header.indexOf('deviceInfo');\n\n    const existingSessionRowIndex = rows.findIndex(\n      (row, index) => index > 0 && row[emailIndex] === emailAddress && row[deviceInfoIndex] === deviceInfo\n    );\n\n    if (existingSessionRowIndex !== -1) {\n      console.log(`[Sessions] Found existing session for ${emailAddress} on device. Removing before adding new one.`);\n      const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);\n      if (sheetId === null) {\n        throw new Error(`Sheet with name \"${sheetName}\" not found.`);\n      }\n\n      await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n          requests: [{\n            deleteDimension: {\n              range: {\n                sheetId,\n                dimension: 'ROWS',\n                startIndex: existingSessionRowIndex,\n                endIndex: existingSessionRowIndex + 1,\n              },\n            },\n          }],\n        },\n      });\n    }\n  }\n\n  const values = [[emailAddress, sessionToken, loginTime, ipAddress, deviceInfo]];\n  const appendRequest = {\n    spreadsheetId: SPREADSHEET_ID,\n    range: `${sheetName}!A1`,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values,\n    },\n  };\n\n  try {\n    await sheets.spreadsheets.values.append(appendRequest);\n    console.log(`[Sessions] Added new session for user ${emailAddress}`);\n  } catch (err) {\n    console.error('The API returned an error while adding a session: ' + err);\n    throw new Error('Failed to add session to Google Sheet.');\n  }\n}\n\nexport async function getSessionsByEmail(email: string): Promise<SessionInfo[]> {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: SESSIONS_SHEET_NAME,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return [];\n\n    const header = rows[0];\n    const emailIndex = header.indexOf('emailAddress');\n    const tokenIndex = header.indexOf('sessionToken');\n    const timeIndex = header.indexOf('loginTime');\n    const ipIndex = header.indexOf('ipAddress');\n    const deviceIndex = header.indexOf('deviceInfo');\n\n    return rows.slice(1)\n        .filter(row => row[emailIndex] === email)\n        .map(row => ({\n            token: row[tokenIndex],\n            loginTime: row[timeIndex],\n            ipAddress: row[ipIndex],\n            deviceInfo: row[deviceIndex],\n        }));\n}\n\nasync function findRowIndexByToken(token: string): Promise<{ sheetId: number, rowIndex: number }> {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const sheetName = SESSIONS_SHEET_NAME;\n\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range: `${sheetName}!B:B`, // Only need to check the token column\n    });\n\n    const rows = response.data.values;\n    if (!rows) throw new Error('Could not find session.');\n\n    const rowIndex = rows.findIndex(row => row[0] === token);\n    if (rowIndex === -1) throw new Error('Session token not found.');\n\n    const sheetId = await getSheetId(SPREADSHEET_ID, sheetName);\n    if (sheetId === null) throw new Error('Could not find sheet ID for sessions.');\n    \n    return { sheetId, rowIndex };\n}\n\nexport async function findUserByTokenFromSheet(token: string): Promise<{ email: string } | null> {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${SESSIONS_SHEET_NAME}!A:B`; // emailAddress and sessionToken columns\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return null;\n\n    const header = rows[0];\n    const emailIndex = header.indexOf('emailAddress');\n    const tokenIndex = header.indexOf('sessionToken');\n\n    const sessionRow = rows.slice(1).find(row => row[tokenIndex] === token);\n\n    if (sessionRow) {\n        return { email: sessionRow[emailIndex] };\n    }\n    return null;\n}\n\n\nexport async function deleteSessionByToken(token: string) {\n    const { sheetId, rowIndex } = await findRowIndexByToken(token);\n    \n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    await sheets.spreadsheets.batchUpdate({\n        spreadsheetId: SPREADSHEET_ID,\n        resource: {\n            requests: [{\n                deleteDimension: {\n                    range: {\n                        sheetId,\n                        dimension: 'ROWS',\n                        startIndex: rowIndex,\n                        endIndex: rowIndex + 1,\n                    },\n                },\n            }],\n        },\n    });\n    console.log(`[Sessions] Deleted session with token ending in ...${token.slice(-4)}`);\n}\n\nexport async function deleteAllOtherSessionsByToken(currentToken: string) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${SESSIONS_SHEET_NAME}!A:E`;\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return;\n\n    const header = rows[0];\n    const tokenIndex = header.indexOf('sessionToken');\n    const emailIndex = header.indexOf('emailAddress');\n    \n    const currentUserRow = rows.find(row => row[tokenIndex] === currentToken);\n    if (!currentUserRow) return;\n\n    const currentUserEmail = currentUserRow[emailIndex];\n\n    const sheetId = await getSheetId(SPREADSHEET_ID, SESSIONS_SHEET_NAME);\n    if (sheetId === null) throw new Error('Could not find sheet ID.');\n\n    const deleteRequests = rows\n        .map((row, index) => ({ row, index }))\n        .filter(({ row }) => row[emailIndex] === currentUserEmail && row[tokenIndex] !== currentToken)\n        .map(({ index }) => ({\n            deleteDimension: {\n                range: {\n                    sheetId,\n                    dimension: 'ROWS',\n                    startIndex: index,\n                    endIndex: index + 1,\n                },\n            },\n        }))\n        .reverse(); \n\n    if (deleteRequests.length > 0) {\n        await sheets.spreadsheets.batchUpdate({\n            spreadsheetId: SPREADSHEET_ID,\n            resource: { requests: deleteRequests },\n        });\n        console.log(`[Sessions] Deleted ${deleteRequests.length} other session(s) for user ${currentUserEmail}`);\n    }\n}\n\nexport async function deleteAllSessionsByEmail(email: string) {\n    const sheets = google.sheets({ version: 'v4', auth: await getOAuth2Client() });\n    const range = `${SESSIONS_SHEET_NAME}!A:E`;\n    const response = await sheets.spreadsheets.values.get({\n        spreadsheetId: SPREADSHEET_ID,\n        range,\n    });\n\n    const rows = response.data.values;\n    if (!rows || rows.length < 2) return;\n\n    const header = rows[0];\n    const emailIndex = header.indexOf('emailAddress');\n    \n    const sheetId = await getSheetId(SPREADSHEET_ID, SESSIONS_SHEET_NAME);\n    if (sheetId === null) throw new Error('Could not find sheet ID.');\n\n    const deleteRequests = rows\n        .map((row, index) => ({ row, index }))\n        .filter(({ row, index }) => index > 0 && row[emailIndex] === email)\n        .map(({ index }) => ({\n            deleteDimension: {\n                range: {\n                    sheetId,\n                    dimension: 'ROWS',\n                    startIndex: index,\n                    endIndex: index + 1,\n                },\n            },\n        }))\n        .reverse(); // Reverse to handle shifting indices correctly\n\n    if (deleteRequests.length > 0) {\n        await sheets.spreadsheets.batchUpdate({\n            spreadsheetId: SPREADSHEET_ID,\n            resource: { requests: deleteRequests },\n        });\n        console.log(`[Sessions] Deleted ${deleteRequests.length} session(s) for user ${email}`);\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1163, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/auth/session/route.ts"],"sourcesContent":["\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { findUserByTokenFromSheet } from '@/lib/googlesheets';\n\nexport async function GET(request: NextRequest) {\n  const sessionToken = request.cookies.get('sessionToken')?.value;\n\n  if (!sessionToken) {\n    return NextResponse.json({ isValid: false }, { status: 401 });\n  }\n\n  try {\n    const user = await findUserByTokenFromSheet(sessionToken);\n    if (user) {\n      return NextResponse.json({ isValid: true });\n    } else {\n      return NextResponse.json({ isValid: false }, { status: 401 });\n    }\n  } catch (error) {\n    console.error('API session validation error:', error);\n    return NextResponse.json(\n      { isValid: false, error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// Implement a HEAD method for lightweight session checks if needed\nexport async function HEAD(request: NextRequest) {\n  const sessionToken = request.cookies.get('sessionToken')?.value;\n  if (!sessionToken) {\n    return new Response(null, { status: 401 });\n  }\n  try {\n    const user = await findUserByTokenFromSheet(sessionToken);\n    if (user) {\n        return new Response(null, { status: 200 });\n    } else {\n        return new Response(null, { status: 401 });\n    }\n  } catch (error) {\n    // In case of a backend error, we should deny access for security.\n    return new Response(null, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AACA;AAEA;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,MAAM,eAAe,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB;IAE1D,IAAI,CAAC,cAAc;QACjB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAM,GAAG;YAAE,QAAQ;QAAI;IAC7D;IAEA,IAAI;QACF,MAAM,OAAO,MAAM,CAAA,GAAA,4HAAA,CAAA,2BAAwB,AAAD,EAAE;QAC5C,IAAI,MAAM;YACR,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAK;QAC3C,OAAO;YACL,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAM,GAAG;gBAAE,QAAQ;YAAI;QAC7D;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAAwB,GACjD;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,KAAK,OAAoB;IAC7C,MAAM,eAAe,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB;IAC1D,IAAI,CAAC,cAAc;QACjB,OAAO,IAAI,SAAS,MAAM;YAAE,QAAQ;QAAI;IAC1C;IACA,IAAI;QACF,MAAM,OAAO,MAAM,CAAA,GAAA,4HAAA,CAAA,2BAAwB,AAAD,EAAE;QAC5C,IAAI,MAAM;YACN,OAAO,IAAI,SAAS,MAAM;gBAAE,QAAQ;YAAI;QAC5C,OAAO;YACH,OAAO,IAAI,SAAS,MAAM;gBAAE,QAAQ;YAAI;QAC5C;IACF,EAAE,OAAO,OAAO;QACd,kEAAkE;QAClE,OAAO,IAAI,SAAS,MAAM;YAAE,QAAQ;QAAI;IAC1C;AACF","debugId":null}}]
}